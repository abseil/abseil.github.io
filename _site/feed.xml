<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Abseil Blog &amp; Tips</title>
    <description>An open-source collection of C++ library code designed to
    augment the C++ standard library</description>
    <link>http://0.0.0.0:4000</link>
    
      
        <item>
          <title>Tip of the Week #74: Delegating and Inheriting Constructors</title>
          <description>&lt;p&gt;Originally posted as totw/74 on 2014-04-21&lt;/p&gt;

&lt;p&gt;By Bradley White &lt;a href=&quot;mailto:bww@google.com&quot;&gt;(bww@google.com)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“Delegating work works, provided the one delegating works, too.” – Robert
Half&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;When a class has multiple constructors there is often a need to perform similar
initialization in each variant. To avoid code duplication, many older
classes resort to defining a private &lt;code class=&quot;highlighter-rouge&quot;&gt;SharedInit()&lt;/code&gt; method that is called from
the constructors. For example:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SharedInit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;explicit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SharedInit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;explicit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SharedInit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SharedInit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SharedInit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;…&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;C++11 provides a new mechanism, delegating constructors, for dealing with such
situations more clearly by allowing one constructor to be defined in terms of
another. It is also an efficiency gain if the class has members that are
expensive to default-initialize.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;…&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;explicit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;explicit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Note that if you delegate to another constructor you cannot also use a member
initialization list – all initialization is done by the delegated constructor.
Don’t go overboard though. If all the shared code does is set members, separate
member-initialization lists or in-class initializers are probably clearer than
using delegating constructors. Use good judgement.&lt;/p&gt;

&lt;p class=&quot;note&quot;&gt;
Aside: an object is not considered complete until the delegating constructor
returns; in practice, this only matters if the constructors can throw, as they
leave the delegated-from objects in an incomplete state.
&lt;/p&gt;

&lt;p&gt;Another, less common form of constructor code duplication occurs when extending
the behavior of a multi-constructor class through a wrapper. For example,
consider a “veneer” subclass of C that just adds a new member function.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;D&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NewMethod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;But what of the constructors for D? We’d like to simply re-use those from C
rather than writing out all the forwarding boilerplate, and C++11 allows for
this via the new &lt;em&gt;inheriting constructors&lt;/em&gt; mechanism.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;D&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// inherit all constructors from C
&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NewMethod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This new form of “using” for constructors matches its previous use for
member functions.&lt;/p&gt;

&lt;p&gt;Note, however, that constructors should really only be inherited when the
derived class does not add new data members that need to be initialized
explicitly. Indeed, the style guide cautions against inheriting constructors
unless the new members (if any) have in-class initialization.&lt;/p&gt;

&lt;p&gt;So, go ahead and use C++11’s delegating and inheriting constructors when they
reduce duplication, eliminate forwarding boilerplate, or otherwise make your
classes simpler and clearer.&lt;/p&gt;
</description>
          <pubDate>2017-12-21T00:00:00-05:00</pubDate>
          <link>http://0.0.0.0:4000/tips/74</link>
          <guid isPermaLink="true">http://0.0.0.0:4000/tips/74</guid>
        </item>
      
    
      
        <item>
          <title>Tip of the Week #42: Prefer Factory Functions to Initializer Methods</title>
          <description>&lt;p&gt;Originally posted as totw/42 on 2013-05-10&lt;/p&gt;

&lt;p&gt;By Geoffrey Romer &lt;a href=&quot;mailto:gromer@google.com&quot;&gt;(gromer@google.com)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Revised 2017-12-21&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“The man who builds a factory builds a temple; the man who works there worships
there, and to each is due, not scorn and blame, but reverence and praise.” –
Calvin Coolidge&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;In environments where exceptions are disallowed (such as within Google), C++
constructors effectively must succeed, because they have no way to report
failure to the caller. You can use an &lt;code class=&quot;highlighter-rouge&quot;&gt;abort()&lt;/code&gt;, of course, but doing so
crashes the whole program, which is often unacceptable in production code.&lt;/p&gt;

&lt;p&gt;If your class’s initialization logic can’t avoid the possibility of failure, one
common approach is to give the class an initializer method (also called an “init
method”), which performs any initialization work that might fail, and signals
that failure via its return value. The assumption is usually that the user will
call this method immediately after construction, and if it fails the user will
immediately destroy the object. However, these assumptions are not always
documented, nor always obeyed. It’s all too easy for users to start calling
other methods before initialization, or after initialization has failed.
Sometimes the class actually encourages this behavior, e.g. by providing methods
to configure the object before initializing it, or to read errors out of it
after initialization fails.&lt;/p&gt;

&lt;p&gt;This design commits you to maintaining a class with at least two distinct
user-visible states, and often three: initialized, uninitialized, and
initialization-failed. Making such a design work requires a lot of discipline:
every method of the class has to specify what states it can be called in, and
users have to comply with these rules. If this discipline lapses, client
developers will tend to write whatever code happens to work, regardless of
what you intended to support. When that starts to happen, maintainability
nosedives, because your implementation has to support whatever combinations of
pre-initialization method calls your clients have started to depend on. In
effect, your implementation has become your interface. (See
&lt;a href=&quot;https://hyrumslaw.com&quot;&gt;Hyrum’s Law&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;Fortunately, there’s a simple alternative that lacks these drawbacks: provide a
&lt;em&gt;factory function&lt;/em&gt; which creates and initializes instances of your class, and
returns them by pointer or as &lt;code class=&quot;highlighter-rouge&quot;&gt;absl::optional&lt;/code&gt; (see &lt;a href=&quot;123&quot;&gt;TotW #123&lt;/a&gt;),
using null to indicate failure. Here’s a toy example using &lt;code class=&quot;highlighter-rouge&quot;&gt;unique_ptr&amp;lt;&amp;gt;&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// foo.h
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Factory method: creates and returns a Foo.
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// May return null on failure.
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unique_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// Foo is not copyable.
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

 &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Clients can't invoke the constructor directly.
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// foo.c
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unique_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Note that since Foo's constructor is private, we have to use new.
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;absl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WrapUnique&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In many cases, this pattern gives you the best of both worlds: the factory
function &lt;code class=&quot;highlighter-rouge&quot;&gt;Foo::Create()&lt;/code&gt; exposes only fully-initialized objects like a
constructor, but it can indicate failure like an initializer method. Another
advantage of factory functions is that they can return instances of any subclass
of the return type (though this is not possible if using &lt;code class=&quot;highlighter-rouge&quot;&gt;absl::optional&lt;/code&gt; as
the return type). This allows you to swap in a different implementation
without updating user code, or even choose the implementation class dynamically,
based on user input.&lt;/p&gt;

&lt;p&gt;The primary drawback of this approach is that it returns a pointer to a
heap-allocated object, so it’s not well-suited for “value-like” classes designed
to work on the stack. However, such classes usually don’t require complex
initialization in the first place. Factory functions also can’t be used when a
derived class constructor needs to initialize its base, so initializer methods
are sometimes necessary in the protected API of a base class. The public API can
still use factory functions, though.&lt;/p&gt;
</description>
          <pubDate>2017-12-21T00:00:00-05:00</pubDate>
          <link>http://0.0.0.0:4000/tips/42</link>
          <guid isPermaLink="true">http://0.0.0.0:4000/tips/42</guid>
        </item>
      
    
      
        <item>
          <title>Tip of the Week #131: Special Member Functions and `= default`</title>
          <description>&lt;p&gt;Originally posted as totw/131 on 2017-03-24&lt;/p&gt;

&lt;p&gt;By James Dennett &lt;a href=&quot;mailto:jdennett@google.com&quot;&gt;(jdennett@google.com)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Since the beginning of time, C++ has supported compiler-declared versions of
some so-called &lt;em&gt;special member functions&lt;/em&gt;: the default constructor, destructor,
copy constructor and copy assignment operators. C++11 added move construction
and move assignment to the list, and added syntax (&lt;code class=&quot;highlighter-rouge&quot;&gt;=default&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;=delete&lt;/code&gt;) to
give control over when those defaults are declared and defined.&lt;/p&gt;

&lt;h2 id=&quot;what-does-default-do-and-why-would-we-use-it&quot;&gt;What Does &lt;code class=&quot;highlighter-rouge&quot;&gt;=default&lt;/code&gt; Do, and Why Would We Use It?&lt;/h2&gt;

&lt;p&gt;Writing &lt;code class=&quot;highlighter-rouge&quot;&gt;=default&lt;/code&gt; is our way to tell the compiler “do what you would normally
have done for this special member function”. Why might we want to do this
rather than writing an implementation by hand or leaving the compiler to
declare one for us?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;We can change the access level (e.g., make a constructor &lt;code class=&quot;highlighter-rouge&quot;&gt;protected&lt;/code&gt; instead
of &lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt;), make a destructor virtual, or reinstate a function that would
be suppressed (e.g., a default constructor for a class that has other
user-declared constructors) and still get the compiler to generate the
function for us.&lt;/li&gt;
  &lt;li&gt;Compiler-defined copy and move operations don’t need maintenance every time
members are added or removed, if copying/moving the members is sufficient.&lt;/li&gt;
  &lt;li&gt;Compiler-provided special member functions can be &lt;em&gt;trivial&lt;/em&gt; (when all of the
operations they invoke are themselves trivial), which can make them faster
and safer.&lt;/li&gt;
  &lt;li&gt;Types with defaulted constructors can be &lt;em&gt;aggregates&lt;/em&gt;, and hence support
&lt;em&gt;aggregate initialization&lt;/em&gt;, whereas those with user-provided constructors
cannot.&lt;/li&gt;
  &lt;li&gt;Explicitly declaring a defaulted member gives us a place to document the
semantics of the resulting function.&lt;/li&gt;
  &lt;li&gt;In a class template, &lt;code class=&quot;highlighter-rouge&quot;&gt;=default&lt;/code&gt; is a simple way to declare an operation
conditionally, based on whether some underlying type provides it.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When we use &lt;code class=&quot;highlighter-rouge&quot;&gt;=default&lt;/code&gt; on the initial declaration of a special member function,
the compiler will check whether it can synthesize an inline definition for that
function. If it can, it does. If it can’t, the function is actually declared as
&lt;em&gt;deleted&lt;/em&gt;, just as if we’d written &lt;code class=&quot;highlighter-rouge&quot;&gt;=delete&lt;/code&gt;. That’s just what we’d need for
transparently wrapping a class (say, if we’re defining a class template), but it
can be surprising to readers.&lt;/p&gt;

&lt;p&gt;If a function’s initial declaration uses &lt;code class=&quot;highlighter-rouge&quot;&gt;=default&lt;/code&gt;, or if the compiler declares
a special member function that is not user-declared, an appropriate &lt;code class=&quot;highlighter-rouge&quot;&gt;noexcept&lt;/code&gt;
specification is deduced, potentially allowing faster code.&lt;/p&gt;

&lt;h2 id=&quot;how-does-it-work&quot;&gt;How Does It Work?&lt;/h2&gt;

&lt;p&gt;Before C++11, if we needed a default constructor and already had other
constructors, we’d have written one as:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// User-provided, non-trivial constructor makes A a non-aggregate.
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;From C++11 onwards we have more options.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// misleading: C has a deleted default constructor
&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;private:&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// const =&amp;gt; must always be initialized.
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;D&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// unsurprising, but not explicit: D has a default constructor
&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;private:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unique_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// std::unique_ptr has a default constructor
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Clearly we shouldn’t write code like &lt;code class=&quot;highlighter-rouge&quot;&gt;class C&lt;/code&gt;: in a non-template, use
&lt;code class=&quot;highlighter-rouge&quot;&gt;=default&lt;/code&gt; only if you intend the class to support the operation (and then test
that it does).  &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;clang-tidy&lt;/code&gt;&lt;/em&gt; includes a check for this.&lt;/p&gt;

&lt;p&gt;When &lt;code class=&quot;highlighter-rouge&quot;&gt;=default&lt;/code&gt; is used &lt;em&gt;after&lt;/em&gt; the first declaration of a special member
function (i.e., outside of the class), it has a simpler meaning: it tells the
compiler to define the function, and to give an error if it is unable to do so.
When &lt;code class=&quot;highlighter-rouge&quot;&gt;=default&lt;/code&gt; is used outside of the class, the defaulted function will not be
trivial: triviality is determined by the first declaration (so that all clients
agree on whether the operation is trivial or not).&lt;/p&gt;

&lt;p&gt;If you don’t need your class to be an aggregate and you don’t need the
constructor to be trivial then defaulting the constructor outside of the class
definition, like examples &lt;code class=&quot;highlighter-rouge&quot;&gt;E&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;F&lt;/code&gt; below, is often a good choice.  Its meaning
is clear to readers, and is checked by the compiler.  For the special case of
defaulting a &lt;em&gt;default&lt;/em&gt; constructor or a destructor we could write &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;&lt;/code&gt; instead
of &lt;code class=&quot;highlighter-rouge&quot;&gt;=default&lt;/code&gt;, but for other defaulted operations the compiler-generated
implementation is less simple, and for consistency it’s good to write &lt;code class=&quot;highlighter-rouge&quot;&gt;=default&lt;/code&gt;
in all applicable cases.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// promises to have a default constructor, but...
&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;private:&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// const =&amp;gt; must always be initialized.
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// compilation error here: would not initialize `i`
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;F&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// promises to have a default constructor
&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;private:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unique_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// std::unique_ptr has a default constructor
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// works as expected
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;recommendations&quot;&gt;Recommendations&lt;/h2&gt;

&lt;p&gt;Prefer &lt;code class=&quot;highlighter-rouge&quot;&gt;=default&lt;/code&gt; over writing an equivalent implementation by hand, even
if that implementation is just &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;&lt;/code&gt;. Optionally, omit &lt;code class=&quot;highlighter-rouge&quot;&gt;=default&lt;/code&gt; from the
initial declaration and provide a separate defaulted implementation.&lt;/p&gt;

&lt;p&gt;Be cautious about defaulting move operations. Moved-from objects must still
satisfy the invariants of their type, and the default implementations will
usually not preserve relationships between fields.&lt;/p&gt;

&lt;p&gt;Outside of templates, write &lt;code class=&quot;highlighter-rouge&quot;&gt;=delete&lt;/code&gt; instead if &lt;code class=&quot;highlighter-rouge&quot;&gt;=default&lt;/code&gt; wouldn’t provide an
implementation.&lt;/p&gt;
</description>
          <pubDate>2017-12-07T00:00:00-05:00</pubDate>
          <link>http://0.0.0.0:4000/tips/131</link>
          <guid isPermaLink="true">http://0.0.0.0:4000/tips/131</guid>
        </item>
      
    
      
        <item>
          <title>Tip of the Week #123: &lt;code&gt;absl::optional&lt;/code&gt; and &lt;code&gt;std::unique_ptr&lt;/code&gt;</title>
          <description>&lt;p&gt;Originally posted as totw/123 on 2016-09-06&lt;/p&gt;

&lt;p&gt;By Alexey Sokolov &lt;a href=&quot;mailto:sokolov@google.com&quot;&gt;(sokolov@google.com)&lt;/a&gt; and 
Etienne Dechamps &lt;a href=&quot;mailto:edechamps@google.com&quot;&gt;(edechamps@google.com)&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;how-to-store-values&quot;&gt;How to Store Values&lt;/h2&gt;

&lt;p&gt;This tip discusses several ways of storing values. Here we use class member
variables as an example, but many of the points below also apply to local
variables.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;memory&amp;gt;
#include &quot;third_party/absl/types/optional.h&quot;
#include &quot;.../bar.h&quot;
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;absl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;opt_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unique_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptr_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;as-a-bare-object&quot;&gt;As a Bare Object&lt;/h3&gt;

&lt;p&gt;This is the simplest way. &lt;code class=&quot;highlighter-rouge&quot;&gt;val_&lt;/code&gt; is constructed and destroyed at the beginning
of &lt;code class=&quot;highlighter-rouge&quot;&gt;Foo&lt;/code&gt;’s constructor and at the end of &lt;code class=&quot;highlighter-rouge&quot;&gt;Foo&lt;/code&gt;’s destructor, respectively. If
&lt;code class=&quot;highlighter-rouge&quot;&gt;Bar&lt;/code&gt; has a default constructor, it doesn’t even need to be initialized
explicitly.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;val_&lt;/code&gt; is very safe to use, because its value can’t be null. This removes a
class of potential bugs.&lt;/p&gt;

&lt;p&gt;But bare objects are not very flexible:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The lifetime of &lt;code class=&quot;highlighter-rouge&quot;&gt;val_&lt;/code&gt; is fundamentally tied to the lifetime of its parent
&lt;code class=&quot;highlighter-rouge&quot;&gt;Foo&lt;/code&gt; object, which is sometimes not desirable. If &lt;code class=&quot;highlighter-rouge&quot;&gt;Bar&lt;/code&gt; supports move or
swap operations, the contents of &lt;code class=&quot;highlighter-rouge&quot;&gt;val_&lt;/code&gt; can be replaced using these
operations, while any existing pointers or references to &lt;code class=&quot;highlighter-rouge&quot;&gt;val_&lt;/code&gt; continue
pointing or referring to the same &lt;code class=&quot;highlighter-rouge&quot;&gt;val_&lt;/code&gt; object (as a container), not to the
value stored in it.&lt;/li&gt;
  &lt;li&gt;Any arguments that need to be passed to &lt;code class=&quot;highlighter-rouge&quot;&gt;Bar&lt;/code&gt;’s constructor need to be
computed inside the initializer list of &lt;code class=&quot;highlighter-rouge&quot;&gt;Foo&lt;/code&gt;’s constructor, which can be
difficult if complicated expressions are involved.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;as-absloptionalbar&quot;&gt;As &lt;code class=&quot;highlighter-rouge&quot;&gt;absl::optional&amp;lt;Bar&amp;gt;&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;This is a good middle ground between the simplicity of bare objects and the
flexibility of &lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&lt;/code&gt;. The object is stored inside &lt;code class=&quot;highlighter-rouge&quot;&gt;Foo&lt;/code&gt; but, unlike
bare objects, &lt;code class=&quot;highlighter-rouge&quot;&gt;absl::optional&lt;/code&gt; can be empty. It can be populated at any time by
assignment (&lt;code class=&quot;highlighter-rouge&quot;&gt;opt_ = ...&lt;/code&gt;) or by constructing the object in place
(&lt;code class=&quot;highlighter-rouge&quot;&gt;opt_.emplace(...)&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Because the object is stored inline, the usual caveats about allocating large
objects on the stack apply, just like for a bare object. Also be aware that an
empty &lt;code class=&quot;highlighter-rouge&quot;&gt;absl::optional&lt;/code&gt; uses as much memory as a populated one.&lt;/p&gt;

&lt;p&gt;Compared to a bare object, &lt;code class=&quot;highlighter-rouge&quot;&gt;absl::optional&lt;/code&gt; has a few downsides:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;It’s less obvious for the reader where object construction and destruction
occur.&lt;/li&gt;
  &lt;li&gt;There is a risk of accessing an object which does not exist.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;as-stdunique_ptrbar&quot;&gt;As &lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&amp;lt;Bar&amp;gt;&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;This is the most flexible way. The object is stored outside of &lt;code class=&quot;highlighter-rouge&quot;&gt;Foo&lt;/code&gt;. Just like
&lt;code class=&quot;highlighter-rouge&quot;&gt;absl::optional&lt;/code&gt;, a &lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&lt;/code&gt; can be empty. However, unlike
&lt;code class=&quot;highlighter-rouge&quot;&gt;absl::optional&lt;/code&gt;, it is possible to transfer ownership of the object to
something else (through a move operation), to take ownership of the object from
something else (at construction or through assignment), or to assume ownership
of a raw pointer (at construction or through &lt;code class=&quot;highlighter-rouge&quot;&gt;ptr_ = absl::WrapUnique(...)&lt;/code&gt;, see
&lt;a href=&quot;/tips/126&quot;&gt;TotW 126&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;When &lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&lt;/code&gt; is null, it doesn’t have the object allocated, and
consumes only the size of a pointer&lt;sup id=&quot;fnref:deleter&quot;&gt;&lt;a href=&quot;#fn:deleter&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;Wrapping an object in a &lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&lt;/code&gt; is necessary if the object may need to
outlive the scope of the &lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&lt;/code&gt; (ownership transfer).&lt;/p&gt;

&lt;p&gt;This flexibility comes with some costs:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Increased cognitive load on the reader:
    &lt;ul&gt;
      &lt;li&gt;It’s less obvious what’s stored inside (&lt;code class=&quot;highlighter-rouge&quot;&gt;Bar&lt;/code&gt;, or something derived from
&lt;code class=&quot;highlighter-rouge&quot;&gt;Bar&lt;/code&gt;). However, it may also decrease the cognitive load, as the reader
can focus only on the base interface held by the pointer.&lt;/li&gt;
      &lt;li&gt;It’s even less obvious than with &lt;code class=&quot;highlighter-rouge&quot;&gt;absl::optional&lt;/code&gt; where object
construction and destruction occur, because ownership of the object can
be transferred.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;As with &lt;code class=&quot;highlighter-rouge&quot;&gt;absl::optional&lt;/code&gt;, there is a risk of accessing an object which does
not exist - the famous null pointer dereference.&lt;/li&gt;
  &lt;li&gt;The pointer introduces an additional level of indirection, which requires a
heap allocation, and is &lt;a href=&quot;https://en.wikipedia.org/wiki/Locality_of_reference&quot;&gt;not
friendly&lt;/a&gt; to CPU
caches; Whether this matters or not depends a lot on particular use cases.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&amp;lt;Bar&amp;gt;&lt;/code&gt; is not copyable even if &lt;code class=&quot;highlighter-rouge&quot;&gt;Bar&lt;/code&gt; is. This also prevents
&lt;code class=&quot;highlighter-rouge&quot;&gt;Foo&lt;/code&gt; from being copyable.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;As always, strive to avoid unnecessary complexity, and use the simplest thing
that works. Prefer bare object, if it works for your case. Otherwise, try
&lt;code class=&quot;highlighter-rouge&quot;&gt;absl::optional&lt;/code&gt;. As a last resort, use &lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&lt;/code&gt;.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
  &lt;tr&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Bar&lt;/code&gt;&lt;/th&gt;
    &lt;th&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;absl::optional&amp;lt;Bar&amp;gt;&lt;/code&gt;&lt;/th&gt;
    &lt;th&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&amp;lt;Bar&amp;gt;&lt;/code&gt;&lt;/th&gt;
  &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
  &lt;tr&gt;
    &lt;td&gt;Supports delayed construction&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
    &lt;td&gt;✓&lt;/td&gt;
    &lt;td&gt;✓&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Always safe to access&lt;/td&gt;
    &lt;td&gt;✓&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Can transfer ownership of &lt;code class=&quot;highlighter-rouge&quot;&gt;Bar&lt;/code&gt;&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
    &lt;td&gt;✓&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Can store subclasses of &lt;code class=&quot;highlighter-rouge&quot;&gt;Bar&lt;/code&gt;&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
    &lt;td&gt;✓&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Movable&lt;/td&gt;
    &lt;td&gt;If &lt;code class=&quot;highlighter-rouge&quot;&gt;Bar&lt;/code&gt; is movable&lt;/td&gt;
    &lt;td&gt;If &lt;code class=&quot;highlighter-rouge&quot;&gt;Bar&lt;/code&gt; is movable&lt;/td&gt;
    &lt;td&gt;✓&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Copyable&lt;/td&gt;
    &lt;td&gt;If &lt;code class=&quot;highlighter-rouge&quot;&gt;Bar&lt;/code&gt; is copyable&lt;/td&gt;
    &lt;td&gt;If &lt;code class=&quot;highlighter-rouge&quot;&gt;Bar&lt;/code&gt; is copyable&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Friendly to CPU caches&lt;/td&gt;
    &lt;td&gt;✓&lt;/td&gt;
    &lt;td&gt;✓&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;No heap allocation overhead&lt;/td&gt;
    &lt;td&gt;✓&lt;/td&gt;
    &lt;td&gt;✓&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Memory usage&lt;/td&gt;
    &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof(Bar)&lt;/code&gt;&lt;/td&gt;
    &lt;td&gt;&lt;nobr&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof(Bar) + sizeof(bool)&lt;/code&gt;&lt;/nobr&gt;&lt;sup id=&quot;fnref:padding&quot;&gt;&lt;a href=&quot;#fn:padding&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof(Bar*)&lt;/code&gt; when null, &lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof(Bar*) + sizeof(Bar)&lt;/code&gt; otherwise&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Object lifetime&lt;/td&gt;
    &lt;td&gt;Same as enclosing scope&lt;/td&gt;
    &lt;td&gt;Restricted to enclosing scope&lt;/td&gt;
    &lt;td&gt;Unrestricted&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Call &lt;code class=&quot;highlighter-rouge&quot;&gt;f(Bar*)&lt;/code&gt;&lt;/td&gt;
    &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;f(&amp;amp;val_)&lt;/code&gt;&lt;/td&gt;
    &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;f(&amp;amp;opt_.value())&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;f(&amp;amp;*opt_)&lt;/code&gt;&lt;/td&gt;
    &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;f(ptr_.get())&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;f(&amp;amp;*ptr_)&lt;/code&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Remove value&lt;/td&gt;
    &lt;td&gt;N/A&lt;/td&gt;
    &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;opt_.reset();&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;opt_ = absl::nullopt;&lt;/code&gt;&lt;/td&gt;
    &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ptr_.reset();&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;ptr_ = nullptr;&lt;/code&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:deleter&quot;&gt;
      &lt;p&gt;In case of a non-empty custom deleter there is also an additional
space for that deleter.&amp;nbsp;&lt;a href=&quot;#fnref:deleter&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:padding&quot;&gt;
      &lt;p&gt;Also padding may be added.&amp;nbsp;&lt;a href=&quot;#fnref:padding&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
          <pubDate>2017-12-07T00:00:00-05:00</pubDate>
          <link>http://0.0.0.0:4000/tips/123</link>
          <guid isPermaLink="true">http://0.0.0.0:4000/tips/123</guid>
        </item>
      
    
      
        <item>
          <title>Tip of the Week #130: Namespace Naming</title>
          <description>&lt;p&gt;Originally posted as totw/130 on 2017-02-17&lt;/p&gt;

&lt;p&gt;By Titus Winters &lt;a href=&quot;mailto:titus@google.com&quot;&gt;(titus@google.com)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The precision of naming takes away from the uniqueness of seeing&lt;/em&gt; — Pierre
Bonnard&lt;/p&gt;

&lt;p&gt;The earliest commit of the Google C++ Style Guide contains the guidance that
many people are still using for namespace naming. Roughly, this can be
summarized as “namespaces are derived from package paths.” Following on
the heels of Java’s package naming requirements, this makes a lot of sense: we
want to be able to uniquely identify symbols in C++ and we want there to be
uniqueness and consistency in namespace choice.&lt;/p&gt;

&lt;p&gt;Except in actuality, we don’t. We just didn’t realize for almost a decade.&lt;/p&gt;

&lt;h2 id=&quot;name-lookup&quot;&gt;Name Lookup&lt;/h2&gt;

&lt;p&gt;Let’s start with how name lookup works in C++ and how it’s different from Java.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Baz&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In C++, lookup on an unqualified name (&lt;code class=&quot;highlighter-rouge&quot;&gt;Baz&lt;/code&gt;) will search expanding scopes for a
symbol of the same name: first in &lt;code class=&quot;highlighter-rouge&quot;&gt;f()&lt;/code&gt; (the function), then in &lt;code class=&quot;highlighter-rouge&quot;&gt;bar&lt;/code&gt;, then in
&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;, then in the global namespace.&lt;/p&gt;

&lt;p&gt;In Java, there is no such thing as an unqualified symbol: either a symbol is
a qualified name:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;com&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;google&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Baz&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;com&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;google&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Baz&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Or it is imported, either as a single package member or via wildcard:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;com.google.foo.bar.Baz&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;com.google.foo.bar.*&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In no case is &lt;code class=&quot;highlighter-rouge&quot;&gt;Baz&lt;/code&gt; looked for outside of the package that is explicitly
provided: wildcards don’t descend into child packages, nor is search extended
into parent packages. As it turns out, this difference in how parent
packages/namespaces are handled within Java and C++ is fundamental to why
structural namespace naming (making the namespace structure match the package
hierarchy) is a mistake within C++.&lt;/p&gt;

&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;/h2&gt;

&lt;p&gt;The fundamental problem for building namespaces out of packages is that we
rarely rely on fully-qualified lookup in C++, normally writing &lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&lt;/code&gt;
rather than &lt;code class=&quot;highlighter-rouge&quot;&gt;::std::unique_ptr&lt;/code&gt;. Coupled with lookup in enclosing namespaces,
this means that for code in a deeply nested package
(&lt;code class=&quot;highlighter-rouge&quot;&gt;::division::section::team::subteam::project&lt;/code&gt;, for example) any symbol that is not
fully qualified (&lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&lt;/code&gt;) can in fact reference any of&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;::std::unique_ptr&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;::division::std::unique_ptr&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;::division::section::std::unique_ptr&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;::division::section::team::std::unique_ptr&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;::division::section::team::subteam::std::unique_ptr&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;::division::section::team::subteam::project::std::unique_ptr&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And what’s worse: unqualified search starts at the bottom of that list &lt;em&gt;and
stops as soon as there is a namespace match&lt;/em&gt;. This means that your build can be
broken if any of your transitive includes add a previously unused namespace that
matches the leading namespace of any symbol you use out of an unqualified
namespace. Strictly speaking, this doesn’t even have to be a build break: if
someone adds something with a matching name and a syntactically-compatible API,
the implementation of that API may be completely incompatible and cause
widespread havoc at runtime. Obviously this isn’t too bad with &lt;code class=&quot;highlighter-rouge&quot;&gt;std&lt;/code&gt; - nobody
should ever be adding a nested namespace &lt;code class=&quot;highlighter-rouge&quot;&gt;std&lt;/code&gt; -  but what about more common
namespaces? How about things like &lt;code class=&quot;highlighter-rouge&quot;&gt;testing&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;Names aren’t chosen to be unique. Since teams commonly create local utility
packages to handle common tasks relating to the infrastructure they rely on, we
wind up with local &lt;code class=&quot;highlighter-rouge&quot;&gt;util&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;pipeline&lt;/code&gt; packages - and
sub-namespaces. This is a recipe for unnecessary and unintended collisions.&lt;/p&gt;

&lt;p&gt;For comparison, the problem in Java is far reduced: if you wildcard-import from
two packages in Java and one adds a new symbol with the same name as the other
package, your build can break. This is easily and completely solved by
forbidding wildcard imports as is done in many Java styles.&lt;/p&gt;

&lt;h2 id=&quot;two-consistent-options-three-approaches&quot;&gt;Two Consistent Options, Three Approaches&lt;/h2&gt;

&lt;p&gt;There are two features that prevent this build-break-at-a-distance:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If no leaf namespace (&lt;code class=&quot;highlighter-rouge&quot;&gt;search::foo::bar&lt;/code&gt;) matches any top-level namespace
(&lt;code class=&quot;highlighter-rouge&quot;&gt;::bar&lt;/code&gt;) or a sub-namespace of any parent of that leaf (&lt;code class=&quot;highlighter-rouge&quot;&gt;search::bar&lt;/code&gt;), no
name collisions will occur.&lt;/li&gt;
  &lt;li&gt;If there are no unqualified lookups, there will be no problems.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There are (at least) three ways to achieve this:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Always fully qualify everything outside of the current namespace. This is
very verbose and sort of weird: nothing in C++ (including the standard
library) is written with leading &lt;code class=&quot;highlighter-rouge&quot;&gt;::&lt;/code&gt; on every symbol.&lt;/li&gt;
  &lt;li&gt;Build some tooling to identify introduction of new namespaces and ensure
that it doesn’t overlap with any other namespace in the same hierarchy. That
is, do not add &lt;code class=&quot;highlighter-rouge&quot;&gt;search::bar&lt;/code&gt; if there is a &lt;code class=&quot;highlighter-rouge&quot;&gt;::bar&lt;/code&gt; or a &lt;code class=&quot;highlighter-rouge&quot;&gt;search::foo::bar&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Don’t nest deeply: a single top-level namespace per project gets the same
result without long/complicated names, with less exposure to accidents,
without causing surprise for new engineers, and without the need to build any
tooling.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The current style guide suggests the &lt;a href=&quot;http://google.github.io/styleguide/cppguide.html#Namespace_Names&quot;&gt;last
option&lt;/a&gt;, but
allows for the old style (namespaces match package names) if necessary. This is
largely because the Google didn’t want to cause too much anxiety or
trigger anyone re-namespacing things. That said, if we had it to do over again
in a fresh codebase we would unambiguously say this: one top-level namespace for
public interfaces per project. Ensure uniqueness of namespaces via a common
database. Thus we get (only) top-level namespaces like &lt;code class=&quot;highlighter-rouge&quot;&gt;absl&lt;/code&gt;, and can have no
ambiguity in lookup (barring collision between local symbols and those in the
global namespace, but modern rules discourage the global namespace anyway).&lt;/p&gt;

&lt;p&gt;Because there is so much code that existed before this change, and so much code
following the old pattern even after this change, we find ourselves in a sort of
half-way space, with some namespaces that often need to be fully qualified
(&lt;code class=&quot;highlighter-rouge&quot;&gt;::util&lt;/code&gt;), and some that are obviously unique and never need to be (&lt;code class=&quot;highlighter-rouge&quot;&gt;std&lt;/code&gt;).&lt;/p&gt;

&lt;h2 id=&quot;but-it-keeps-things-organized&quot;&gt;But It Keeps Things Organized!&lt;/h2&gt;

&lt;p&gt;I regularly hear people express that small/nested namespaces “keep things
organized.” Putting things in their place feels right - why lump together
something like &lt;code class=&quot;highlighter-rouge&quot;&gt;StrCat()&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;make_unique()&lt;/code&gt; other than being in Abseil these
have nothing to do with one another! Wouldn’t an &lt;code class=&quot;highlighter-rouge&quot;&gt;absl::strings::utilities&lt;/code&gt;
namespace help differentiate from &lt;code class=&quot;highlighter-rouge&quot;&gt;absl::smart_ptrs&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;In other languages this would probably be good - better organization with no
downside. However, because of how lookup works (expanding into successive layers
of containing namespace scopes) your fine-grained namespace is impacted by every
symbol (and sub-namespace) added in every parent namespace. That is: while you
don’t exactly “contain” the names from parent namespaces, name/namespace
collisions matter nearly as much as if you do. Small/deeply-nested namespaces
don’t &lt;em&gt;shield&lt;/em&gt; you from this, they &lt;em&gt;exacerbate&lt;/em&gt; it.&lt;/p&gt;

&lt;h2 id=&quot;best-practices&quot;&gt;Best Practices&lt;/h2&gt;

&lt;p&gt;Practically speaking, the following is the best we can do given the
realities of most codebases:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Have a database of some form for a codebase to identify the unique namespaces.&lt;/li&gt;
  &lt;li&gt;When introducing a new namespace, use that database and introduce it as
a top-level.&lt;/li&gt;
  &lt;li&gt;If for some reason the above is impossible, never &lt;em&gt;ever&lt;/em&gt; introduce a
sub-namespace that matches a well-known top-level namespace. No
sub-namespaces for &lt;code class=&quot;highlighter-rouge&quot;&gt;absl&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;testing&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;util&lt;/code&gt;, etc. Try to give
sub-namespaces unique names that are unlikely to collide with future
top-levels.&lt;/li&gt;
  &lt;li&gt;When declaring namespace aliases and using-declarations, use fully qualified
names, unless you are referring to a name inside the current namespace, as
per &lt;a href=&quot;/tips/119&quot;&gt;TotW 119&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;For code in &lt;code class=&quot;highlighter-rouge&quot;&gt;util&lt;/code&gt; or other commonly-abused namespaces, try to avoid full
qualification, but qualify if necessary.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The advice in &lt;a href=&quot;/tips/119&quot;&gt;TotW 119&lt;/a&gt; also helps, for &lt;code class=&quot;highlighter-rouge&quot;&gt;.cc&lt;/code&gt; files: our concern with
fully-qualifying is not that it is bad, but that it is &lt;em&gt;weird&lt;/em&gt; compared to C++
code in the rest of the world. Limited use in using-declarations strikes an
acceptable balance. However, even complete adherence to this suggestion doesn’t
fully mitigate the dangers from unqualified name lookup because we still have
header files and don’t want to fully qualify every symbol in every header.&lt;/p&gt;
</description>
          <pubDate>2017-11-30T00:00:00-05:00</pubDate>
          <link>http://0.0.0.0:4000/tips/130</link>
          <guid isPermaLink="true">http://0.0.0.0:4000/tips/130</guid>
        </item>
      
    
      
        <item>
          <title>Tip of the Week #119: Using-declarations and namespace aliases</title>
          <description>&lt;p&gt;Originally posted as totw/119 on 2016-07-14&lt;/p&gt;

&lt;p&gt;By Thomas Köppe &lt;a href=&quot;mailto:tkoeppe@google.com&quot;&gt;(tkoeppe@google.com)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This tip gives a simple, robust recipe for writing &lt;em&gt;using-declarations&lt;/em&gt; and
namespace aliases in &lt;code class=&quot;highlighter-rouge&quot;&gt;.cc&lt;/code&gt; files that avoids subtle pitfalls.&lt;/p&gt;

&lt;p&gt;Before we dive into the details, here is an example of the recipe in action:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;example&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;makers&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;otherlib&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BazBuilder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mylib&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BarFactory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;abc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;applied&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bitfiddling&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;concepts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Private helper code here.
&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// namespace
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Interface implementation code here.
&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// namespace makers
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// namespace example
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Remember that everything in this tip applies only to &lt;code class=&quot;highlighter-rouge&quot;&gt;.cc&lt;/code&gt; files, since you
should &lt;a href=&quot;http://google.github.io/styleguide/cppguide.html#Aliases&quot;&gt;never put convenience aliases in header
files&lt;/a&gt;. Such aliases
are a convenience for the implementer (and the reader of an implementation), not
an exported facility. (Names that &lt;em&gt;are&lt;/em&gt; part of the exported API may of course
be declared in headers.)&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Never declare namespace aliases or convenience &lt;em&gt;using-declaration&lt;/em&gt;s
at namespace scope in header files, only in &lt;code class=&quot;highlighter-rouge&quot;&gt;.cc&lt;/code&gt; files.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Declare namespace aliases and &lt;em&gt;using-declaration&lt;/em&gt;s inside the
innermost namespace, whether named or anonymous. (Do not add an anonymous
namespace just for this purpose.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When declaring namespace aliases and &lt;em&gt;using-declaration&lt;/em&gt;s, use fully
qualified names (with leading &lt;code class=&quot;highlighter-rouge&quot;&gt;::&lt;/code&gt;) unless you are referring to a name
inside the current namespace.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;For other uses of names, avoid fully qualifying when reasonable; see
&lt;a href=&quot;/tips/130&quot;&gt;TotW 130&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(Remember that you can always have a local namespace alias or
&lt;em&gt;using-declaration&lt;/em&gt; in a block scope, which can be handy in header-only
libraries.)&lt;/p&gt;

&lt;h2 id=&quot;background&quot;&gt;Background&lt;/h2&gt;

&lt;p&gt;C++ organizes names into &lt;em&gt;namespaces&lt;/em&gt;. This crucial facility allows code bases
to scale by keeping ownership of names local avoiding name collisions in other
scopes. However, namespaces impose a certain cosmetic burden, since qualified
names (&lt;code class=&quot;highlighter-rouge&quot;&gt;foo::Bar&lt;/code&gt;) are often long and quickly become clutter. We often find it
convenient to use &lt;em&gt;unqualified names&lt;/em&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;Bar&lt;/code&gt;). Additionally, we may wish to
introduce a namespace alias for a long but frequently used namespace: &lt;code class=&quot;highlighter-rouge&quot;&gt;namespace
eu = example::v1::util;&lt;/code&gt; We will collectively call &lt;em&gt;using-declaration&lt;/em&gt;s
and namespace aliases just &lt;em&gt;aliases&lt;/em&gt; in this tip.&lt;/p&gt;

&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;/h2&gt;

&lt;p&gt;The purpose of a namespace is to help code authors avoid name collisions, both
at the point of name lookup and at the point of linking. Aliases can potentially
undermine the protection afforded by namespaces. The problem has two separate
aspects: the scope of the alias, and the use of relative qualifiers.&lt;/p&gt;

&lt;h3 id=&quot;scope-of-the-alias&quot;&gt;Scope of the Alias&lt;/h3&gt;

&lt;p&gt;The scope at which you place an alias can have subtle effects on code
maintainability. Consider the following two variants:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Quz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;example&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;util&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;It appears that both &lt;em&gt;using-declaration&lt;/em&gt;s are effective at making the
names &lt;code class=&quot;highlighter-rouge&quot;&gt;Bar&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Quz&lt;/code&gt; available for unqualified lookup inside our working
namespace &lt;code class=&quot;highlighter-rouge&quot;&gt;::example::util&lt;/code&gt;. For &lt;code class=&quot;highlighter-rouge&quot;&gt;Bar&lt;/code&gt;, everything is working as expected,
provided there is no other declaration of &lt;code class=&quot;highlighter-rouge&quot;&gt;Bar&lt;/code&gt; inside namespace
&lt;code class=&quot;highlighter-rouge&quot;&gt;::example::util&lt;/code&gt;. But this is your namespace, so it is in your power to control
this.&lt;/p&gt;

&lt;p&gt;On the other hand, if a header is later included that declares a global name
&lt;code class=&quot;highlighter-rouge&quot;&gt;Quz&lt;/code&gt;, then the first &lt;em&gt;using-declaration&lt;/em&gt; becomes ill-formed, as it attempts to
redeclare the name &lt;code class=&quot;highlighter-rouge&quot;&gt;Quz&lt;/code&gt;. And if another header declares &lt;code class=&quot;highlighter-rouge&quot;&gt;::example::Quz&lt;/code&gt; or
&lt;code class=&quot;highlighter-rouge&quot;&gt;::example::util::Quz&lt;/code&gt;, then unqualified lookup will find &lt;em&gt;that&lt;/em&gt; name rather
than your alias.&lt;/p&gt;

&lt;p&gt;This brittleness can be avoided if you do not add names to namespaces that you
do not own (which includes the global namespace). By placing the aliases inside
your own namespace, the unqualified lookup finds your alias first and never
continues to search containing namespaces.&lt;/p&gt;

&lt;p&gt;More generally, the closer a declaration is to the point of use, the smaller is
the set of scopes that can break your code. At the worst end of our example is
&lt;code class=&quot;highlighter-rouge&quot;&gt;Quz&lt;/code&gt;, which can be broken by anyone; &lt;code class=&quot;highlighter-rouge&quot;&gt;Bar&lt;/code&gt; can only be broken by other code in
&lt;code class=&quot;highlighter-rouge&quot;&gt;::example::util&lt;/code&gt;, and a name that is declared and used inside an unnamed
namespace cannot be broken by any other scope. See &lt;a href=&quot;#unnamed-namespaces&quot;&gt;Unnamed
Namespaces&lt;/a&gt; for an example.&lt;/p&gt;

&lt;h3 id=&quot;relative-qualifiers&quot;&gt;Relative Qualifiers&lt;/h3&gt;

&lt;p&gt;A &lt;em&gt;using-declaration&lt;/em&gt; of the form &lt;code class=&quot;highlighter-rouge&quot;&gt;using foo::Bar&lt;/code&gt; seems innocuous, but it is in
fact ambiguous. The problem is that it is safe to rely on the &lt;em&gt;existence&lt;/em&gt; of
names in a namespace, but it is not safe to rely on the &lt;em&gt;absence&lt;/em&gt; of names.
Consider this code:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;example&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;util&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;It is perhaps the author’s intention to use the name &lt;code class=&quot;highlighter-rouge&quot;&gt;::foo::Bar&lt;/code&gt;.
However, this can break, because the code is relying on the existence of
&lt;code class=&quot;highlighter-rouge&quot;&gt;::foo::Bar&lt;/code&gt; &lt;em&gt;and also&lt;/em&gt; on the non-existence of namespaces &lt;code class=&quot;highlighter-rouge&quot;&gt;::example::foo&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;::example::util::foo&lt;/code&gt;. This brittleness can be avoided by qualifying the used
name fully: &lt;code class=&quot;highlighter-rouge&quot;&gt;using ::foo::Bar&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The only time that a relative name is unambiguous and cannot possibly be broken
by outside declarations is if it refers to a name that is already inside your
current namespace:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;example&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;util&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;internal&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Params&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// namespace internal
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;internal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// OK, same as ::example::util::internal::Params
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This follows the same logic that we discussed in the previous section.&lt;/p&gt;

&lt;p&gt;What if a name lives in a sibling namespace, such as &lt;code class=&quot;highlighter-rouge&quot;&gt;::example::tools::Thing&lt;/code&gt;?
You can say either &lt;code class=&quot;highlighter-rouge&quot;&gt;tools::Thing&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;::example::tools::Thing&lt;/code&gt;. The fully
qualified name is always correct, but it may also be appropriate to use the
relative name. Use your own judgment.&lt;/p&gt;

&lt;p&gt;A cheap way to avoid a lot of these problems is not to use namespaces in your
project that are the same as popular top-level namespaces (such as &lt;code class=&quot;highlighter-rouge&quot;&gt;util&lt;/code&gt;); the
Style Guide &lt;a href=&quot;http://google.github.io/styleguide/cppguide.html#Namespace_Names&quot;&gt;recommends this practice&lt;/a&gt; explicitly.&lt;/p&gt;

&lt;h3 id=&quot;demo&quot;&gt;Demo&lt;/h3&gt;

&lt;p&gt;The following code shows examples of both failure modes.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;helper.h:&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// namespace foo
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// namespace bar
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;some_feature.h:&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Your code:&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &quot;helper.h&quot;
#include &quot;some_feature.h&quot;
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// namespace foo
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Failure mode #1: Alias at a bad scope.
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// Error: redeclaration (because of &quot;f&quot; declared in some_feature.h)
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Failure mode #2: Alias badly qualified.
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// Error: No &quot;f&quot; in namespace ::bar::foo (because that namespace was declared in helper.h)
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// The recommended way, robust in the face of unrelated declarations:
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// OK
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;UseCase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// namespace bar
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;unnamed-namespaces&quot;&gt;Unnamed Namespaces&lt;/h2&gt;

&lt;p&gt;A &lt;em&gt;using-declaration&lt;/em&gt; placed in an unnamed namespace can be accessed from the
enclosing namespace and vice versa. If you already have an unnamed namespace at
the top of the file, prefer putting all aliases there. From within that unnamed
namespace, you gain an extra little bit of robustness against clashing with
something declared in the enclosing namespace.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;example&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;util&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Put all using-declarations in here. Don't spread them over the file.
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Quz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// In here, Bar and Quz refer inalienably to your aliases.
&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// namespace
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Can use both Bar and Quz here too. (But don't declare any entities called Bar or Quz yourself now.)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;non-aliased-names&quot;&gt;Non-aliased names&lt;/h2&gt;

&lt;p&gt;So far we have been talking about local aliases for distant names. But what if
we want to use names directly and not create aliases at all? Should we say
&lt;code class=&quot;highlighter-rouge&quot;&gt;util::Status&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;::util::Status&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;There is no obvious answer. Unlike the alias declarations that we have been
discussing until now, which appear at the top of the file far away from the
actual code, the direct use of names affects the local readability of your code.
While it is true that relatively qualified names may break in the future, there
is a significant cost for using absolute qualifications. The visual clutter
caused by the leading &lt;code class=&quot;highlighter-rouge&quot;&gt;::&lt;/code&gt; may well be distracting and not worth the added
robustness. In this case, use your own judgment to decide which style you
prefer. See &lt;a href=&quot;/tips/130&quot;&gt;TotW 130&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;acknowledgments&quot;&gt;Acknowledgments&lt;/h2&gt;

&lt;p&gt;All credit is due to Roman Perepelitsa (romanp@google.com) who originally
suggested this style in a mailing list discussion and who contributed numerous
corrections and punchlines. However, all errors are mine.&lt;/p&gt;
</description>
          <pubDate>2017-11-30T00:00:00-05:00</pubDate>
          <link>http://0.0.0.0:4000/tips/119</link>
          <guid isPermaLink="true">http://0.0.0.0:4000/tips/119</guid>
        </item>
      
    
      
        <item>
          <title>CppCon 2017: How to Break an ABI</title>
          <description>&lt;h2 id=&quot;gennadiy-rozentals-lightning-talk&quot;&gt;Gennadiy Rozental’s Lightning Talk&lt;/h2&gt;

&lt;p&gt;By &lt;a href=&quot;mailto:shreck@google.com&quot;&gt;Tom Manshreck&lt;/a&gt;, Abseil Tech Writer&lt;/p&gt;

&lt;p&gt;Breaking an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application_binary_interface&quot; target=&quot;_blank&quot;&gt;ABI&lt;/a&gt;
is seldom your first choice, but what do you do if you simply must
break this contract with your developers?&lt;/p&gt;

&lt;p&gt;Check out Gennadiy Rozental’s talk on how we implemented our own &lt;code class=&quot;highlighter-rouge&quot;&gt;::string&lt;/code&gt;
class in Google, decided we eventually should move back to a &lt;code class=&quot;highlighter-rouge&quot;&gt;std::string&lt;/code&gt;,
and how we kept Google’s engineers happy during the transition.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=NzaYUlAw93k&quot; target=&quot;_blank&quot;&gt;
&lt;img src=&quot;/img/cppcon-breaking-abi.png&quot; /&gt;
&lt;/a&gt;&lt;/p&gt;
</description>
          <pubDate>2017-11-30T00:00:00-05:00</pubDate>
          <link>http://0.0.0.0:4000/blog/20171023-cppcon-breaking-abi</link>
          <guid isPermaLink="true">http://0.0.0.0:4000/blog/20171023-cppcon-breaking-abi</guid>
        </item>
      
    
      
        <item>
          <title>Tip of the Week #126: `make_unique` is the new `new`</title>
          <description>&lt;p&gt;Originally posted as totw/126 on 2016-12-12&lt;/p&gt;

&lt;p&gt;By James Dennett &lt;a href=&quot;mailto:jdennett@google.com&quot;&gt;(jdennett@google.com)&lt;/a&gt; based on a
mailing list post by Titus Winters &lt;a href=&quot;mailto:titus@google.com&quot;&gt;(titus@google.com)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;As a codebase expands it is increasingly difficult to know the details of
everything you depend on. Requiring deep knowledge doesn’t scale: we have to
rely on interfaces and contracts to know that code is correct, both when writing
and when reviewing. In many cases the type system can provide those contracts in
a common fashion. Consistent use of type system contracts makes for easier
authoring and reviewing of code by identifying places where there are
potentially risky allocations or ownership transfers for objects allocated on
the heap.&lt;/p&gt;

&lt;p&gt;While in C++ we can reduce the need for dynamic memory allocation by using plain
values, sometimes we need objects to outlive their scope. C++ code should prefer
smart pointers (most commonly &lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&lt;/code&gt;) instead of raw pointers when
dynamically allocating objects. This provides a consistent story around
allocation and ownership transfer, and leaves a clearer visual signal where
there’s code that needs closer inspection for ownership issues. The side effect
of matching how allocation works in the outside world post-C++14 and being
exception safe is just icing.&lt;/p&gt;

&lt;p&gt;Two key tools for this are &lt;code class=&quot;highlighter-rouge&quot;&gt;absl::make_unique()&lt;/code&gt; (a C++11 implementation of
C++14’s &lt;code class=&quot;highlighter-rouge&quot;&gt;std::make_unique()&lt;/code&gt;, for leak-free dynamic allocation) and
&lt;code class=&quot;highlighter-rouge&quot;&gt;absl::WrapUnique()&lt;/code&gt; (for wrapping owned raw pointers into the corresponding
&lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&lt;/code&gt; types). They can be found in
&lt;a href=&quot;https://github.com/abseil/abseil-cpp/blob/master/absl/memory/memory.h&quot;&gt;absl/memory/memory.h&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;why-avoid-new&quot;&gt;Why Avoid &lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;?&lt;/h2&gt;

&lt;p&gt;Why should code prefer smart pointers and these allocation functions over raw
pointers and &lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;When possible, ownership is best expressed in the type system. This allows
reviewers to verify correctness (absence of leaks and of double-deletes)
almost entirely by local inspection. (In code that is exceptionally
performance sensitive, this may be excused: while cheap, passing
&lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&lt;/code&gt; across function boundaries by value has non-zero overhead
because of ABI constraints. That’s rarely important enough to justify
avoiding it.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Somewhat like the reasoning for preferring &lt;code class=&quot;highlighter-rouge&quot;&gt;push_back()&lt;/code&gt; over
&lt;code class=&quot;highlighter-rouge&quot;&gt;emplace_back()&lt;/code&gt; (&lt;a href=&quot;/tips/112&quot;&gt;TotW 112&lt;/a&gt;), &lt;code class=&quot;highlighter-rouge&quot;&gt;absl::make_unique()&lt;/code&gt; directly
expresses the intent and can only do one thing (do the allocation with a
public constructor, returning a &lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&lt;/code&gt; of the specified
type). There’s no type conversion or hidden behavior. &lt;code class=&quot;highlighter-rouge&quot;&gt;absl::make_unique()&lt;/code&gt;
does what it says on the tin.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The same could be achieved with &lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&amp;lt;T&amp;gt; my_t(new T(args));&lt;/code&gt; but
that is redundant (repeating the type name &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;) and for some people there’s
value in minimizing calls to &lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;. More on this in #5.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If all allocations are handled via &lt;code class=&quot;highlighter-rouge&quot;&gt;absl::make_unique()&lt;/code&gt; or factory calls,
that leaves &lt;code class=&quot;highlighter-rouge&quot;&gt;absl::WrapUnique()&lt;/code&gt; for the implementation of those factory
calls, for code interacting with legacy methods that don’t rely on
&lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&lt;/code&gt; for ownership transfer, and for rare cases that need to
dynamically allocate with aggregate initialization (&lt;code class=&quot;highlighter-rouge&quot;&gt;absl::WrapUnique(new
MyStruct{3.141, &quot;pi&quot;})&lt;/code&gt;). In code review it’s easy to spot the
&lt;code class=&quot;highlighter-rouge&quot;&gt;absl::WrapUnique&lt;/code&gt; calls and evaluate “does that expression look like an
ownership transfer?” Usually it’s obvious (for example, it’s some factory
function). When it’s not obvious, we need to check the function to be sure
that it’s actually a raw-pointer ownership transfer.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If we instead rely mostly on the constructors of &lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&lt;/code&gt;, we see
calls like: \
&lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&amp;lt;T&amp;gt; foo(Blah());&lt;/code&gt; \
&lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&amp;lt;T&amp;gt; bar(new T());&lt;/code&gt; \
It takes only a moment’s inspection to see that the latter is safe (no leak,
no double-delete). The former? It depends: if &lt;code class=&quot;highlighter-rouge&quot;&gt;Blah()&lt;/code&gt; is returning a
&lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&lt;/code&gt;, it’s fine, though in that case it would be more obviously
safe if written as \
&lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&amp;lt;T&amp;gt; foo = Blah();&lt;/code&gt; \
If &lt;code class=&quot;highlighter-rouge&quot;&gt;Blah()&lt;/code&gt; is returning an ownership-transferred raw pointer, that’s also
fine. If &lt;code class=&quot;highlighter-rouge&quot;&gt;Blah()&lt;/code&gt; is returning just some random pointer (no transfer), then
there’s a problem. Reliance on &lt;code class=&quot;highlighter-rouge&quot;&gt;absl::make_unique()&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;absl::WrapUnique()&lt;/code&gt;
(avoiding the constructors) provides an additional visual clue for the
places where we have to worry (calls to &lt;code class=&quot;highlighter-rouge&quot;&gt;absl::WrapUnique()&lt;/code&gt;, and only those).&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;how-should-we-choose-which-to-use&quot;&gt;How Should We Choose Which to Use?&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;By default, use &lt;code class=&quot;highlighter-rouge&quot;&gt;absl::make_unique()&lt;/code&gt; (or &lt;code class=&quot;highlighter-rouge&quot;&gt;std::make_shared()&lt;/code&gt; for the rare
cases where shared ownership is appropriate) for dynamic allocation. For
example, instead of: &lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&amp;lt;T&amp;gt; bar(new T());&lt;/code&gt; write &lt;code class=&quot;highlighter-rouge&quot;&gt;auto bar
= absl::make_unique&amp;lt;T&amp;gt;();&lt;/code&gt; and instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;bar.reset(new T());&lt;/code&gt; write
&lt;code class=&quot;highlighter-rouge&quot;&gt;bar = absl::make_unique&amp;lt;T&amp;gt;();&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In a factory function that uses a non-public constructor, return a
&lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt; and use &lt;code class=&quot;highlighter-rouge&quot;&gt;absl::WrapUnique(new T(...))&lt;/code&gt; in the
implementation.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When dynamically allocating an object that requires brace initialization
(typically a struct, an array, or a container), use &lt;code class=&quot;highlighter-rouge&quot;&gt;absl::WrapUnique(new
T{...})&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When calling a legacy API that accepts ownership via a &lt;code class=&quot;highlighter-rouge&quot;&gt;T*&lt;/code&gt;, either allocate
the object in advance with &lt;code class=&quot;highlighter-rouge&quot;&gt;absl::make_unique&lt;/code&gt; and call &lt;code class=&quot;highlighter-rouge&quot;&gt;ptr.release()&lt;/code&gt; in
the call, or use &lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt; directly in the function argument.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When calling a legacy API that returns ownership via a &lt;code class=&quot;highlighter-rouge&quot;&gt;T*&lt;/code&gt;, immediately
construct a smart pointer with &lt;code class=&quot;highlighter-rouge&quot;&gt;WrapUnique&lt;/code&gt; (unless you’re immediately
passing the pointer to another legacy API that accepts ownership via a
&lt;code class=&quot;highlighter-rouge&quot;&gt;T*&lt;/code&gt;).&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;Prefer &lt;code class=&quot;highlighter-rouge&quot;&gt;absl::make_unique()&lt;/code&gt; over &lt;code class=&quot;highlighter-rouge&quot;&gt;absl::WrapUnique()&lt;/code&gt;, and prefer
&lt;code class=&quot;highlighter-rouge&quot;&gt;absl::WrapUnique()&lt;/code&gt; over raw &lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;.&lt;/p&gt;
</description>
          <pubDate>2017-11-23T00:00:00-05:00</pubDate>
          <link>http://0.0.0.0:4000/tips/126</link>
          <guid isPermaLink="true">http://0.0.0.0:4000/tips/126</guid>
        </item>
      
    
      
        <item>
          <title>Tip of the Week #109: Meaningful `const` in Function Declarations</title>
          <description>&lt;p&gt;Originally posted as totw/109 on 2016-01-14&lt;/p&gt;

&lt;p&gt;By Greg Miller &lt;a href=&quot;mailto:jgm@google.com&quot;&gt;(jgm@google.com)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This document will explain when &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt; is meaningful in function declarations,
and when it is meaningless and best omitted. But first, let us briefly explain
what is meant by the terms &lt;em&gt;declaration&lt;/em&gt; and &lt;em&gt;definition&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Consider the following code:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;                     &lt;span class=&quot;c1&quot;&gt;// 1: declaration of F(int)
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;               &lt;span class=&quot;c1&quot;&gt;// 2: re-declaration of F(int)
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// 3: definition of F(int)
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 4: error: re-definition of F(int)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The first two lines are function &lt;em&gt;declarations&lt;/em&gt;. A function &lt;em&gt;declaration&lt;/em&gt; tells
the compiler the function’s signature and return type. In the above example, the
function’s signature is &lt;code class=&quot;highlighter-rouge&quot;&gt;F(int)&lt;/code&gt;. The constness of the function’s parameter type
is ignored, so both declarations are equivalent (See &lt;a href=&quot;http://eel.is/c++draft/over.load&quot;&gt;“Overloadable
declarations”&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;Lines 3 and 4 from the above code are both function &lt;em&gt;definitions&lt;/em&gt;. A function
&lt;em&gt;definition&lt;/em&gt; is also a declaration, but a definition also contains the
function’s body. Therefore, line 3 is a definition for a function with the
signature &lt;code class=&quot;highlighter-rouge&quot;&gt;F(int)&lt;/code&gt;. Similarly, line 4 is also a definition for the same
function, &lt;code class=&quot;highlighter-rouge&quot;&gt;F(int)&lt;/code&gt;, which will result in an error at link time. Multiple
declarations are allowed, but only a single definition is permitted.&lt;/p&gt;

&lt;p&gt;Even though the definitions on lines 3 and 4 &lt;em&gt;declare&lt;/em&gt; and &lt;em&gt;define&lt;/em&gt; the same
function, there is a difference within their function bodies due to the way they
are declared. From the definition on line 3, the type of the function-parameter
variable within the function will be &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt; (i.e., non-const). On the other hand,
the definition on line 4 will produce a function-parameter variable within the
function whose type is &lt;code class=&quot;highlighter-rouge&quot;&gt;const int&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;meaningful-const-in-function-declarations&quot;&gt;Meaningful &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt; in Function Declarations&lt;/h2&gt;

&lt;p&gt;Not all &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt; qualifications in function declarations are ignored. To quote
from “Overloadable declarations” ([over.load]) in the C++ standard (emphasis
added):&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt; type-specifiers &lt;strong&gt;buried within a parameter type specification&lt;/strong&gt; are
significant and can be used to distinguish overloaded function declarations&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The following are examples where &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt; is significant and not ignored:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;                  &lt;span class=&quot;c1&quot;&gt;// 1
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;                  &lt;span class=&quot;c1&quot;&gt;// 2
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unique_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 3
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;                        &lt;span class=&quot;c1&quot;&gt;// 4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In the above examples, the &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; parameter itself is never declared &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;. Each
of the above functions accepts a parameter named &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; of a different type, thus
forming a valid overload set. Line 1 declares a function that accepts a “pointer
to an &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt; that is &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;”. Line 2 declares a function that accepts a
“reference to an &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt; that is &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;”. And line 3 declares a function that
accepts a “unique_ptr to an &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt; that is &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;”. All of these uses of &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;
are important and not ignored because they are part of the parameter type
specification and are not top-level &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt; qualifications that affect the
parameter &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; itself.&lt;/p&gt;

&lt;p&gt;Line 4 is interesting because it does not include the &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt; keyword at all,
and may at first appear to be equivalent to the declaration on line 1 given the
reasons cited at the beginning of this document. The reason that this is not
true and that line 4 is a valid and distinct declaration is that only top-level,
or outermost, &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt; qualifications of the parameter type specification are
ignored.&lt;/p&gt;

&lt;p&gt;To complete this example, let us look at a few more examples where a &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt; is
meaningless and ignored.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;// 1: declares F(int)
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;         &lt;span class=&quot;c1&quot;&gt;// 2: declares F(int*)
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// 3: declares F(const int*)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;rules-of-thumb&quot;&gt;Rules of Thumb&lt;/h2&gt;

&lt;p&gt;Though few of us will ever truly master all the delightful obscurities of C++,
it is important that we do our best to understand the rules of the game. This
will help us write code that is understood by other C++ programmers who are
following the same rules and playing the same game. For this reason, it is
important that we understand when &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt; qualification is meaningful in a
function declaration and when it is ignored.&lt;/p&gt;

&lt;p&gt;Although there is no official guidance from the &lt;a href=&quot;http://google.github.io/styleguide/cppguide.html&quot;&gt;Google C++ style guide&lt;/a&gt;, and there is no single
generally accepted opinion, the following is one reasonable set of guidelines:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Never use top-level &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt; on function parameters in &lt;em&gt;declarations&lt;/em&gt; that
are not definitions (and be careful not to copy/paste a meaningless
&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;). It is meaningless and ignored by the compiler, it is visual noise,
and it could mislead readers.&lt;/li&gt;
  &lt;li&gt;Do use top-level &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt; on function parameters in &lt;em&gt;definitions&lt;/em&gt; at your (or
your team’s) discretion. You might follow the same rationale as you would
for when to declare a function-local variable &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
</description>
          <pubDate>2017-11-23T00:00:00-05:00</pubDate>
          <link>http://0.0.0.0:4000/tips/109</link>
          <guid isPermaLink="true">http://0.0.0.0:4000/tips/109</guid>
        </item>
      
    
      
        <item>
          <title>Tip of the Week #99: Nonmember Interface Etiquette</title>
          <description>&lt;p&gt;Originally posted as totw/99 on 2015-06-24&lt;/p&gt;

&lt;p&gt;Revised 2017-10-10&lt;/p&gt;

&lt;p&gt;The interface of a C++ class is not constrained to its members or to its
definition. When evaluating an API, we must consider definitions beyond the
class body that can be as much a part of its interface as its public members.&lt;/p&gt;

&lt;p&gt;These external interface points include template specializations like hashers or
traits, nonmember operator overloads (e.g. logging, relationals), and other
canonical nonmember functions designed for use with argument-dependent lookup
(ADL), most notably &lt;code class=&quot;highlighter-rouge&quot;&gt;swap()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A few of these are illustrated below for some sample class &lt;code class=&quot;highlighter-rouge&quot;&gt;space::Key&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;space&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Key&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// standard streaming
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ostream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ostream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// gTest printing
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PrintTo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ostream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// new-style flag extension:
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ParseFlag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UnparseFlag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// namespace space
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;HASH_NAMESPACE_BEGIN&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;space&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;space&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;HASH_NAMESPACE_END&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;There are some important risks associated with making such extensions
incorrectly, so this article will try to present some guidance.&lt;/p&gt;

&lt;h2 id=&quot;the-proper-namespace&quot;&gt;The Proper Namespace&lt;/h2&gt;

&lt;p&gt;Interface points that are functions are usually designed to be found by
argument-dependent lookup (ADL, see &lt;a href=&quot;/tips/49&quot;&gt;TotW 49&lt;/a&gt;). Operators and some
operator-like functions (notably &lt;code class=&quot;highlighter-rouge&quot;&gt;swap()&lt;/code&gt;) are designed to be found by ADL. This
protocol only works reliably when the function is defined in a namespace
associated with the type being customized. The associated namespaces include
those of its base classes and class template parameters. A common mistake is to
place these functions in the global namespace. To illustrate the problem,
consider the following code in which &lt;code class=&quot;highlighter-rouge&quot;&gt;good(x)&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;bad(x)&lt;/code&gt; functions are called
with identical syntax:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;library&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Letter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;good&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Letter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// namespace library
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// bad is improperly placed in global namespace
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;library&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Letter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;client&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;good&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;library&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Letter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;good&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// ok: 'library::good' is found by ADL.
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;bad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// oops: '::bad' is hidden by 'client::bad'.
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// namespace client
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Note the difference between &lt;code class=&quot;highlighter-rouge&quot;&gt;library::good()&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;::bad()&lt;/code&gt;. The &lt;code class=&quot;highlighter-rouge&quot;&gt;test()&lt;/code&gt;
function is relying on the absence of any function called &lt;code class=&quot;highlighter-rouge&quot;&gt;bad()&lt;/code&gt; in namespaces
enclosing the call site. The appearance of &lt;code class=&quot;highlighter-rouge&quot;&gt;client::bad()&lt;/code&gt; hides &lt;code class=&quot;highlighter-rouge&quot;&gt;::bad()&lt;/code&gt; from
the &lt;code class=&quot;highlighter-rouge&quot;&gt;test&lt;/code&gt; caller.  Meanwhile, the &lt;code class=&quot;highlighter-rouge&quot;&gt;good()&lt;/code&gt; function is found regardless of what
else exists in the &lt;code class=&quot;highlighter-rouge&quot;&gt;test()&lt;/code&gt; function’s enclosing scope. The C++ name lookup
sequence will only yield a global if a name search from closer lexical scopes to
the call site fails to find any names.&lt;/p&gt;

&lt;p&gt;This is all very subtle, which is the point, really. It’s all much simpler if we
&lt;em&gt;default to defining functions alongside the data on which they operate&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;a-quick-note-on-in-class-friend-definitions&quot;&gt;A Quick Note on In-Class Friend Definitions&lt;/h2&gt;

&lt;p&gt;There’s a way to add non-member functions to a class from within the class
definition. Friend functions can be defined directly inside a class.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;library&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Key&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;explicit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;friend&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;friend&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;friend&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

 &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// namespace library
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;These friend functions have a special property of ONLY being visible through
ADL. They’re a little strange in that they are defined in the enclosing
namespace, but don’t appear in name lookup there. These in-class &lt;code class=&quot;highlighter-rouge&quot;&gt;friend&lt;/code&gt;
definitions must have inlined bodies for this stealth property to kick in. See
&lt;a href=&quot;http://stackoverflow.com/questions/381164/friend-and-inline-method-whats-the-point&quot;&gt;“Friend
Definitions”&lt;/a&gt;
for more detail.&lt;/p&gt;

&lt;p&gt;Such functions will not hide global functions from fragile call sites in their
namespace or appear in diagnostic messages for unrelated calls to functions of
the same name. They get out of the way, essentially. They’re also very
convenient to define, easy to discover, and they have access to class internals.
Probably the biggest drawback is that they will not be found in cases where the
enclosing class is implicitly convertible from an argument type.&lt;/p&gt;

&lt;p&gt;Note that access (i.e. &lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;protected&lt;/code&gt;) has no effect on
friend functions, but it might be polite to place these in the public section
anyway, just so they’ll be more visible during perusal of the public API points.&lt;/p&gt;

&lt;h2 id=&quot;the-proper-source-location&quot;&gt;The Proper Source Location&lt;/h2&gt;

&lt;p&gt;To avoid violations of the one-definition rule (ODR), any customizations on a
type’s interface should appear where they can’t accidentally be defined multiple
times. This usually means they should be packaged with the type in the same
header. It’s not appropriate to add this sort of nonmember customization in a
&lt;code class=&quot;highlighter-rouge&quot;&gt;*_test.cc&lt;/code&gt; file, or in a “utilities” header off to the side where it can be
overlooked. Force the compiler to see the customization and you will be more
likely to catch violations.&lt;/p&gt;

&lt;p&gt;A function overload (including operator overloads) intended as a nonmember
extension should be declared in a header that defines one of its arguments.&lt;/p&gt;

&lt;p&gt;The same goes for template specializations. Template specializations can be
packaged with the primary template definition, or packaged with the type on
which it’s being specialized. For partial specializations or with multiple
parameters it’s a judgment call. It’s usually pretty clear in practice which
site is better. The important thing is that the specialization should not be
hidden in client code: it should be as visible as the template and the
user-defined types involved.&lt;/p&gt;

&lt;h2 id=&quot;when-to-customize&quot;&gt;When to Customize&lt;/h2&gt;

&lt;p&gt;Don’t customize the behavior of a class in a test. This is dangerous and
unfortunately very common. Test source files are not immune to these dangers and
should follow the same rules as production code. We find a lot of inappropriate
operators in &lt;code class=&quot;highlighter-rouge&quot;&gt;*_test.cc&lt;/code&gt; files that are written with the intent to “get
&lt;code class=&quot;highlighter-rouge&quot;&gt;EXPECT_EQ&lt;/code&gt; to compile” or some other pragmatic concern. Unfortunately they are
still ODR risks (if not violations) and can make library maintenance
difficult. These rogue definitions might even stand in the way of library
maintenance as adding these operators upstream would break the very tests that
needed them and defined their own. For testing there are alternatives available
with a little more effort.&lt;/p&gt;

&lt;p&gt;Note that ADL works from the original declaration point for a type. Typedefs,
type aliases, alias templates, and using declarations do not create types and
have no impact on ADL. This can make it a little tricky to locate the proper
placement for customizations, but this cannot be helped, so just do it.&lt;/p&gt;

&lt;p&gt;Don’t augment the interface to types generated by protobufs. This is another
common pitfall. You may own the &lt;code class=&quot;highlighter-rouge&quot;&gt;.proto&lt;/code&gt; file, but that doesn’t mean you own the
C++ API it generates, and your augmentations could block improvements to the
generated C++ API. This is an ODR risk because you can’t ensure that your
augmentations are seen whenever the generated header is included.&lt;/p&gt;

&lt;p&gt;When defining &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;, it may be tempting to define behavior for templates like
&lt;code class=&quot;highlighter-rouge&quot;&gt;std::vector&amp;lt;T&amp;gt;&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;std::pair&amp;lt;T,T&amp;gt;&lt;/code&gt;. Though your customizations may take
precedence and may do what you expect, you may be conflicting with other
expected customizations defined on the broader class template.&lt;/p&gt;

&lt;p&gt;It’s possible to define some customizations for raw pointers. It may be tempting
in some cases to supply these customizations for &lt;code class=&quot;highlighter-rouge&quot;&gt;T*&lt;/code&gt; along with &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;. This is
not advised. It’s dangerous because the customization may conflict with the
expected ordinary behavior of pointers (e.g. the way they’re logged, swapped, or
compared). It’s best to leave pointers alone.&lt;/p&gt;

&lt;h2 id=&quot;what-to-do-when-youre-stuck&quot;&gt;What to Do When You’re Stuck&lt;/h2&gt;

&lt;p&gt;Following these guidelines can be challenging. Much of the inappropriate
overloading and specialization seen in C++ code is motivated by a small set of
root causes. Below is a partial listing with successful workarounds. If you
run into a library API that can’t be worked with, please send a note to the
owners to see about adding the appropriate customization hooks. Common APIs should
be usable without breaking these interface packaging guidelines.&lt;/p&gt;

&lt;h3 id=&quot;testing-a-type-with-expect_eq-etc&quot;&gt;Testing a Type with &lt;code class=&quot;highlighter-rouge&quot;&gt;EXPECT_EQ&lt;/code&gt;, etc.&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;temptation:&lt;/em&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;EXPECT_EQ&lt;/code&gt; requires &lt;code class=&quot;highlighter-rouge&quot;&gt;operator==&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; or
GoogleTest’s &lt;code class=&quot;highlighter-rouge&quot;&gt;PrintTo&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;workaround:&lt;/em&gt; Write lightweight gmock matchers with
&lt;a href=&quot;https://github.com/google/googletest/blob/master/googlemock/docs/CookBook.md#writing-new-parameterized-matchers-quickly&quot;&gt;MATCHER_P&lt;/a&gt;
instead of relying exclusively on &lt;code class=&quot;highlighter-rouge&quot;&gt;EXPECT_EQ&lt;/code&gt; etc.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;workaround:&lt;/em&gt; Create &lt;em&gt;local&lt;/em&gt; (this is essential) wrapper types you DO truly own
and provide customizations on those, possibly using trivial inheritance as a
shortcut.&lt;/p&gt;

&lt;h3 id=&quot;using-t-as-a-container-key&quot;&gt;Using &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; as a Container Key&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;temptation:&lt;/em&gt; Container default functor types may rely on &lt;code class=&quot;highlighter-rouge&quot;&gt;operator&amp;lt;&lt;/code&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;operator==&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;hash&amp;lt;T&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;workaround:&lt;/em&gt; Use more custom comparators or custom hashers. Use more typedefs
for your associative container types to hide these details from client code.&lt;/p&gt;

&lt;h3 id=&quot;logging-containers-of-t&quot;&gt;Logging Containers of &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;temptation:&lt;/em&gt; Defining &lt;code class=&quot;highlighter-rouge&quot;&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; overloads for standard containers.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;workaround:&lt;/em&gt; Don’t try to log the container directly.&lt;/p&gt;

&lt;h2 id=&quot;take-aways&quot;&gt;Take-Aways&lt;/h2&gt;

&lt;p&gt;A type’s behavior is not completely defined by its class definition. Non-member
definitions and specializations also contribute. You may need to keep reading
past that closing brace to really understand how a class works.&lt;/p&gt;

&lt;p&gt;Be aware of when and where it’s safe to add these customizations. Adding
inappropriate definitions may get your code to work for now, but you could be
adding fragility and maintenance blockers for other engineers down the line to
deal with.&lt;/p&gt;

</description>
          <pubDate>2017-11-16T00:00:00-05:00</pubDate>
          <link>http://0.0.0.0:4000/tips/99</link>
          <guid isPermaLink="true">http://0.0.0.0:4000/tips/99</guid>
        </item>
      
    
      
        <item>
          <title>Tip of the Week #65: Putting Things in their Place</title>
          <description>&lt;p&gt;Originally posted as totw/65 on 2013-12-12&lt;/p&gt;

&lt;p&gt;By Hyrum Wright &lt;a href=&quot;mailto:hyrum@hyrumwright.org&quot;&gt;(hyrum@hyrumwright.org)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“Let me ’splain. No, there is too much. Let me sum up.” –Inigo Montoya&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;C++11 added a new way to insert elements into standard containers: the
&lt;code class=&quot;highlighter-rouge&quot;&gt;emplace()&lt;/code&gt; family of methods. These methods create an object directly within a
container, instead of creating a temporary object and then copying or moving
that object into the container. Avoiding these copies is more efficient for
almost all objects, and makes it easier to store move-only objects (such as
&lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&lt;/code&gt;) in standard containers.&lt;/p&gt;

&lt;h2 id=&quot;the-old-way-and-the-new-way&quot;&gt;The Old Way and the New Way&lt;/h2&gt;

&lt;p&gt;Let’s look at a simple example using vectors to contrast the two styles. The
first example uses pre-C++11 code:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;…&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addFoo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Using the older &lt;code class=&quot;highlighter-rouge&quot;&gt;push_back()&lt;/code&gt; method, two &lt;code class=&quot;highlighter-rouge&quot;&gt;Foo&lt;/code&gt; objects are constructed: the
temporary argument and the object in the vector that is move-constructed from
the temporary.&lt;/p&gt;

&lt;p&gt;We can instead use C++11’s &lt;code class=&quot;highlighter-rouge&quot;&gt;emplace_back()&lt;/code&gt; and only one object will be
constructed directly within the memory of the vector. Since the “emplace” family
of functions forward their arguments to the underlying object’s constructor, we
can provide the constructor arguments directly, obviating the need to create a
temporary &lt;code class=&quot;highlighter-rouge&quot;&gt;Foo&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addBetterFoo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emplace_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;using-emplace-methods-for-move-only-operations&quot;&gt;Using Emplace Methods for Move-Only Operations&lt;/h2&gt;

&lt;p&gt;So far, we’ve looked at cases where emplace methods improve performance, but
they also make previously impossible code feasible, such as storing move-only
types like &lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&lt;/code&gt; within containers. Consider this snippet:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unique_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;How would you insert values into this vector? One way would be to use
&lt;code class=&quot;highlighter-rouge&quot;&gt;push_back()&lt;/code&gt; and construct the value directly within its argument:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unique_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This syntax works, but can be a bit unwieldy. Unfortunately, the traditional way
of getting around this confusion is fraught with complexity:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unique_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This code compiles, but it leaves ownership of the raw pointer unclear until the
insertion. What’s worse, the vector now owns the object, but &lt;code class=&quot;highlighter-rouge&quot;&gt;f2&lt;/code&gt; still remains
valid, and could accidentally be deleted later on. To an uninformed reader, this
ownership pattern can be confusing, particularly if construction and insertion
are not sequential events as above.&lt;/p&gt;

&lt;p&gt;Other solutions won’t even compile, because &lt;code class=&quot;highlighter-rouge&quot;&gt;unique_ptr&lt;/code&gt; isn’t copyable:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unique_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;             &lt;span class=&quot;c1&quot;&gt;// Does not compile!
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Does not compile!
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Using emplace methods can make it more intuitive to insert the object while it’s
being created. In other cases, if you need to move the &lt;code class=&quot;highlighter-rouge&quot;&gt;unique_ptr&lt;/code&gt; into the
vector, you can:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unique_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emplace_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;By combining emplace with a standard iterator, you can also insert the object at
an arbitrary location in the vector:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emplace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;That said, in practical terms we wouldn’t want to see these ways to construct a
&lt;code class=&quot;highlighter-rouge&quot;&gt;unique_ptr&lt;/code&gt; - Use &lt;code class=&quot;highlighter-rouge&quot;&gt;std::make_unique&lt;/code&gt; (from C++14) or &lt;code class=&quot;highlighter-rouge&quot;&gt;absl::make_unique&lt;/code&gt; (if
you’re still on C++11).&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;We’ve used vector as an example in this Tip, but emplace methods are also
available for maps, lists and other STL containers. When combined with
&lt;code class=&quot;highlighter-rouge&quot;&gt;unique_ptr&lt;/code&gt;, emplace allows for good encapsulation and makes the ownership
semantics of heap-allocated objects clear in ways that weren’t possible before.
Hopefully this has given you a feel for the power of the new emplace family of
container methods, and a desire to use them where appropriate in your own code.&lt;/p&gt;

</description>
          <pubDate>2017-11-16T00:00:00-05:00</pubDate>
          <link>http://0.0.0.0:4000/tips/65</link>
          <guid isPermaLink="true">http://0.0.0.0:4000/tips/65</guid>
        </item>
      
    
      
        <item>
          <title>Tip of the Week #112: emplace vs. push_back</title>
          <description>&lt;p&gt;Originally posted as totw/112 on 2016-02-25&lt;/p&gt;

&lt;p&gt;By Geoff Romer &lt;a href=&quot;mailto:gromer@google.com&quot;&gt;(gromer@google.com)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Revised 2017-08-30&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“The less we use our power, the greater it will be.” — Thomas Jefferson&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;As you may already know (and if not, &lt;a href=&quot;/tips/65&quot;&gt;TotW 65&lt;/a&gt;), C++11 introduced a
powerful new way to insert items into containers: &lt;code class=&quot;highlighter-rouge&quot;&gt;emplace&lt;/code&gt; methods. These let
you construct an object in-place inside the container, using any of the object’s
constructors. That includes the move and copy constructors, so it turns out any
time you could use a &lt;code class=&quot;highlighter-rouge&quot;&gt;push&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;insert&lt;/code&gt; method, you can use an &lt;code class=&quot;highlighter-rouge&quot;&gt;emplace&lt;/code&gt; method
instead, with no other changes:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;my_vec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;my_vec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;foo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// This is OK, so...
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;my_vec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emplace_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;foo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// This is also OK, and has the same result
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;my_set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;my_set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;foo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// Same here: any insert call can be
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;my_set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emplace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;foo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;// rewritten as an emplace call.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This raises an obvious question: which one should you use? Should we perhaps
just discard &lt;code class=&quot;highlighter-rouge&quot;&gt;push_back()&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;insert()&lt;/code&gt;, and use &lt;code class=&quot;highlighter-rouge&quot;&gt;emplace&lt;/code&gt; methods all the
time?&lt;/p&gt;

&lt;p&gt;Let me answer that question by asking another: what do these two lines of code
do?&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;vec1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;vec2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emplace_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The first line is quite straightforward: it adds the number 1048576 to the end
of the vector. The second, however, is not so clear. Without knowing the type of
the vector, we don’t know what constructor it’s invoking, so we can’t really say
what that line is doing. For example, if &lt;code class=&quot;highlighter-rouge&quot;&gt;vec2&lt;/code&gt; is a &lt;code class=&quot;highlighter-rouge&quot;&gt;std::vector&amp;lt;int&amp;gt;&lt;/code&gt;, that
line merely adds 1048576 to the end, as with the first line, but if &lt;code class=&quot;highlighter-rouge&quot;&gt;vec2&lt;/code&gt; is a
&lt;code class=&quot;highlighter-rouge&quot;&gt;std::vector&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt;&lt;/code&gt;, that second line constructs a &lt;code class=&quot;highlighter-rouge&quot;&gt;vector&lt;/code&gt; of over
a million elements, allocating several megabytes of memory in the process.&lt;/p&gt;

&lt;p&gt;Consequently, if you have a choice between &lt;code class=&quot;highlighter-rouge&quot;&gt;push_back()&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;emplace_back()&lt;/code&gt;
with the same arguments, your code will tend to be more readable if you choose
&lt;code class=&quot;highlighter-rouge&quot;&gt;push_back()&lt;/code&gt;, because &lt;code class=&quot;highlighter-rouge&quot;&gt;push_back()&lt;/code&gt; expresses your intent more specifically.
Choosing &lt;code class=&quot;highlighter-rouge&quot;&gt;push_back()&lt;/code&gt; is also safer: suppose you have a
&lt;code class=&quot;highlighter-rouge&quot;&gt;std::vector&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt;&lt;/code&gt; and you want to append a number to the end of
the first &lt;code class=&quot;highlighter-rouge&quot;&gt;vector&lt;/code&gt;, but you accidentally forget the subscript. If you write
&lt;code class=&quot;highlighter-rouge&quot;&gt;my_vec.push_back(2&amp;lt;&amp;lt;20)&lt;/code&gt;, you’ll get a compile error and you’ll quickly spot
the problem. On the other hand, if you write &lt;code class=&quot;highlighter-rouge&quot;&gt;my_vec.emplace_back(2&amp;lt;&amp;lt;20)&lt;/code&gt;, the
code will compile, and you won’t notice any problems until run-time.&lt;/p&gt;

&lt;p&gt;Now, it’s true that when implicit conversions are involved, &lt;code class=&quot;highlighter-rouge&quot;&gt;emplace_back()&lt;/code&gt; can
be somewhat faster than &lt;code class=&quot;highlighter-rouge&quot;&gt;push_back()&lt;/code&gt;. For example, in the code that we began
with, &lt;code class=&quot;highlighter-rouge&quot;&gt;my_vec.push_back(&quot;foo&quot;)&lt;/code&gt; constructs a temporary &lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt; from the string
literal, and then moves that string into the container, whereas
&lt;code class=&quot;highlighter-rouge&quot;&gt;my_vec.emplace_back(&quot;foo&quot;)&lt;/code&gt; just constructs the &lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt; directly in the
container, avoiding the extra move. For more expensive types, this may be a
reason to use &lt;code class=&quot;highlighter-rouge&quot;&gt;emplace_back()&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;push_back()&lt;/code&gt;, despite the readability and
safety costs, but then again it may not. Very often the performance difference
just won’t matter. As always, the rule of thumb is that you should avoid
“optimizations” that make the code less safe or less clear, unless the
performance benefit is big enough to show up in your application benchmarks.&lt;/p&gt;

&lt;p&gt;So in general, if both &lt;code class=&quot;highlighter-rouge&quot;&gt;push_back()&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;emplace_back()&lt;/code&gt; would work with the same
arguments, you should prefer &lt;code class=&quot;highlighter-rouge&quot;&gt;push_back()&lt;/code&gt;, and likewise for &lt;code class=&quot;highlighter-rouge&quot;&gt;insert()&lt;/code&gt; vs.
&lt;code class=&quot;highlighter-rouge&quot;&gt;emplace()&lt;/code&gt;.&lt;/p&gt;

</description>
          <pubDate>2017-11-16T00:00:00-05:00</pubDate>
          <link>http://0.0.0.0:4000/tips/112</link>
          <guid isPermaLink="true">http://0.0.0.0:4000/tips/112</guid>
        </item>
      
    
      
        <item>
          <title>Tip of the Week #49: Argument-Dependent Lookup</title>
          <description>&lt;p&gt;Originally posted as totw/49 on 2013-07-14&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“…whatever disappearing trail of its legalistic argle-bargle one chooses to
follow…” –Antonin Scalia, &lt;a href=&quot;http://www.supremecourt.gov/opinions/12pdf/12-307_6j37.pdf&quot;&gt;U.S. v Windsor dissenting opinion&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;p&gt;A function call expression such as &lt;code class=&quot;highlighter-rouge&quot;&gt;func(a,b,c)&lt;/code&gt;, in which the function is named
without the &lt;code class=&quot;highlighter-rouge&quot;&gt;::&lt;/code&gt; scope operator, is called unqualified. When C++ code refers to
a function by an unqualified name, the compiler performs a search for a matching
function declaration. What is surprising to some people (and different from
other languages) is that in addition to the caller’s lexical scope, the set of
search scopes is augmented by namespaces associated with the function argument
types. This additional lookup is called &lt;em&gt;Argument-Dependent Lookup&lt;/em&gt; (ADL). It’s
definitely happening in your code, so you’ll be much better off with a basic
understanding of how it works.&lt;/p&gt;

&lt;h2 id=&quot;name-lookup-basics&quot;&gt;Name Lookup Basics&lt;/h2&gt;

&lt;p&gt;A function call must be mapped to a single function definition by the compiler.
This matching is done in two independent serial processing stages. First, &lt;em&gt;name
lookup&lt;/em&gt; applies some scope searching rules to produce a set of overloads
matching the name of the function. Then &lt;em&gt;overload resolution&lt;/em&gt; takes those
overloads produced by that name lookup and tries to choose a best match for the
arguments given at the call site. Keep this distinction in mind. Name lookup
comes first, and it doesn’t try to make any determination as to whether a
function is a good match or not. It doesn’t even consider the argument count. It
just searches scopes for a function name. Overload resolution is a complex topic
in its own right, but it’s not our focus right now. Just know that it’s a
separate processing stage that gets its inputs from name lookup.&lt;/p&gt;

&lt;p&gt;When an unqualified function call is encountered, several independent search
sequences can occur for that function name, each attempting to match the name to
a set of overloads. The most obvious search is the outward search starting from
the lexical scope of the call site:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;internal&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ok: finds b::func().
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// b::internal
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// b
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This name lookup has nothing to do with ADL yet (&lt;code class=&quot;highlighter-rouge&quot;&gt;func()&lt;/code&gt; has no arguments). It
is simply a search outward from the site of the function call, proceeding
outward from local function scope (if applicable), to class scope, enclosing
class scope, and base classes (if applicable), then to namespace scope, and out
into enclosing namespaces, and finally the global &lt;code class=&quot;highlighter-rouge&quot;&gt;::&lt;/code&gt; namespace.&lt;/p&gt;

&lt;p&gt;As name lookup progresses through a sequence of increasingly widening scopes,
the process stops as soon as any function with the target name is found, whether
or not that function’s arguments are compatible with the arguments supplied by
the call site. When a scope is encountered containing at least one function
declaration with the target name, the overloads in that scope become the result
of that name lookup.&lt;/p&gt;

&lt;p&gt;This is illustrated in the example below:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// b::func
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;internal&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// b::internal::func
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deep&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// error: finds only b::internal::func(int).
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// b::internal::deep
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// b::internal
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// b
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;It’s tempting but incorrect to think a &lt;code class=&quot;highlighter-rouge&quot;&gt;func(s)&lt;/code&gt; expression will overlook the
obviously bad match of &lt;code class=&quot;highlighter-rouge&quot;&gt;b::internal::func(int)&lt;/code&gt;, and continue looking to the
next outward enclosing scope to find &lt;code class=&quot;highlighter-rouge&quot;&gt;b::func(const string&amp;amp;)&lt;/code&gt;. However, name
lookup doesn’t consider argument types. It finds something called &lt;code class=&quot;highlighter-rouge&quot;&gt;func&lt;/code&gt; and
stops in &lt;code class=&quot;highlighter-rouge&quot;&gt;b::internal&lt;/code&gt;, leaving the evaluation of “obviously bad” to the
overload resolution phase. The &lt;code class=&quot;highlighter-rouge&quot;&gt;b::func(const string&amp;amp;)&lt;/code&gt; function is never even
seen by overload resolution.&lt;/p&gt;

&lt;p&gt;An important implication of the scoped search order is that overloads in a scope
appearing earlier in the search order will hide overloads from later scopes.&lt;/p&gt;

&lt;h2 id=&quot;argument-dependent-lookup&quot;&gt;Argument-Dependent Lookup&lt;/h2&gt;

&lt;p&gt;If a function call passes arguments, a few more parallel name lookups are
launched. These extra lookups begin in each associated namespace of each of the
function call’s arguments. A scope containing a name match doesn’t stop all of
the lookups, only the one that encountered the match.&lt;/p&gt;

&lt;h2 id=&quot;the-simple-case&quot;&gt;The Simple Case&lt;/h2&gt;

&lt;p&gt;Consider the following code:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;aspace&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// found by ADL name lookup on 'a'.
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// namespace aspace
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bspace&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// found by lexical scope name lookup
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;aspace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// aspace::func(const aspace::A&amp;amp;)
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// namespace bspace
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Two name lookups are launched to resolve the call to &lt;code class=&quot;highlighter-rouge&quot;&gt;func(a)&lt;/code&gt;. The lexical
scope name lookup starts in the local function scope of &lt;code class=&quot;highlighter-rouge&quot;&gt;bspace::test()&lt;/code&gt;. It
finds no &lt;code class=&quot;highlighter-rouge&quot;&gt;func&lt;/code&gt; there and proceeds to the scope of namespace &lt;code class=&quot;highlighter-rouge&quot;&gt;bspace&lt;/code&gt;, in which
it finds &lt;code class=&quot;highlighter-rouge&quot;&gt;func(int)&lt;/code&gt; and stops. The other name lookup, which is due to ADL,
starts in the namespace associated with the argument &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;. In this case, that’s
only namespace &lt;code class=&quot;highlighter-rouge&quot;&gt;aspace&lt;/code&gt;. That lookup finds &lt;code class=&quot;highlighter-rouge&quot;&gt;aspace::func(const aspace::A&amp;amp;)&lt;/code&gt; and
stops. Overload resolution therefore receives two candidates. These are
‘bspace::func(int)’ from lexical name lookup, and ‘aspace::func(const
aspace::A&amp;amp;)’ from the single ADL lookup. In overload resolution, the &lt;code class=&quot;highlighter-rouge&quot;&gt;func(a)&lt;/code&gt;
call resolves to &lt;code class=&quot;highlighter-rouge&quot;&gt;aspace::func(const aspace::A&amp;amp;)&lt;/code&gt;. The &lt;code class=&quot;highlighter-rouge&quot;&gt;bspace::func(int)&lt;/code&gt;
overload is not a good match for the argument type and so it is rejected by
overload resolution.&lt;/p&gt;

&lt;p&gt;The lexical name search and each of the additional ADL-triggered name searches
can be considered to occur in parallel, with each returning a set of candidate
function overloads. The results of all such searches are thrown in a bag and
they compete via overload resolution to determine the best match. If there’s a
tie for best match, the compiler issues an ambiguity error; “There can be only
one.” If no overload is a good match, that’s an error too. So more precisely,
“there must be exactly one”, which doesn’t sound as cool in a movie trailer.&lt;/p&gt;

&lt;h2 id=&quot;type-associated-namespaces&quot;&gt;Type-Associated Namespaces&lt;/h2&gt;

&lt;p&gt;The previous example was the simple case, but a more sophisticated type can have
many namespaces associated with it. The set of namespaces associated with a type
includes any namespace of any type that appears as a part of the argument type’s
full name, including its template parameter types. It also includes the
namespaces of direct and indirect base classes. For example, a single argument
that expands to the type &lt;code class=&quot;highlighter-rouge&quot;&gt;a::A&amp;lt;b::B, c::internal::C*&amp;gt;&lt;/code&gt; will produce searches
beginning in the &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;c::internal&lt;/code&gt; namespaces (and any other namespaces
associated with the constituent types &lt;code class=&quot;highlighter-rouge&quot;&gt;a::A&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;b::B&lt;/code&gt;, or &lt;code class=&quot;highlighter-rouge&quot;&gt;c::internal::C&lt;/code&gt;), each
looking for the called function name. The following example shows a few of these
effects:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;aspace&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AGeneric&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;find_me&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// namespace aspace
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bspace&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;aspace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AliasForA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;aspace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BGeneric&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// ok: base class namespace searched.
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// ok: template parameter namespace searched.
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;find_me&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BGeneric&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;aspace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// ok: template namespace searched.
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;find_me&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;aspace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AGeneric&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// namespace bspace
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;tips&quot;&gt;Tips&lt;/h2&gt;

&lt;p&gt;With the fundamental name lookup mechanism fresh in your mind, consider the
following tips which may help you when you are working with real C++ code.&lt;/p&gt;

&lt;h2 id=&quot;type-aliases&quot;&gt;Type Aliases&lt;/h2&gt;

&lt;p&gt;Sometimes determining the set of namespaces associated with a type will take a
bit of detective work. &lt;code class=&quot;highlighter-rouge&quot;&gt;typedef&lt;/code&gt; and using declarations can introduce aliases
for a type. In those cases the aliases are fully resolved and expanded to their
source types before the list of namespaces to search are chosen. This is one way
in which &lt;code class=&quot;highlighter-rouge&quot;&gt;typedef&lt;/code&gt; and using declarations can be a bit misleading, because they
can lead you to make incorrect predictions about which namespaces will be
searched by ADL. This is demonstrated below:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cspace&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// ok: note that this searches aspace, not bspace.
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bspace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AliasForA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// namespace cspace
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;caveat-iterator&quot;&gt;Caveat Iterator&lt;/h2&gt;

&lt;p&gt;Be careful with iterators. You don’t really know with what namespaces they are
associated, so don’t rely on ADL for resolving function calls involving
iterators. They might just be pointers to the elements, or they might be in some
namespace private to the implementation that has nothing to do with the
container’s namespace.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// maybe this compiles, maybe not!
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// namespace d
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The above code has a dependency on whether &lt;code class=&quot;highlighter-rouge&quot;&gt;std::vector&amp;lt;int&amp;gt;::iterator&lt;/code&gt; is
&lt;code class=&quot;highlighter-rouge&quot;&gt;int*&lt;/code&gt; (which is possible) or some type in a namespace that has a count overload
(like &lt;code class=&quot;highlighter-rouge&quot;&gt;std::count()&lt;/code&gt;). It’s possible that this will work on some platforms and not
others, or that it will work in debug builds with instrumented iterators, but
not in optimized builds. It’s better to just qualify the function name. If you
want to call &lt;code class=&quot;highlighter-rouge&quot;&gt;std::count()&lt;/code&gt;, spell it that way.&lt;/p&gt;

&lt;h2 id=&quot;overloaded-operators&quot;&gt;Overloaded Operators&lt;/h2&gt;

&lt;p&gt;An operator (e.g. &lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&amp;lt;&lt;/code&gt;) can be thought of as a kind of function name,
e.g. &lt;code class=&quot;highlighter-rouge&quot;&gt;operator+(a,b)&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;operator&amp;lt;&amp;lt;(a,b)&lt;/code&gt;, and are also unqualified. One of the
most important uses of ADL is the search for &lt;code class=&quot;highlighter-rouge&quot;&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; used during logging.
Usually we see something like &lt;code class=&quot;highlighter-rouge&quot;&gt;std::cout &amp;lt;&amp;lt; obj;&lt;/code&gt; for some &lt;code class=&quot;highlighter-rouge&quot;&gt;obj&lt;/code&gt;, let’s say of
type &lt;code class=&quot;highlighter-rouge&quot;&gt;O::Obj&lt;/code&gt;. This statement is like an unqualified function call of the form
&lt;code class=&quot;highlighter-rouge&quot;&gt;operator&amp;lt;&amp;lt;(std::ostream&amp;amp;, const O::Obj&amp;amp;)&lt;/code&gt;, which will find overloads in the
&lt;code class=&quot;highlighter-rouge&quot;&gt;std&lt;/code&gt; namespace from the &lt;code class=&quot;highlighter-rouge&quot;&gt;std::ostream&lt;/code&gt; parameter, the &lt;code class=&quot;highlighter-rouge&quot;&gt;O&lt;/code&gt; namespace from the
&lt;code class=&quot;highlighter-rouge&quot;&gt;O::Obj&lt;/code&gt; parameter, and of course any overloads picked up from the lexical scope
search from the call site.&lt;/p&gt;

&lt;p&gt;It’s important to place such operators in the same namespace as the user-defined
type they’re meant to operate upon: in this case within namespace &lt;code class=&quot;highlighter-rouge&quot;&gt;O&lt;/code&gt;. If the
&lt;code class=&quot;highlighter-rouge&quot;&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; is placed in an outer namespace like &lt;code class=&quot;highlighter-rouge&quot;&gt;::&lt;/code&gt; (the global namespace),
that operator will work for a while until someone quite innocently places an
unrelated &lt;code class=&quot;highlighter-rouge&quot;&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; in namespace ‘O’ for some other type. It takes a bit of
discipline but saves a lot of confusion later to follow the simple rule of
defining all operators and other associated nonmember functions next to the
type’s definition in the same namespace.&lt;/p&gt;

&lt;h2 id=&quot;fundamental-types&quot;&gt;Fundamental Types&lt;/h2&gt;

&lt;p&gt;Note that the fundamental types (e.g. &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt;, etc) are not associated
with the global namespace. They are associated with no namespace. They do not
contribute any namespaces to ADL. Pointer and array types are associated with
their pointee or element types.&lt;/p&gt;

&lt;h2 id=&quot;refactoring-gotchas&quot;&gt;Refactoring Gotchas&lt;/h2&gt;

&lt;p&gt;Refactorings that change the types of arguments to an unqualified function call
can affect which, if any, overloads are considered. Just moving a type into a
namespace and leaving behind a typedef in the old namespace for compatibility
doesn’t help, and really just makes the problem harder to diagnose. Be careful
when moving types to new namespaces.&lt;/p&gt;

&lt;p&gt;Similarly, moving a function to a new namespace and leaving behind a &lt;code class=&quot;highlighter-rouge&quot;&gt;using&lt;/code&gt;
declaration might mean that unqualified calls won’t find it anymore. Sadly, they
might still compile by finding a different function you didn’t intend them to
find. Be careful when moving functions to new namespaces.&lt;/p&gt;

&lt;h2 id=&quot;final-thought&quot;&gt;Final Thought&lt;/h2&gt;

&lt;p&gt;Relatively few programmers understand the exact rules and corner cases involved
with function lookups. The language spec contains 13 pages of rules about what
exactly goes into a name search, including special cases, details about friend
functions, and enclosing class scopes to keep your head spinning for years.
Despite all this complexity, if you keep the basic idea of parallel name
searches in mind, you’ll be on solid footing for understanding how your function
calls and operators are resolving. You will now be able to see how seemingly
remote declarations end up being chosen when you invoke functions or operators.
And you’ll be a little better able to diagnose puzzling build errors like
ambiguities or name-hiding effects when they happen.&lt;/p&gt;

</description>
          <pubDate>2017-11-09T00:00:00-05:00</pubDate>
          <link>http://0.0.0.0:4000/tips/49</link>
          <guid isPermaLink="true">http://0.0.0.0:4000/tips/49</guid>
        </item>
      
    
      
        <item>
          <title>Tip of the Week #135: Test the Contract, not the Implementation</title>
          <description>&lt;p&gt;Originally posted as totw/135 on 2017-08-30&lt;/p&gt;

&lt;p&gt;By James Dennett (jdennett@google.com)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“If you have one true friend you have more than your share.” — Thomas Fuller&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;C++ has a somewhat elaborate access control mechanism using &lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;protected&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;friend&lt;/code&gt;. Test code has its own rules of etiquette
for using those facilities, and GoogleTest augments them with its own
&lt;code class=&quot;highlighter-rouge&quot;&gt;FRIEND_TEST&lt;/code&gt; macro. Use of &lt;code class=&quot;highlighter-rouge&quot;&gt;FRIEND_TEST&lt;/code&gt; should be a last resort, not a
preferred choice.&lt;/p&gt;

&lt;h2 id=&quot;test-the-contract&quot;&gt;Test the Contract&lt;/h2&gt;

&lt;p&gt;We write tests to find bugs in the implementation of a component’s contract, or
to give us sufficient confidence that there are no such bugs. When using
test-driven development (TDD), we also write tests to help us to design that
contract. Tests that depend on unspecified aspects of a component are brittle,
and prone to reporting failures even when the production code is working
correctly.&lt;/p&gt;

&lt;p&gt;Prefer to test via the public interface of a component. More generally, tests
should verify the contract of a component and, just as with any other client,
should not make assumptions beyond what’s guaranteed.&lt;/p&gt;

&lt;h2 id=&quot;augmenting-the-public-api-for-tests&quot;&gt;Augmenting the Public API for Tests&lt;/h2&gt;

&lt;p&gt;Sometimes it’s hard to get sufficient coverage when testing via a minimal
interface. If your component is implementing a very narrow interface specified
by a base class (e.g., one with only a &lt;code class=&quot;highlighter-rouge&quot;&gt;ProcessItem&lt;/code&gt; virtual function) and it’s
impractical to gain sufficient confidence from a test that uses only that
interface, consider creating a new, testable component containing the
implementation details. Then the class containing the virtual function can be so
simple that it needs only minimal testing. BUILD visibility can be used to
restrict use of your implementation class if needed (and if your build system
supports it).&lt;/p&gt;

&lt;p&gt;If a test depends on just one or two private functions, consider making those
functions part of the public interface. This isn’t so bad: you’ll need them to
have a clearly documented interface anyway, and other clients (not just the
test) might find them useful. If, after consideration, you decide that a
function really is only for tests then it should be documented as such, and
maybe named with a &lt;code class=&quot;highlighter-rouge&quot;&gt;ForTesting&lt;/code&gt; suffix.&lt;/p&gt;

&lt;h2 id=&quot;using-peers-to-avoid-exposing-implementation&quot;&gt;Using Peers to Avoid Exposing Implementation&lt;/h2&gt;

&lt;p&gt;If the test still needs to have access to private implementation details, create
a &lt;em&gt;test peer&lt;/em&gt; (sometimes called a &lt;em&gt;test spouse&lt;/em&gt;). A test peer is a friend class
of the class under test, often defined in the &lt;code class=&quot;highlighter-rouge&quot;&gt;_test.cc&lt;/code&gt; file (though some
prefer to define it in the same file as the class that befriends it), and used
to provide controlled access to the class under test to the test code. The test
peer won’t be able to live in an anonymous namespace as its exact name needs to
match the &lt;code class=&quot;highlighter-rouge&quot;&gt;friend&lt;/code&gt; declaration, but the rest of the test code can be in an
anonymous namespace as usual. The name of a test peer class typically ends in
&lt;code class=&quot;highlighter-rouge&quot;&gt;Peer&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;last-resort-use-friend_test&quot;&gt;Last Resort: Use &lt;code class=&quot;highlighter-rouge&quot;&gt;FRIEND_TEST&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;While common in older code, &lt;code class=&quot;highlighter-rouge&quot;&gt;FRIEND_TEST&lt;/code&gt; should not be used in new code. It
introduces reverse coupling, making the production header file depend on details
of the associated unit test. It forces the tests to move out of the anonymous
namespace. Every &lt;code class=&quot;highlighter-rouge&quot;&gt;FRIEND_TEST&lt;/code&gt; grants a test function unrestricted access to
the class under test; in long test functions it can be hard to see where the
test modifies the state of the class under test. It requires use of an unusual
header file provided by &lt;a href=&quot;https://github.com/google/googletest&quot;&gt;GoogleTest&lt;/a&gt; for
inclusion in production code, whereas almost all of GoogleTest is intended only
for use in tests. And finally it scales badly, requiring new &lt;code class=&quot;highlighter-rouge&quot;&gt;FRIEND_TEST&lt;/code&gt; uses
to be added to the production header when new tests are added. In practice this
often results in header files having lengthy blocks of &lt;code class=&quot;highlighter-rouge&quot;&gt;FRIEND_TEST&lt;/code&gt; lines.&lt;/p&gt;

&lt;h2 id=&quot;summary-of-recommendations&quot;&gt;Summary of Recommendations&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Prefer to test the client interface of a component, and keep tests
independent of private implementation details.&lt;/li&gt;
  &lt;li&gt;Factor out a testable, possibly test-only subcomponent if the client
interface isn’t sufficient to thoroughly exercise the unit under test.&lt;/li&gt;
  &lt;li&gt;Sometimes it’s reasonable to add to the public interface in order to make a
component testable.&lt;/li&gt;
  &lt;li&gt;If necessary, access private members from tests using a &lt;em&gt;test peer&lt;/em&gt; rather
than using &lt;code class=&quot;highlighter-rouge&quot;&gt;FRIEND_TEST&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
</description>
          <pubDate>2017-11-09T00:00:00-05:00</pubDate>
          <link>http://0.0.0.0:4000/tips/135</link>
          <guid isPermaLink="true">http://0.0.0.0:4000/tips/135</guid>
        </item>
      
    
      
        <item>
          <title>Tip of the Week #107: Reference Lifetime Extension</title>
          <description>&lt;p&gt;Originally posted as totw/107 on 2015-12-10&lt;/p&gt;

&lt;p&gt;By Titus Winters (titus@google.com)&lt;/p&gt;

&lt;p&gt;There have been some reports of confusion about references and lifetimes after
&lt;a href=&quot;/tips/101&quot;&gt;TotW 101&lt;/a&gt;, so in this Tip we’ll dive more into the question, “When does
reference lifetime extension apply?”&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// Is this safe/legal?
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In short, lifetimes of temporaries (referents) will be extended &lt;em&gt;if and only if&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A local &lt;code class=&quot;highlighter-rouge&quot;&gt;const T&amp;amp;&lt;/code&gt; (or &lt;code class=&quot;highlighter-rouge&quot;&gt;T&amp;amp;&amp;amp;&lt;/code&gt;, although Google style generally ignores that)
is initialized to the result of an expression (usually a function call)
returning a temporary &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; &lt;em&gt;or&lt;/em&gt; the &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; subobject of a temporary (e.g. a
struct containing &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The standard-ese may be a little tricky to unpack, so lets discuss some of the
edge cases to clarify:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;This doesn’t work when assigning to &lt;code class=&quot;highlighter-rouge&quot;&gt;T&amp;amp;&lt;/code&gt;, it must be &lt;code class=&quot;highlighter-rouge&quot;&gt;const T&amp;amp;&lt;/code&gt;. (It’s a
compilation error.)&lt;/li&gt;
  &lt;li&gt;This doesn’t work if there is a (non-polymorphic) type conversion at
play. For instance, assigning to &lt;code class=&quot;highlighter-rouge&quot;&gt;const absl::string_view&amp;amp;&lt;/code&gt; from &lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt;
does not extend the lifetime of the &lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt;. (You also don’t want &lt;code class=&quot;highlighter-rouge&quot;&gt;const
absl::string_view&amp;amp;&lt;/code&gt; in the first place, but that’s a separate issue).&lt;/li&gt;
  &lt;li&gt;This doesn’t work when you’re getting the subobject indirectly: the compiler
doesn’t look through function calls (getters or the like). The subobject
form only works when you’re directly assigning from a public member variable
subobject of the temporary. (So it doesn’t come up often because we don’t
have many expressions that return temporary structs.)&lt;/li&gt;
  &lt;li&gt;The case where type conversion is allowed is when assigning to a &lt;code class=&quot;highlighter-rouge&quot;&gt;T&amp;amp;&lt;/code&gt; from a
temporary of &lt;code class=&quot;highlighter-rouge&quot;&gt;U&lt;/code&gt; when &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; is a parent class of &lt;code class=&quot;highlighter-rouge&quot;&gt;U&lt;/code&gt;. Please don’t do that:
it’s even more confusing for readers than the other cases.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If the lifetime of the temporary is extended, it will last until the reference
goes out of scope. If the lifetime of the temporary isn’t extended in the above
fashion, the &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; being referred to is destroyed at the end of the statement
(when we get to the next &lt;code class=&quot;highlighter-rouge&quot;&gt;;&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;As per &lt;a href=&quot;/tips/101&quot;&gt;TotW 101&lt;/a&gt; you probably shouldn’t rely on lifetime extension
in the explicit case of reference-initialization: it’s not gaining you much/any
performance, and it is subtle, fragile, and prone to cause extra work for your
reviewers and future maintainers.&lt;/p&gt;

&lt;p&gt;There are subtle cases where lifetime extension &lt;em&gt;is&lt;/em&gt; happening and is necessary
and beneficial (like ranged-for over a temporary container), but again, the
extension is only for the result of the temporary expression, not any
sub-expressions. For instance, these work:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GetInts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GetInts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// lifetime extension on the vector is important
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Return string_views of size 1 for each char in this string.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;absl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string_view&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Explode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Lifetime extension kicks in on the vector, but *not* on the temporary string!
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;absl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string_view&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Explode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StrCat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;oo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;ps&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// WRONG
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This does not work:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;MyProto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GetProto&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Lifetime extension *doesn't work* here: sub_protos (a repeated field)
// is destroyed by MyProto going out of scope, and the lifetime extension rules
// don't kick in here to magically lifetime extend the MyProto returned by
// GetProto().  The sub-object lifetime extension only works for simple
// is-a-member-of relationships: the compiler doesn't see that sub_protos()
// itself returning a reference to an sub-object of the outer temporary.
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SubProto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GetProto&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sub_protos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// WRONG
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
          <pubDate>2017-11-02T00:00:00-04:00</pubDate>
          <link>http://0.0.0.0:4000/tips/107</link>
          <guid isPermaLink="true">http://0.0.0.0:4000/tips/107</guid>
        </item>
      
    
      
        <item>
          <title>Tip of the Week #101: Return Values, References, and Lifetimes</title>
          <description>&lt;p&gt;Originally posted as totw/101 on 2015-07-29&lt;/p&gt;

&lt;p&gt;By Titus Winters (titus@google.com)&lt;/p&gt;

&lt;p&gt;Consider the following code snippet:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unique_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Consumer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;consumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Consumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In particular, I’d like to draw your attention to the &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;. Is it appropriate?
What should we check? What can go wrong? I find a decent number of C++
programmers that aren’t entirely clear on references, but do generally know that
they “avoid making copies.” As with most issues in C++, it’s more complicated
than that.&lt;/p&gt;

&lt;h2 id=&quot;case-by-case-what-is-being-returned-and-how-is-it-being-stored&quot;&gt;Case by Case: What is Being Returned and How is it Being Stored?&lt;/h2&gt;

&lt;p&gt;There are two (maybe three) important questions here:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;What type is returned (in this example, by &lt;code class=&quot;highlighter-rouge&quot;&gt;GetName()&lt;/code&gt;)?&lt;/li&gt;
  &lt;li&gt;What type are we storing into/initializing (in this example, what is the
type of &lt;code class=&quot;highlighter-rouge&quot;&gt;name&lt;/code&gt;)?&lt;/li&gt;
  &lt;li&gt;If we are returning a reference, does the object being returned by reference
have any lifetime limitations?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We’ll continue with &lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt; as our example type, but the same arguments
generalize for most non-trivial value types.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Returning &lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt;, initializing &lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt;: This is usually
&lt;a href=&quot;https://en.wikipedia.org/wiki/Return_value_optimization&quot;&gt;RVO&lt;/a&gt; and is
guaranteed to be, at worst, a move for modern types (See &lt;a href=&quot;/tips/77&quot;&gt;TotW
77&lt;/a&gt;).&lt;/li&gt;
  &lt;li&gt;Returning &lt;code class=&quot;highlighter-rouge&quot;&gt;string&amp;amp;&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;const string&amp;amp;&lt;/code&gt;, initializing &lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt;: This is a
copy (there must be some long-living object which we are returning a
reference to, so once we initialize a new string there are two names for
that data, hence a copy. See &lt;a href=&quot;/tips/77&quot;&gt;TotW 77&lt;/a&gt;). Sometimes this is
valuable, like if you need your &lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt; to outlast the lifetime guarantees
provided by the function.&lt;/li&gt;
  &lt;li&gt;Returning &lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt;, initializing &lt;code class=&quot;highlighter-rouge&quot;&gt;string&amp;amp;&lt;/code&gt;: This won’t compile, as you
cannot bind a reference to a temporary.&lt;/li&gt;
  &lt;li&gt;Returning &lt;code class=&quot;highlighter-rouge&quot;&gt;const string&amp;amp;&lt;/code&gt;, initializing &lt;code class=&quot;highlighter-rouge&quot;&gt;string&amp;amp;&lt;/code&gt;: This won’t compile, as
you’ve dropped the const inappropriately.&lt;/li&gt;
  &lt;li&gt;Returning &lt;code class=&quot;highlighter-rouge&quot;&gt;const string&amp;amp;&lt;/code&gt;, initializing &lt;code class=&quot;highlighter-rouge&quot;&gt;const string&amp;amp;&lt;/code&gt;: This is no cost
(you’re effectively returning just a pointer). However, you have inherited
any existing lifetime restrictions: how long is that reference good for?
Most accessor methods that return a reference are returning a member - at
most, the reference can be valid for the life of the containing object.&lt;/li&gt;
  &lt;li&gt;Returning &lt;code class=&quot;highlighter-rouge&quot;&gt;string&amp;amp;&lt;/code&gt;, initializing &lt;code class=&quot;highlighter-rouge&quot;&gt;string&amp;amp;&lt;/code&gt;: This is the same as #5, but
with the additional caveat: the returned reference is non-const, so any
modifications to your reference will be reflected in the source.&lt;/li&gt;
  &lt;li&gt;Returning &lt;code class=&quot;highlighter-rouge&quot;&gt;string&amp;amp;&lt;/code&gt;, initializing &lt;code class=&quot;highlighter-rouge&quot;&gt;const string&amp;amp;&lt;/code&gt;: The same as #5.&lt;/li&gt;
  &lt;li&gt;Returning &lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt;, initializing &lt;code class=&quot;highlighter-rouge&quot;&gt;const string&amp;amp;&lt;/code&gt;: You’d think, given #3,
that this wouldn’t work. However, the language has special-case support for
this: if you initialize a &lt;code class=&quot;highlighter-rouge&quot;&gt;const T&amp;amp;&lt;/code&gt; with a temporary &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;, that &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; (in this
case &lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt;) is not destroyed until the &lt;em&gt;reference&lt;/em&gt; goes out of scope (in
the common case of automatic or static variables).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Scenario #8 is what allows most reflexive use of references (that is “Oh, I
don’t want to copy so I’ll just assign into a reference” without necessarily
thinking about what is being returned). However, because of #1, it’s also
not really doing anything for you: there probably wouldn’t have been a copy in
the first place. Further, now readers of your code have to contend with your
local variable being of type &lt;code class=&quot;highlighter-rouge&quot;&gt;const string&amp;amp;&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt;, and thus worry
about whether the underlying &lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt; has gone out of scope or changed.&lt;/p&gt;

&lt;p&gt;Put another way: when code reviewing the original snippet, I have to worry
about:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Is &lt;code class=&quot;highlighter-rouge&quot;&gt;GetName()&lt;/code&gt; returning by value or by reference?&lt;/li&gt;
  &lt;li&gt;Does the constructor for &lt;code class=&quot;highlighter-rouge&quot;&gt;Consumer&lt;/code&gt; take &lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;const string&amp;amp;&lt;/code&gt; or
&lt;code class=&quot;highlighter-rouge&quot;&gt;string_view&lt;/code&gt;?&lt;/li&gt;
  &lt;li&gt;Does the constructor have any lifetime requirements placed on that
parameter? (If it isn’t just &lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt;.)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;However, if you just declare &lt;code class=&quot;highlighter-rouge&quot;&gt;name&lt;/code&gt; as &lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt; in the first place, it’s
generally no less efficient (because of RVO and move semantics), and at least as
likely to be safe with respect to object lifetimes.&lt;/p&gt;

&lt;p&gt;Additionally, if there is an object lifetime issue, it’s often simpler to spot
when storing as &lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt;: rather than looking at the interplay between the
lifetime promise of &lt;code class=&quot;highlighter-rouge&quot;&gt;GetName()&lt;/code&gt;’s returned reference and the lifetime
requirements of &lt;code class=&quot;highlighter-rouge&quot;&gt;SetName()&lt;/code&gt;, having your own &lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt; means only having to look
at the local code and &lt;code class=&quot;highlighter-rouge&quot;&gt;SetName()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;All of which is to say: avoiding copies is fine, so long as you’re not making
things more complicated. Making code more complicated when there wasn’t a copy
in the first place is not a good tradeoff.&lt;/p&gt;
</description>
          <pubDate>2017-11-02T00:00:00-04:00</pubDate>
          <link>http://0.0.0.0:4000/tips/101</link>
          <guid isPermaLink="true">http://0.0.0.0:4000/tips/101</guid>
        </item>
      
    
      
        <item>
          <title>CppCon 2017: 'A Type, by Any Other Name'</title>
          <description>&lt;h2 id=&quot;jon-cohen-a-type-by-any-other-name&quot;&gt;Jon Cohen: “A Type, by Any Other Name”&lt;/h2&gt;

&lt;p&gt;By &lt;a href=&quot;mailto:shreck@google.com&quot;&gt;Tom Manshreck&lt;/a&gt;, Abseil Tech Writer&lt;/p&gt;

&lt;p&gt;It’s Halloween, so find out what spooky things (like ADL) lurk when
doing a major renaming/refactoring on a codebase as large as Google’s.
Oooh, scary, kids!&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=ely_hVVZjEU&quot; target=&quot;_blank&quot;&gt;
&lt;img src=&quot;/img/cppcon-renaming.png&quot; /&gt;
&lt;/a&gt;&lt;/p&gt;
</description>
          <pubDate>2017-10-31T00:00:00-04:00</pubDate>
          <link>http://0.0.0.0:4000/blog/20171031-cppcon-renaming</link>
          <guid isPermaLink="true">http://0.0.0.0:4000/blog/20171031-cppcon-renaming</guid>
        </item>
      
    
      
        <item>
          <title>Tip of the Week #94: Callsite Readability and bool Parameters</title>
          <description>&lt;p&gt;Originally posted as totw/94 on 2015-04-27&lt;/p&gt;

&lt;p&gt;&lt;em&gt;By Geoff Romer &lt;a href=&quot;mailto:gromer@google.com&quot;&gt;(gromer@google.com)&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Revised 2017-10-25&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“Of the many forms of false culture, a premature converse with abstractions is
perhaps the most likely to prove fatal to the growth of … vigour of
intellect.” — George Boole.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Suppose you come across code like this:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;ParseCommandLineFlags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Can you tell what this code does, and in particular what the last argument
means? Now suppose you’ve come across this function before, and you know that
the last argument has to do with whether command-line flags are left in &lt;code class=&quot;highlighter-rouge&quot;&gt;argv&lt;/code&gt;
after the call. Can you tell which is true and which is false?&lt;/p&gt;

&lt;p&gt;Of course you don’t know, because this is hypothetical, but even in real code,
we have better things to do with our brains than memorize the meaning of every
function parameter, and better things to do with our time than go look up the
documentation for every function call we encounter. We have to be able to make
pretty good guesses about what function calls mean, just from looking at the
callsite.&lt;/p&gt;

&lt;p&gt;Well-chosen function names are the key to making function calls readable, but
they’re often not enough. We usually need the arguments themselves to give us
some clues about what they mean. For example, you might not know what to make of
&lt;code class=&quot;highlighter-rouge&quot;&gt;absl::string_view s(x, y);&lt;/code&gt; if you’d never seen &lt;code class=&quot;highlighter-rouge&quot;&gt;string_view&lt;/code&gt; before, but
&lt;code class=&quot;highlighter-rouge&quot;&gt;absl::string_view s(my_str.data(), my_str.size());&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;absl::string_view
s(&quot;foo&quot;);&lt;/code&gt; are much clearer. The trouble with &lt;code class=&quot;highlighter-rouge&quot;&gt;bool&lt;/code&gt; parameters is that the
argument at the callsite is very often a literal &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;, and that
gives the reader no contextual cues about the meaning of the parameter, as we
saw in the &lt;code class=&quot;highlighter-rouge&quot;&gt;ParseCommandLineFlags()&lt;/code&gt; example. This problem is compounded if
there’s more than one &lt;code class=&quot;highlighter-rouge&quot;&gt;bool&lt;/code&gt; parameter, because now you have the additional
problem of figuring out which parameter is which.&lt;/p&gt;

&lt;p&gt;So how can we fix code like that example? One (bad) possibility is to do
something like this:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;ParseCommandLineFlags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* preserve flags */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The drawbacks of this approach are evident: it’s not clear if that comment is
describing the meaning of the parameter or the effect of the argument. In other
words, is it saying that we’re preserving the flags, or is it saying that it’s
false that we’re preserving the flags? Even if the comment manages to make that
clear, there’s still a risk that the comment will get out of sync with the code.&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;better&lt;/em&gt; approach is to specify the name of the parameter in the comment:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;ParseCommandLineFlags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/*remove_flags=*/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This is much clearer, and much less likely to fall out of sync with the code.
&lt;a href=&quot;https://clang.llvm.org/extra/clang-tidy/checks/misc-argument-comment.html&quot;&gt;Clang-tidy will even
check&lt;/a&gt;
that the comment has the correct parameter name. A less ambiguous but longer
variant is to use an explanatory variable:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;remove_flags&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;ParseCommandLineFlags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;remove_flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;However, explanatory variable names are not checked by the compiler, and so they
may be erroneous. This is a particular problem when you have multiple &lt;code class=&quot;highlighter-rouge&quot;&gt;bool&lt;/code&gt;
parameters, which might be transposed by the caller.&lt;/p&gt;

&lt;p&gt;All these approaches also rely on programmers to consistently remember to add
these comments or variables, and to do so correctly (although clang-tidy will
check the correctness of parameter-name comments).&lt;/p&gt;

&lt;p&gt;In many cases, the best solution is to avoid using &lt;code class=&quot;highlighter-rouge&quot;&gt;bool&lt;/code&gt; parameters in the
first place, and use an &lt;code class=&quot;highlighter-rouge&quot;&gt;enum&lt;/code&gt; instead. For example, &lt;code class=&quot;highlighter-rouge&quot;&gt;ParseCommandLineFlags()&lt;/code&gt;
could be declared like this:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ShouldRemoveFlags&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kDontRemoveFlags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kRemoveFlags&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ParseCommandLineFlags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;***&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ShouldRemoveFlags&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;remove_flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;so that the call could look like this:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;ParseCommandLineFlags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kDontRemoveFlags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;You can also use an &lt;code class=&quot;highlighter-rouge&quot;&gt;enum class&lt;/code&gt;, as described in &lt;a href=&quot;/tips/86&quot;&gt;TotW 86&lt;/a&gt;, but
in that case you’d want to use a slightly different naming convention, e.g.:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ShouldRemoveFlags&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kNo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kYes&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;…&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;ParseCommandLineFlags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ShouldRemoveFlags&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kNo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Obviously, this approach has to be implemented when the function is defined; you
can’t really opt into it at the callsite (you can fake it, but for little
benefit). So when you’re defining a function, particularly if it’s going to be
widely used, the onus is on you to think carefully about how the callsites will
look, and in particular to be very skeptical of &lt;code class=&quot;highlighter-rouge&quot;&gt;bool&lt;/code&gt; parameters.&lt;/p&gt;

</description>
          <pubDate>2017-10-26T00:00:00-04:00</pubDate>
          <link>http://0.0.0.0:4000/tips/94</link>
          <guid isPermaLink="true">http://0.0.0.0:4000/tips/94</guid>
        </item>
      
    
      
        <item>
          <title>Tip of the Week #86: Enumerating with Class</title>
          <description>&lt;p&gt;Originally posted as totw/86 on 2015-01-05&lt;/p&gt;

&lt;p&gt;&lt;em&gt;By Bradley White &lt;a href=&quot;mailto:bww@google.com&quot;&gt;(bww@google.com)&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“Show class, … and display character.” - Bear Bryant.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;An enumeration, or simply an &lt;strong&gt;enum&lt;/strong&gt;, is a type that can hold one of a
specified set of integers. Some values of this set can be given names, and are
called the enumerators.&lt;/p&gt;

&lt;h2 id=&quot;unscoped-enumerations&quot;&gt;Unscoped Enumerations&lt;/h2&gt;

&lt;p&gt;This concept will be familiar to C++ programmers, but prior to C++11
enumerations had two significant shortcomings: the enumeration names were:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;in the same scope as the enum type, and&lt;/li&gt;
  &lt;li&gt;implicitly convertible to values of some integer type.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So, with C++98 …&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CursorDirection&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kRight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kUp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kDown&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;CursorDirection&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// OK: enumerator in scope
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kRight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;// OK: enumerator converts to int
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;but, …&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// error: redeclarations of kLeft and kRight
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PoliticalOrientation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kCenter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;C++11 modified the behavior of unscoped enums in one way: the enumerators are
now local to the enum, but continue to be exported into the enum’s scope for
backwards compatibility.&lt;/p&gt;

&lt;p&gt;So, with C++11 …&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;CursorDirection&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CursorDirection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// OK in C++11
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CursorDirection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kRight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;             &lt;span class=&quot;c1&quot;&gt;// OK: still converts to int
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;but the declaration of &lt;code class=&quot;highlighter-rouge&quot;&gt;PoliticalOrientation&lt;/code&gt; would still elicit errors.&lt;/p&gt;

&lt;h2 id=&quot;scoped-enumerations&quot;&gt;Scoped Enumerations&lt;/h2&gt;

&lt;p&gt;The implicit conversion to integer has been observed to be a common source of
bugs, while the namespace pollution caused by having the enumerators in the same
scope as the enum causes problems in large, multi-library projects. To address
both these concerns, C++11 introduced a new concept: the &lt;strong&gt;scoped enum&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;In a scoped enum, introduced by the keywords &lt;code class=&quot;highlighter-rouge&quot;&gt;enum class&lt;/code&gt;, the enumerators are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;only local to the enum (they are not exported into the enum’s scope), and&lt;/li&gt;
  &lt;li&gt;not implicitly convertible to integer types.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So, (note the additional class keyword) …&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CursorDirection&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kRight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kUp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kDown&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;CursorDirection&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                    &lt;span class=&quot;c1&quot;&gt;// error: kLeft not in this scope
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CursorDirection&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CursorDirection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// OK
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CursorDirection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kRight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;              &lt;span class=&quot;c1&quot;&gt;// error: no conversion
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;and, …&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// OK: kLeft and kRight are local to each scoped enum
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PoliticalOrientation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kCenter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;These simple changes eliminate the problems with plain enumerations, so enum
class should be preferred in all new code.&lt;/p&gt;

&lt;p&gt;Using a scoped enum does mean that you’ll have to explicitly cast to an integer
type should you still want such a conversion (e.g., when logging an enumeration
value, or when using bitwise operations on flag-like enumerators). Hashing with
&lt;code class=&quot;highlighter-rouge&quot;&gt;std::hash&lt;/code&gt; will continue to work though (e.g.,
&lt;code class=&quot;highlighter-rouge&quot;&gt;std::unordered_map&amp;lt;CursorDirection, int&amp;gt;&lt;/code&gt;).&lt;/p&gt;

&lt;h2 id=&quot;underlying-enumeration-types&quot;&gt;Underlying Enumeration Types&lt;/h2&gt;

&lt;p&gt;C++11 also introduced the ability to specify the underlying type for both
varieties of enumeration. Previously the underlying integer type of an enum was
determined by examining the sign and magnitude of the enumerators, but now we
can be explicit. For example, …&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Use &quot;int&quot; as the underlying type for CursorDirection
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CursorDirection&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kRight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kUp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kDown&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Because this enumerator range is small, and if we wished to avoid wasting space
when storing &lt;code class=&quot;highlighter-rouge&quot;&gt;CursorDirection&lt;/code&gt; values, we could specify &lt;code class=&quot;highlighter-rouge&quot;&gt;char&lt;/code&gt; instead.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Use &quot;char&quot; as the underlying type for CursorDirection
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CursorDirection&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kRight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kUp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kDown&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The compiler will issue an error if an enumerator value exceeds the range of the
underlying type.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Prefer using &lt;code class=&quot;highlighter-rouge&quot;&gt;enum class&lt;/code&gt; in new code. You’ll reduce namespace pollution, and
you may avoid bugs in implicit conversions.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Parting&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kSoLong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kFarewell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kAufWiedersehen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kAdieu&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
          <pubDate>2017-10-26T00:00:00-04:00</pubDate>
          <link>http://0.0.0.0:4000/tips/86</link>
          <guid isPermaLink="true">http://0.0.0.0:4000/tips/86</guid>
        </item>
      
    
      
        <item>
          <title>Tip of the Week #64: Raw String Literals</title>
          <description>&lt;p&gt;Originally published as totw/64 on 2013-12-09&lt;/p&gt;

&lt;p&gt;&lt;em&gt;By Titus Winters &lt;a href=&quot;mailto:titus@google.com&quot;&gt;(titus@google.com)&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Updated 2017-10-23&lt;/p&gt;

&lt;p&gt;Quicklink: &lt;a href=&quot;https://abseil.io/tips/64&quot;&gt;abseil.io/tips/64&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;(?:\&quot;(?:\\\\\&quot;|[^\&quot;])*\&quot;|'(?:\\\\'|[^'])*')&quot;;&lt;/code&gt; — A cat walking over the
keyboard . . . or maybe what the fox says . . . no, actually just a highly-
escaped regexp found in real C++ code.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Odds are you’ve had trouble getting your regular expression understood properly
in C++ due to escaping issues. Similarly, you’ve probably been annoyed with
preserving quotes and newlines when embedding a text version of Protobuf or JSON
data into your unittests. When you have to use significant escaping (or worse,
multi-layer escaping), code clarity drops precipitously.&lt;/p&gt;

&lt;p&gt;Luckily, there’s a new C++11 feature that removes this need for escaping: raw
string literals.&lt;/p&gt;

&lt;h2 id=&quot;the-raw-string-literal-format&quot;&gt;The Raw String Literal Format&lt;/h2&gt;

&lt;p&gt;A raw string literal has the following special syntax:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;R&quot;tag(whatever you want to say)tag&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tag&lt;/code&gt; is a sequence of up to 16 characters (and an empty tag is both OK and
common). The characters after ‘“tag(‘ and before the first following occurrence
of ‘)tag”’ are used literally as the contents of the string literal. ‘tag’ may
contain any character but parentheses, backslash, and whitespace.&lt;/p&gt;

&lt;p&gt;Examine the difference:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;concert_17_raw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;id: 17&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;artist: &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Beyonce&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;date: &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Wed Oct 10 12:39:54 EDT 2012&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;price_usd: 200&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;versus:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;concert_17_raw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;R&quot;(
    id: 17
    artist: &quot;Beyonce&quot;
    date: &quot;Wed Oct 10 12:39:54 EDT 2012&quot;
    price_usd: 200)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;special-cases&quot;&gt;Special Cases&lt;/h2&gt;

&lt;p&gt;Note that indentation rules, combined with the fact that raw string literals may
contain newlines, leave you with an awkward choice on how to indent the first
line of your raw string block. Because text protobufs ignore whitespace, this
problem can be avoided by throwing in a leading newline (ignored by the parser)
in that case, but not all uses of raw strings are so forgiving.&lt;/p&gt;

&lt;p&gt;A non-empty tag is useful when the sequence &lt;code class=&quot;highlighter-rouge&quot;&gt;)&quot;&lt;/code&gt; happens to appear in your
string and therefore can’t act as the closing delimiter:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;my_string&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;R&quot;foo(This contains quoted parens &quot;()&quot;)foo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Raw string literals are certainly not an everyday tool for most of us, but there
are times when good use of this new language feature will increase readability.
So the next time you’re scratching your head trying to figure out if you need
two &lt;code&gt;\\&lt;/code&gt;s or four, try raw string literals instead. Your readers will
thank you for it, even if regular expressions are still hard:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;R&quot;regexp((?:&quot;(?:\\&quot;|[^&quot;])*&quot;|'(?:\\'|[^'])*'))regexp&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
          <pubDate>2017-10-26T00:00:00-04:00</pubDate>
          <link>http://0.0.0.0:4000/tips/64</link>
          <guid isPermaLink="true">http://0.0.0.0:4000/tips/64</guid>
        </item>
      
    
      
        <item>
          <title>CppCon 2017: The design of absl::StrCat</title>
          <description>&lt;h2 id=&quot;jorg-browns-lightning-talk&quot;&gt;Jorg Brown’s Lightning Talk&lt;/h2&gt;

&lt;p&gt;By &lt;a href=&quot;mailto:shreck@google.com&quot;&gt;Tom Manshreck&lt;/a&gt;, Abseil Tech Writer&lt;/p&gt;

&lt;p&gt;Check out Jorg Brown’s Lightning Talk on the design of &lt;code class=&quot;highlighter-rouge&quot;&gt;absl::StrCat()&lt;/code&gt;
for background on what problem it was designed to solve and why it was
designed the way it was.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=tuWnw3sWZ4w&quot; target=&quot;_blank&quot;&gt;
&lt;img src=&quot;/img/cppcon-strcat.png&quot; /&gt;
&lt;/a&gt;&lt;/p&gt;
</description>
          <pubDate>2017-10-23T00:00:00-04:00</pubDate>
          <link>http://0.0.0.0:4000/blog/20171023-cppcon-strcat</link>
          <guid isPermaLink="true">http://0.0.0.0:4000/blog/20171023-cppcon-strcat</guid>
        </item>
      
    
      
        <item>
          <title>Tip of the Week #77: Temporaries, Moves, and Copies</title>
          <description>&lt;p&gt;Originally published as totw/77 on 2014-07-09&lt;/p&gt;

&lt;p&gt;&lt;em&gt;By Titus Winters &lt;a href=&quot;mailto:titus@google.com&quot;&gt;(titus@google.com)&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Updated 2017-10-20&lt;/p&gt;

&lt;p&gt;Quicklink: &lt;a href=&quot;https://abseil.io/tips/77&quot;&gt;abseil.io/tips/77&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In the ongoing attempt to figure out how to explain to non-language-lawyers how
C++11 changed things, we present yet another entry in the series “When are
copies made?” This is part of a general attempt to simplify the subtle rules
that have surrounded copies in C++ and replace it with a simpler set of rules.&lt;/p&gt;

&lt;h2 id=&quot;can-you-count-to-2&quot;&gt;Can You Count to 2?&lt;/h2&gt;

&lt;p&gt;You can? Awesome. Remember that the “name rule” means that each unique name you
can assign to a certain resource affects how many copies of the object are in
circulation. (See &lt;a href=&quot;/tips/55&quot;&gt;TotW 55&lt;/a&gt; on Name Counting for a refresher.)&lt;/p&gt;

&lt;h2 id=&quot;name-counting-in-brief&quot;&gt;Name Counting, in Brief&lt;/h2&gt;

&lt;p&gt;If you’re worrying about a copy being created, presumably you’re worried about
some line of code in particular. So, look at that point. How many names exist
for the data you think is being copied? There are only 3 cases to consider:&lt;/p&gt;

&lt;h2 id=&quot;two-names-its-a-copy&quot;&gt;Two Names: It’s a Copy&lt;/h2&gt;

&lt;p&gt;This one is easy: if you’re giving a second name to the same data, it’s a copy.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;FillAVectorOfIntsByOutputParameterSoNobodyThinksAboutCopies&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// Yep, this is a copy.
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;my_map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;forty_two&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;42&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;my_map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;forty_two&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;// Also a copy: my_map[5] counts as a name.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;one-name-its-a-move&quot;&gt;One Name: It’s a Move&lt;/h2&gt;

&lt;p&gt;This one is a little surprising: C++11 recognizes that if you can’t refer to a
name anymore, you also don’t care about that data anymore. The language had to
be careful not to break cases where you were relying on the destructor (say,
&lt;code class=&quot;highlighter-rouge&quot;&gt;absl::MutexLock&lt;/code&gt;), so &lt;code class=&quot;highlighter-rouge&quot;&gt;return&lt;/code&gt; is the easy case to identify.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GetSomeInts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Just a move: either &quot;ret&quot; or &quot;foo&quot; has the data, but never both at once.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GetSomeInts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The other way to tell the compiler that you’re done with a name (the “name
eraser” from &lt;a href=&quot;/tips/55&quot;&gt;TotW 55&lt;/a&gt;) is calling &lt;code class=&quot;highlighter-rouge&quot;&gt;std::move()&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GetSomeInts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Not a copy, move allows the compiler to treat foo as a
// temporary, so this is invoking the move constructor for
// std::vector&amp;lt;int&amp;gt;.
// Note that it isn’t the call to std::move that does the moving,
// it’s the constructor. The call to std::move just allows foo to
// be treated as a temporary (rather than as an object with a name).
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;zero-names-its-a-temporary&quot;&gt;Zero Names: It’s a Temporary&lt;/h2&gt;

&lt;p&gt;Temporaries are also special: if you want to avoid copies, avoid providing names
to variables.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OperatesOnVector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// No copies: the values in the vector returned by GetSomeInts()
// will be moved (O(1)) into the temporary constructed between these
// calls and passed by reference into OperatesOnVector().
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OperatesOnVector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetSomeInts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;beware-zombies&quot;&gt;Beware: Zombies&lt;/h2&gt;

&lt;p&gt;The above (other than &lt;code class=&quot;highlighter-rouge&quot;&gt;std::move()&lt;/code&gt; itself) is hopefully pretty intuitive, it’s
just that we all built up weird notions of copies in the years pre-dating C++11.
For a language without garbage collection, this type of accounting gives us an
excellent mix of performance and clarity. However, it’s not without dangers, and
the big one is this: what is left in a value after it has been moved from?&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;CHECK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Is this valid? Maybe, but don’t count on it.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This is one of the major difficulties: what can we say about these leftover
values? For most standard library types, such a value is left in a “valid but
unspecified state.” Non-standard types usually hold to the same rule. The safe
approach is to stay away from these objects: you are allowed to re-assign to
them, or let them go out of scope, but don’t make any other assumptions about
their state.&lt;/p&gt;

&lt;p&gt;Clang-tidy provides some some static-checking to catch use-after move with the
&lt;a href=&quot;http://clang.llvm.org/extra/clang-tidy/checks/misc-use-after-move.html&quot;&gt;misc-use-after-move&lt;/a&gt;
check. However, static-analysis won’t ever be able to catch all of these - be on
the lookout. Call these out in code review, and avoid them in your own code.
Stay away from the zombies.&lt;/p&gt;

&lt;h2 id=&quot;wait-stdmove-doesnt-move&quot;&gt;Wait, &lt;code class=&quot;highlighter-rouge&quot;&gt;std::move&lt;/code&gt; Doesn’t Move?&lt;/h2&gt;

&lt;p&gt;Yeah, one other thing to watch for is that a call to &lt;code class=&quot;highlighter-rouge&quot;&gt;std::move()&lt;/code&gt; isn’t 
actually a move itself, it’s just a cast to an rvalue-reference. It’s only the 
use of that reference by a move constructor or move assignment that does the 
work.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GetSomeInts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Does nothing.
// Invokes std::vector&amp;lt;int&amp;gt;’s move-constructor.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This should almost never happen, and you probably shouldn’t waste a lot of
mental storage on it. I really only mention it if the connection between
&lt;code class=&quot;highlighter-rouge&quot;&gt;std::move()&lt;/code&gt; and a move constructor was confusing you.&lt;/p&gt;

&lt;h2 id=&quot;aaaagh-its-all-complicated-why&quot;&gt;Aaaagh! It’s All Complicated! Why!?!&lt;/h2&gt;

&lt;p&gt;First: it’s really not so bad. Since we have move operations in the majority of
our value types (including protobufs), we can do away with all of the
discussions of “Is this a copy? Is this efficient?” and just rely on name
counting: two names, a copy. Fewer than that: no copy.&lt;/p&gt;

&lt;p&gt;Ignoring the issue of copies, value semantics are clearer and simpler to reason
about. Consider these two operations:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;paths&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;ExpandGlob&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GenerateGlob&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;paths&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;paths&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;ExpandGlob&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GenerateGlob&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;paths&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;paths&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Are these the same? What about if there is existing data in &lt;code class=&quot;highlighter-rouge&quot;&gt;*paths&lt;/code&gt;? How can
you tell? Value semantics are easier for a reader to reason about than
input/output parameters, where you need to think about (and document) what
happens to existing data, and potentially whether there is an pointer ownership
transfer.&lt;/p&gt;

&lt;p&gt;Because of the simpler guarantees about lifetime and usage when dealing with
values (instead of pointers), it is easier for the compiler’s optimizers to
operate on code in that style. Well-managed value semantics also minimizes hits
on the allocator (which is cheap but not free). Once we understand how move
semantics help rid us of copies, the compiler’s optimizers can better reason
about object types, lifetimes, virtual dispatch, and a host of other issues that
help generate more efficient machine code.&lt;/p&gt;

&lt;p&gt;Since most utility code is now move-aware, we should stop worrying about copies
and pointer semantics, and focus on writing simple easy-to-follow code. Please
make sure you understand the new rules: not all legacy interfaces you encounter
may be updated to return by value (instead of by output parameter), so there will
always be a mix of styles. It’s important that you understand when one is more
appropriate than the other.&lt;/p&gt;

</description>
          <pubDate>2017-10-20T00:00:00-04:00</pubDate>
          <link>http://0.0.0.0:4000/tips/77</link>
          <guid isPermaLink="true">http://0.0.0.0:4000/tips/77</guid>
        </item>
      
    
      
        <item>
          <title>Tip of the Week #55: Name Counting and unique_ptr</title>
          <description>&lt;p&gt;Originally published as totw/55 on 2013-09-12&lt;/p&gt;

&lt;p&gt;&lt;em&gt;by Titus Winters &lt;a href=&quot;mailto:titus@google.com&quot;&gt;(titus@google.com)&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Updated 2017-10-20&lt;/p&gt;

&lt;p&gt;Quicklink: &lt;a href=&quot;https://abseil.io/tips/55&quot;&gt;abseil.io/tips/55&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“Though we may know Him by a thousand names, He is one and the same to us
all.” - Mahatma Gandhi&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Colloquially, a “name” for a value is any value-typed variable (not a pointer,
nor a reference), in any scope, that holds a particular data value. (For the
spec-lawyers, if we say “name” we’re essentially talking about lvalues.) Because
of &lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&lt;/code&gt;’s specific behavioral requirements, we need to make sure
that any value held in a &lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&lt;/code&gt; only has one name.&lt;/p&gt;

&lt;p&gt;It’s important to note that the C++ language committee picked a very apt name
for &lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&lt;/code&gt;. Any non-null pointer value stored in a &lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&lt;/code&gt;
must occur in only one &lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&lt;/code&gt; at any time; the standard library is
designed to enforce this. Many common problems compiling code that uses
&lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&lt;/code&gt; can be resolved by learning to recognize how to count the
names for a &lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&lt;/code&gt;: one is OK, but multiple names for the same
pointer value are not.&lt;/p&gt;

&lt;p&gt;Let’s count some names. At each line number, count the number of names alive at
that point (whether in scope or not) that refer to a &lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&lt;/code&gt;
containing the same pointer. If you find any line with more than one name for
the same pointer value, that’s an error!&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unique_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NewFoo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unique_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AcceptFoo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unique_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PrintDebugString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Simple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;AcceptFoo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewFoo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DoesNotBuild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unique_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NewFoo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;AcceptFoo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// DOES NOT COMPILE!
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SmarterThanTheCompilerButNot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Compiles, BUT VIOLATES THE RULE and will double-delete at runtime.
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unique_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unique_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In &lt;code class=&quot;highlighter-rouge&quot;&gt;Simple()&lt;/code&gt;, the unique pointer allocated with &lt;code class=&quot;highlighter-rouge&quot;&gt;NewFoo()&lt;/code&gt; only ever has one
name by which you could refer it: the name “f” inside &lt;code class=&quot;highlighter-rouge&quot;&gt;AcceptFoo()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Contrast this with &lt;code class=&quot;highlighter-rouge&quot;&gt;DoesNotBuild()&lt;/code&gt;: the unique pointer allocated with
&lt;code class=&quot;highlighter-rouge&quot;&gt;NewFoo()&lt;/code&gt; has two names which refer to it: &lt;code class=&quot;highlighter-rouge&quot;&gt;DoesNotBuild()&lt;/code&gt;’s “g” and
&lt;code class=&quot;highlighter-rouge&quot;&gt;AcceptFoo()&lt;/code&gt;’s “f”.&lt;/p&gt;

&lt;p&gt;This is the classic uniqueness violation: at any given point in the execution,
any value held by a &lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&lt;/code&gt; (or more generally, any move-only type)
can only be referred to by a single distinct name. Anything that looks like a
copy introducing an additional name is forbidden and won’t compile:&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;scratch.cc: error: call to deleted constructor of std::unique_ptr&amp;lt;Foo&amp;gt;'
  AcceptFoo(g);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Even if the compiler doesn’t catch you, the runtime behavior of
&lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&lt;/code&gt; will. Any time where you “outsmart” the compiler (see
&lt;code class=&quot;highlighter-rouge&quot;&gt;SmarterThanTheCompilerButNot()&lt;/code&gt;) and introduce multiple &lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&lt;/code&gt;
names, it may compile (for now) but you’ll get a run-time memory problem.&lt;/p&gt;

&lt;p&gt;Now the question becomes: how do we remove a name? C++11 provides a solution for
that as well, in the form of &lt;code class=&quot;highlighter-rouge&quot;&gt;std::move()&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;EraseTheName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unique_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NewFoo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;AcceptFoo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Fixes DoesNotBuild with std::move
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The call to &lt;code class=&quot;highlighter-rouge&quot;&gt;std::move()&lt;/code&gt; is effectively a name-eraser: conceptually you can
stop counting “h” as a name for the pointer value. This now passes the
distinct-names rule: on the unique pointer allocated with &lt;code class=&quot;highlighter-rouge&quot;&gt;NewFoo()&lt;/code&gt; has a
single name (“h”), and within the call to &lt;code class=&quot;highlighter-rouge&quot;&gt;AcceptFoo()&lt;/code&gt; there is again only a
single name (“f”). By  using &lt;code class=&quot;highlighter-rouge&quot;&gt;std::move()&lt;/code&gt; we promise that we will not read
from “h” again until we assign a new value to it.&lt;/p&gt;

&lt;p&gt;Name counting is a handy trick in modern C++ for those that aren’t expert in the
subtleties of lvalues, rvalues, etc: it can help you recognize the possibility
of unnecessary copies, and it will help you use &lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&lt;/code&gt; properly.
After counting, if you discover a point where there are too many names, use
&lt;code class=&quot;highlighter-rouge&quot;&gt;std::move&lt;/code&gt; to erase the no-longer-necessary name.&lt;/p&gt;
</description>
          <pubDate>2017-10-20T00:00:00-04:00</pubDate>
          <link>http://0.0.0.0:4000/tips/55</link>
          <guid isPermaLink="true">http://0.0.0.0:4000/tips/55</guid>
        </item>
      
    
      
        <item>
          <title>Tip of the Week #122: Test Fixtures, Clarity, and Dataflow</title>
          <description>&lt;p&gt;Originally published as totw/122 on 2016-08-30&lt;/p&gt;

&lt;p&gt;&lt;em&gt;By Titus Winters &lt;a href=&quot;mailto:titus@google.com&quot;&gt;(titus@google.com)&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Updated 2017-10-20&lt;/p&gt;

&lt;p&gt;Quicklink: &lt;a href=&quot;https://abseil.io/tips/122&quot;&gt;abseil.io/tips/122&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Be obscure clearly.&lt;/em&gt; — E.B. White&lt;/p&gt;

&lt;p&gt;How does test code differ from production code? For one thing, tests are
untested: when you write messy spaghetti code that is spread over several files
and has hundreds of lines of &lt;code class=&quot;highlighter-rouge&quot;&gt;SetUp&lt;/code&gt; how can anyone be sure that the test is
really testing what it needs to? Too often your code reviewers will have to
assume that the setup makes sense and are at best spot-checking the logic for
each individual test case. In those cases, your test is likely to fail if
something changes, but it’s rarely clear whether that something is the right
something.&lt;/p&gt;

&lt;p&gt;On the other hand, if you keep each test simple and as straightforward as
possible, it’s easier to see that it is correct by inspection, understand the
logic, and review for higher quality test logic. Let’s look at a few simple ways
to achieve that.&lt;/p&gt;

&lt;h2 id=&quot;dataflow-in-fixtures&quot;&gt;Dataflow in Fixtures&lt;/h2&gt;

&lt;p&gt;Consider the following example:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FrobberTest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;testing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Test&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;protected&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ConfigureExampleA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;example_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Example A&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;frobber_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;example_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;expected_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Result A&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ConfigureExampleB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;example_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Example B&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;frobber_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;example_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;expected_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Result B&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;Frobber&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;frobber_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;example_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expected_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;TEST_F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FrobberTest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CalculatesA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;ConfigureExampleA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;frobber_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Calculate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;EXPECT_EQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expected_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;TEST_F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FrobberTest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CalculatesB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;ConfigureExampleB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;frobber_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Calculate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;EXPECT_EQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expected_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In this fairly simple example, our tests span 30 lines of code. It’s very easy
to imagine less simple examples that are 10x that: certainly more than will fit
on any single screen. A reader or code reviewer that wants to validate that the
code is correct has to scan around as follows:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;“OK, this is a FrobberTest, where’s that defined … oh, this file. Great.”&lt;/li&gt;
  &lt;li&gt;“&lt;code class=&quot;highlighter-rouge&quot;&gt;ConfigureExampleA&lt;/code&gt; … that’s a FrobberTest method. It’s operating on some
member variables. What types are those? How are they initialized? OK,
Frobber and two strings. Is there a &lt;code class=&quot;highlighter-rouge&quot;&gt;SetUp&lt;/code&gt;? OK, default constructed.”&lt;/li&gt;
  &lt;li&gt;“Back to the test: OK, we calculate a result and compare it against
&lt;code class=&quot;highlighter-rouge&quot;&gt;expected_&lt;/code&gt; … what did we store there again?”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Compare to the equivalent code written in a simpler style:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;TEST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FrobberTest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CalculatesA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Frobber&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;frobber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;frobber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Example A&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;EXPECT_EQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frobber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Calculate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Result A&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;TEST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FrobberTest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CalculatesB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Frobber&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;frobber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;frobber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Example B&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;EXPECT_EQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frobber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Calculate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Result B&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;With this style, even in a world where we have hundreds of tests, we can tell
with only local information exactly what is going on.&lt;/p&gt;

&lt;h2 id=&quot;prefer-free-functions&quot;&gt;Prefer Free Functions&lt;/h2&gt;

&lt;p&gt;In the previous example, all of the variable initialization was nice and terse.
In real tests, that isn’t always true. However, the same ideas about dataflow
and avoiding fixtures may apply. Consider this protobuf example:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BobberTest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;testing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Test&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;protected&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SetUp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;bobber1_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PARSE_TEXT_PROTO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;R&quot;(
        id: 17
        artist: &quot;Beyonce&quot;
        when: &quot;2012-10-10 12:39:54 -04:00&quot;
        price_usd: 200)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;bobber2_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PARSE_TEXT_PROTO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;R&quot;(
        id: 21
        artist: &quot;The Shouting Matches&quot;
        when: &quot;2016-08-24 20:30:21 -04:00&quot;
        price_usd: 60)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;BobberProto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bobber1_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;BobberProto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bobber2_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;TEST_F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BobberTest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UsesProtos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Bobber&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bobber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bobber1_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bobber2_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;SomeCall&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;EXPECT_THAT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bobber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MostRecent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EqualsProto&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bobber2_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Again, the centralized refactoring leads to a lot of indirection: declarations
and initialization are separate, and potentially far away from actual use.
Further, because of &lt;code class=&quot;highlighter-rouge&quot;&gt;SomeCall()&lt;/code&gt; in the middle, and the fact we’re using a
fixture and fixture member variables, there’s no way to be &lt;em&gt;sure&lt;/em&gt; that
&lt;code class=&quot;highlighter-rouge&quot;&gt;bobber1_&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;bobber2_&lt;/code&gt; weren’t modified between initialization and the
&lt;code class=&quot;highlighter-rouge&quot;&gt;EXPECT_THAT&lt;/code&gt; validation, without checking the details of &lt;code class=&quot;highlighter-rouge&quot;&gt;SomeCall()&lt;/code&gt;. More
scrolling around is likely necessary.&lt;/p&gt;

&lt;p&gt;Consider instead:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;BobberProto&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;RecentCheapConcert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PARSE_TEXT_PROTO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;R&quot;(
      id: 21
      artist: &quot;The Shouting Matches&quot;
      when: &quot;2016-08-24 20:30:21 -04:00&quot;
      price_usd: 60)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;BobberProto&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;PastExpensiveConcert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PARSE_TEXT_PROTO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;R&quot;(
      id: 17
      artist: &quot;Beyonce&quot;
      when: &quot;2012-10-10 12:39:54 -04:00&quot;
      price_usd: 200)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;TEST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BobberTest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UsesProtos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Bobber&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bobber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PastExpensiveConcert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RecentCheapConcert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()});&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;SomeCall&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;EXPECT_THAT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bobber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MostRecent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EqualsProto&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RecentCheapConcert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Moving the initialization into free functions makes it clear that there is no
hidden dataflow. Well chosen names for the helpers mean that you can likely
review the test for correctness without even scrolling up to see the details of
the helper.&lt;/p&gt;

&lt;h2 id=&quot;five-easy-steps&quot;&gt;Five Easy Steps&lt;/h2&gt;

&lt;p&gt;You can generally improve test clarity by following these steps:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Avoid fixtures where reasonable. Sometimes it’s not.&lt;/li&gt;
  &lt;li&gt;If you are using fixtures, try to avoid fixture member variables. It is far
too easy to start operating on those in ways akin to globals: data flow is
hard to track since absolutely any code path in the fixture may modify the
member.&lt;/li&gt;
  &lt;li&gt;If you’ve got variables that need complex initialization that would make
each test hard to read, consider a helper function (not part of the fixture)
that documents that initialization and returns the object directly.&lt;/li&gt;
  &lt;li&gt;If you must have fixtures that contain member variables, try to avoid
methods that operate on those members directly: pass them in as parameters
whenever possible to make the dataflow clear.&lt;/li&gt;
  &lt;li&gt;Try to write tests before writing headers: if you start with a usage that is
pleasant to test, your API is usually better, and your tests are almost
always clearer.&lt;/li&gt;
&lt;/ul&gt;
</description>
          <pubDate>2017-10-20T00:00:00-04:00</pubDate>
          <link>http://0.0.0.0:4000/tips/122</link>
          <guid isPermaLink="true">http://0.0.0.0:4000/tips/122</guid>
        </item>
      
    
      
        <item>
          <title>CppCon 2017: C++ as a 'Live at Head' Language</title>
          <description>&lt;h2 id=&quot;titus-winters-plenary-keynote&quot;&gt;Titus Winters’ Plenary Keynote&lt;/h2&gt;

&lt;p&gt;By &lt;a href=&quot;mailto:shreck@google.com&quot;&gt;Tom Manshreck&lt;/a&gt;, Abseil Tech Writer&lt;/p&gt;

&lt;p&gt;If you didn’t get a chance to check out Titus Winters’ plenary
keynote in person, check it out below.&lt;/p&gt;

&lt;p&gt;Find out why “Living at Head” is a good thing!&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=tISy7EJQPzI&amp;amp;t=1032s&quot; target=&quot;_blank&quot;&gt;
&lt;img src=&quot;/img/cppcon-plenary.jpg&quot; /&gt;
&lt;/a&gt;&lt;/p&gt;
</description>
          <pubDate>2017-10-04T00:00:00-04:00</pubDate>
          <link>http://0.0.0.0:4000/blog/20171004-cppcon-plenary</link>
          <guid isPermaLink="true">http://0.0.0.0:4000/blog/20171004-cppcon-plenary</guid>
        </item>
      
    
      
        <item>
          <title>Welcome to Abseil!</title>
          <description>&lt;h2 id=&quot;a-new-common-libraries-project&quot;&gt;A New Common Libraries Project&lt;/h2&gt;

&lt;p&gt;By &lt;a href=&quot;mailto:titus@google.com&quot;&gt;Titus Winters&lt;/a&gt;, Abseil Lead&lt;/p&gt;

&lt;p&gt;Today we are open sourcing &lt;a href=&quot;https://abseil.io&quot;&gt;Abseil&lt;/a&gt;, a collection of 
libraries drawn from the most fundamental pieces of Google’s internal codebase. 
These libraries are the nuts-and-bolts that underpin almost everything that 
Google runs. Bits and pieces of these APIs are embedded in most of our open 
source projects, and now we have brought them together into one comprehensive 
project. Abseil encompasses the most basic building blocks of Google’s 
codebase: code that is production tested and will be fully maintained for years 
to come.&lt;/p&gt;

&lt;p&gt;Our C++ code repository is available at
&lt;a href=&quot;https://github.com/abseil/abseil-cpp&quot;&gt;https://github.com/abseil/abseil-cpp&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;By adopting these new Apache-licensed libraries, you can reap the benefit of years (over a decade in many cases) of our design and optimization work in this space. Our past experience is baked in.&lt;/p&gt;

&lt;p&gt;Just as interesting, we’ve also prepared for the future: several types in
 Abseil’s C++ libraries are “pre-adoption” versions of C++17 types like 
 &lt;a href=&quot;http://en.cppreference.com/w/cpp/string/basic_string_view&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;string_view&lt;/code&gt;&lt;/a&gt; and 
 &lt;a href=&quot;http://en.cppreference.com/w/cpp/utility/optional&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;optional&lt;/code&gt;&lt;/a&gt; - implemented 
 in C++11 to the greatest extent possible. We look forward to moving more and 
 more of our code to match the current standard, and using these new vocabulary 
 types helps us make that transition. Importantly, in C++17 mode these types 
 are merely aliases to the standard, ensuring that you only ever have one type 
 for &lt;code class=&quot;highlighter-rouge&quot;&gt;optional&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;string_view&lt;/code&gt; in a project at a time. Put another way: 
 Abseil is focused on the engineering task of providing APIs that remain stable 
 &lt;strong&gt;over time&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Consisting of the foundational C++ and Python code at Google, Abseil includes 
libraries that will grow to underpin other Google-backed open source projects 
like &lt;a href=&quot;https://grpc.io/&quot;&gt;gRPC&lt;/a&gt;, &lt;a href=&quot;https://github.com/google/protobuf&quot;&gt;Protobuf&lt;/a&gt; 
and &lt;a href=&quot;https://www.tensorflow.org/&quot;&gt;TensorFlow&lt;/a&gt;. We love those projects, and we 
love the users of those projects - we want to ensure smooth usage for these 
things over time. In the next few months we’ll introduce new distribution 
methods to incorporate these projects as a collection into your project.&lt;/p&gt;

&lt;p&gt;Continuing with the “over time” theme, Abseil aims for compatibility with major 
compilers, platforms and standard libraries for approximately 5 years. Our 
5-year target also applies to language version: we assume everyone builds with 
C++11 at this point. (In 2019 we’ll start talking about requiring C++14 as our 
base language version.) This 5-year horizon is part of our balance between 
“support everything” and “provide modern implementations and APIs.”&lt;/p&gt;

&lt;p&gt;Highlights of the initial release include:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Zero configuration: most platforms (OS, compiler, architecture) should just 
work.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/about/design/dropin-types&quot;&gt;Pre-adoption for C++17 types&lt;/a&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;string_view&lt;/code&gt;, 
&lt;code class=&quot;highlighter-rouge&quot;&gt;optional&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;any&lt;/code&gt;. We’ll follow up with &lt;code class=&quot;highlighter-rouge&quot;&gt;variant&lt;/code&gt; soon.&lt;/li&gt;
  &lt;li&gt;Our primary synchronization type, &lt;a href=&quot;/about/design/mutex&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;absl::Mutex&lt;/code&gt;&lt;/a&gt;, has 
an elegant interface and has been extensively optimized.&lt;/li&gt;
  &lt;li&gt;Efficient support for handling time: &lt;code class=&quot;highlighter-rouge&quot;&gt;absl::Time&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;absl::Duration&lt;/code&gt; are 
conceptually similar to &lt;code class=&quot;highlighter-rouge&quot;&gt;std::chrono&lt;/code&gt; types, but are concrete (not class 
templates) and have defined behavior in all cases. Additionally, our 
clock-sampling API &lt;code class=&quot;highlighter-rouge&quot;&gt;absl::Now()&lt;/code&gt; is more heavily optimized than most standard 
library calls for &lt;code class=&quot;highlighter-rouge&quot;&gt;std::chrono::system_clock::now()&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;String handling routines: among internal users, we’ve been told that 
releasing &lt;code class=&quot;highlighter-rouge&quot;&gt;absl::StrCat()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;absl::StrJoin()&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;absl::StrSplit()&lt;/code&gt; would 
itself be a big improvement for the open source C++ world.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The project has support for C++ and some Python. Over time we’ll tie those two 
projects together more closely with shared logging and command-line flag 
infrastructure. To start contributing, please see our contribution guidelines 
and fork us on &lt;a href=&quot;https://github.com/abseil/&quot;&gt;GitHub&lt;/a&gt;. Check out our 
&lt;a href=&quot;/docs&quot;&gt;documentation&lt;/a&gt; and &lt;a href=&quot;/community&quot;&gt;community page&lt;/a&gt; for information on how 
to contact us, ask questions or contribute to Abseil.&lt;/p&gt;
</description>
          <pubDate>2017-09-26T00:00:00-04:00</pubDate>
          <link>http://0.0.0.0:4000/blog/20170926-welcome-to-abseil</link>
          <guid isPermaLink="true">http://0.0.0.0:4000/blog/20170926-welcome-to-abseil</guid>
        </item>
      
    
      
        <item>
          <title>Tip of the Week #1: string_view</title>
          <description>&lt;p&gt;Originally published as totw/1 on 2012-04-20&lt;/p&gt;

&lt;p&gt;&lt;em&gt;By Michael Chastain &lt;a href=&quot;mailto:mec.desktop@gmail.com&quot;&gt;(mec.desktop@gmail.com)&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Updated 2017-09-18&lt;/p&gt;

&lt;h2 id=&quot;whats-a-string_view-and-why-should-you-care&quot;&gt;What’s a &lt;code class=&quot;highlighter-rouge&quot;&gt;string_view&lt;/code&gt;, and Why Should You Care?&lt;/h2&gt;

&lt;p&gt;When creating a function to take a (constant) string as an argument, you have
four alternatives: two that you already know, and two of which you might
not be aware:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TakesCharStar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;             &lt;span class=&quot;c1&quot;&gt;// C convention
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TakesString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;             &lt;span class=&quot;c1&quot;&gt;// Old Standard C++ convention
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TakesStringView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;absl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string_view&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// Abseil C++ convention
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TakesStringView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string_view&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;// C++17 C++ convention
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The first two cases work best when a caller has the string in the format already
provided, but what happens when a conversion is needed (either from &lt;code class=&quot;highlighter-rouge&quot;&gt;const
char*&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;const char*&lt;/code&gt;)?&lt;/p&gt;

&lt;p&gt;Callers needing to convert a &lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt; to a &lt;code class=&quot;highlighter-rouge&quot;&gt;const char*&lt;/code&gt; need to use the
(efficient but inconvenient) &lt;code class=&quot;highlighter-rouge&quot;&gt;c_str()&lt;/code&gt; function:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;AlreadyHasString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;TakesCharStar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;               &lt;span class=&quot;c1&quot;&gt;// explicit conversion
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Callers needing to convert a &lt;code class=&quot;highlighter-rouge&quot;&gt;const char*&lt;/code&gt; to a string don’t need to do anything
additional (the good news) but will invoke the creation of a (convenient but
inefficient) temporary string, copying the contents of that string (the bad
news):&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;AlreadyHasCharStar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;TakesString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// compiler will make a copy
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;what-to-do&quot;&gt;What to Do?&lt;/h2&gt;

&lt;p&gt;Google’s preferred option for accepting such string parameters is through a
&lt;code class=&quot;highlighter-rouge&quot;&gt;string_view&lt;/code&gt;. This is a “pre-adopted” type from C++17 - in C++17 builds you
should use &lt;code class=&quot;highlighter-rouge&quot;&gt;std::string_view&lt;/code&gt;, in any code that can’t rely on C++17 yet you
should use &lt;code class=&quot;highlighter-rouge&quot;&gt;absl::string_view&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;An instance of the &lt;code class=&quot;highlighter-rouge&quot;&gt;string_view&lt;/code&gt; class can be thought of as a “view” into an
existing character buffer. Specifically, a &lt;code class=&quot;highlighter-rouge&quot;&gt;string_view&lt;/code&gt; consists of only a
pointer and a length, identifying a section of character data that is not owned
by the &lt;code class=&quot;highlighter-rouge&quot;&gt;string_view&lt;/code&gt; and cannot be modified by the view. Consequently, making a
copy of a &lt;code class=&quot;highlighter-rouge&quot;&gt;string_view&lt;/code&gt; is a shallow operation: no string data is copied.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;string_view&lt;/code&gt; has implicit conversion constructors from both &lt;code class=&quot;highlighter-rouge&quot;&gt;const char*&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;const string&amp;amp;&lt;/code&gt;, and since &lt;code class=&quot;highlighter-rouge&quot;&gt;string_view&lt;/code&gt; doesn’t copy, there is no O(n) memory
penalty for making a hidden copy. In the case where a &lt;code class=&quot;highlighter-rouge&quot;&gt;const string&amp;amp;&lt;/code&gt; is passed,
the constructor runs in O(1) time. In the case where a &lt;code class=&quot;highlighter-rouge&quot;&gt;const char*&lt;/code&gt; is passed,
the constructor invokes a &lt;code class=&quot;highlighter-rouge&quot;&gt;strlen()&lt;/code&gt; automatically (or you can use the
two-parameter &lt;code class=&quot;highlighter-rouge&quot;&gt;string_view&lt;/code&gt; constructor).&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;AlreadyHasString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;TakesStringView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// no explicit conversion; convenient!
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;AlreadyHasCharStar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;TakesStringView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// no copy; efficient!
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Because the &lt;code class=&quot;highlighter-rouge&quot;&gt;string_view&lt;/code&gt; does not own its data, any strings pointed to by the
&lt;code class=&quot;highlighter-rouge&quot;&gt;string_view&lt;/code&gt; (just like a &lt;code class=&quot;highlighter-rouge&quot;&gt;const char*&lt;/code&gt;) must have a known lifespan, and must
outlast the &lt;code class=&quot;highlighter-rouge&quot;&gt;string_view&lt;/code&gt; itself. This means that using &lt;code class=&quot;highlighter-rouge&quot;&gt;string_view&lt;/code&gt; for
storage is often questionable: you need some proof that the underlying data will
outlive the &lt;code class=&quot;highlighter-rouge&quot;&gt;string_view&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If your API only needs to reference the string data during a single call, and
doesn’t need to modify the data, accepting a &lt;code class=&quot;highlighter-rouge&quot;&gt;string_view&lt;/code&gt; is sufficient. If you
need to reference the data later or need to modify the data, you can explicitly
convert to a C++ string object using &lt;code class=&quot;highlighter-rouge&quot;&gt;string(my_string_view)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Adding &lt;code class=&quot;highlighter-rouge&quot;&gt;string_view&lt;/code&gt; into an existing codebase is not always the right answer:
changing parameters to pass by &lt;code class=&quot;highlighter-rouge&quot;&gt;string_view&lt;/code&gt; can be inefficient if those are
then passed to a function requiring a &lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt; or a NUL-terminated &lt;code class=&quot;highlighter-rouge&quot;&gt;const
char*&lt;/code&gt;. It is best to adopt &lt;code class=&quot;highlighter-rouge&quot;&gt;string_view&lt;/code&gt; starting at the utility code and
working upward, or with complete consistency when starting a new project.&lt;/p&gt;

&lt;h2 id=&quot;a-few-additional-notes&quot;&gt;A Few Additional Notes&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Unlike other string types, you should pass &lt;code class=&quot;highlighter-rouge&quot;&gt;string_view&lt;/code&gt; by value just like
you would an int or a double because &lt;code class=&quot;highlighter-rouge&quot;&gt;string_view&lt;/code&gt; is a small value.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;string_view&lt;/code&gt; is not necessarily NUL-terminated. Thus, it’s not safe to
write:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// DON’T DO THIS
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;However, the following is fine:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%.*s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;You can output a &lt;code class=&quot;highlighter-rouge&quot;&gt;string_view&lt;/code&gt; just like you would a string or a
  &lt;code class=&quot;highlighter-rouge&quot;&gt;const char*&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Took '&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;'&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;You can convert an existing routine that accepts &lt;code class=&quot;highlighter-rouge&quot;&gt;const string&amp;amp;&lt;/code&gt; or
NUL-terminated &lt;code class=&quot;highlighter-rouge&quot;&gt;const char*&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;string_view&lt;/code&gt; safely in most cases. The only
danger we have encountered in performing this operation is if the address of
the function has been taken, this will result in a build break as the
resulting function-pointer type will be different.&lt;/li&gt;
&lt;/ul&gt;
</description>
          <pubDate>2017-09-26T00:00:00-04:00</pubDate>
          <link>http://0.0.0.0:4000/tips/1</link>
          <guid isPermaLink="true">http://0.0.0.0:4000/tips/1</guid>
        </item>
      
    
  </channel>
</rss>