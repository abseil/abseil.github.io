<!DOCTYPE html>
<html lang="en" itemscope itemtype="https://schema.org/WebPage">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="title" content="Abseil open-source foundational code">
    <meta name="description" content="Battle-tested, Mom-approved">
    <title>abseil / Strings Library</title>

    <!-- Fontawesome Icons -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
    
    <!-- Favicons -->
    <link rel="shortcut icon" type="image/x-icon" href="/favicons/favicon.ico" />
    
    <!-- Bootstrap -->
    <link href="/libs/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Site style using SASS, generated by from style.scss -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Slick styling -->
    <link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/jquery.slick/1.6.0/slick.css"/>
    <link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/jquery.slick/1.6.0/slick-theme.css"/>

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- metadata -->
    <meta name="og:title" content="abseil / Strings Library"/>
	 <meta name="og:description" content="An open-source collection of core C++ library code"/>
  </head>
  <body class=>

  	<nav id="sticky-nav">
  <div class="nav-container container">
    <div class="row">
      <div class="col-md-11 nofloat center-block">
        <a class="col-xs-2" href="/">
          <img class="nav-logo" src="/img/absl_18px.svg" alt="Abseil">
        </a>

        <div class="col-xs-2 col-xs-offset-8">
          <button type="button" class="hamburger navbar-toggle collapsed" data-target="#navbar-collapse-1">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
        </div>

        <ul class="nav col-xs-10">
          
          <li><a href="/about" >About</a></li>
          <li><a href="/docs/" class='current'>Docs</a></li>
		  <li><a href="/tips/" >Tips</a></li>
          <li><a href="/blog/" >Blog</a></li>
          <li><a href="/community/" >Community</a></li>
        </ul>

      </div>
    </div>
  </div>

  <div class="top-nav right">
    
    <li class="nav-item"><a href="/"><p>Home</p></a><div class="nav-toggle icon-close"></div></li>
    <hr>
    <li class="nav-item"><a href="/about" ><p>About</p></a></li>
    <hr>
    <li class="nav-item"><a href="/docs/" class='current'><p>Docs</p></a>
      <div class="nav-doc-toggle icon-caret"></div>
      <ul class="doc-list">
        <a href="/docs/cpp" ><li class="nav-doc-tab">C++ Devguide</li></a>
        <a href="/docs/cpp/quickstart" ><li class="nav-doc-tab">C++ Quick Start</li></a>
      </ul>
    </li>
    <hr>
    <li class="nav-item"><a href="/tips/" ><p>Tips</p></a></li>
    <hr>
    <li class="nav-item"><a href="/blog/" ><p>Blog</p></a></li>
    <hr>
    <li class="nav-item"><a href="/community/" ><p>Community</p></a></li>
  </div>
</nav>


<div class="nav-hero-container">
	<nav id="common-nav">
  <div class="nav-container container">
    <div class="row">
      <div class="col-md-11 nofloat center-block">
        <a class="col-xs-2" href="/">
          <img class="nav-logo" src="/img/absl_80px.png" alt="Abseil">
        </a>

        <div class="col-xs-2 col-xs-offset-8">
          <button type="button" class="hamburger navbar-toggle collapsed" data-target="#navbar-collapse-1">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
        </div>

        <ul class="nav col-xs-10">
          
          <li><a href="/about" >About</a></li>
          <li><a href="/docs/" class='current'>Docs</a></li>
          <li><a href="/tips/" >C++ Tips</a></li>
		  <li><a href="/blog/" >Blog</a></li>
          <li><a href="/community" >Community</a></li>
        </ul>

      </div>
    </div>
  </div>

  <div class="top-nav right">
    
    <li class="nav-item"><a href="/"><p>Home</p></a><div class="nav-toggle icon-close"></div></li>
    <hr>
    <li class="nav-item"><a href="/about/" ><p>About</p></a></li>
    <hr>
    <li class="nav-item"><a href="/docs/" class='current'><p>Docs</p></a>
      <div class="nav-doc-toggle icon-caret"></div>
      <ul class="doc-list">
        <a href="/docs/cpp/quickstart" ><li class="nav-doc-tab">Quickstart</li></a>
      </ul>
    </li>
    <hr>
    <li class="nav-item"><a href="/blog/" ><p>Blog</p></a></li>
    <hr>
    <li class="nav-item"><a href="/tips/" ><p>Tips</p></a></li>
    <hr>
    <li class="nav-item"><a href="/community/" ><p>Community</p></a></li>
  </div>
  <div class="container">
    <div class="row">
      <div class="col-md-11 nofloat center-block">
        <div class="col-xs-12">
          <h1 class="page-headline"></h1> 
        </div>
      </div>
    </div>
  </div>

</nav>

   <a href="https://github.com/abseil/" class="fork-btn" target="_blank"></a>

</div>



<div class="container">
<div class="row">
<div class="col-md-11 nofloat center-block ">
<div class="col-sm-3">
<ul class="doc-side-nav">
	
	<li><h5 class="doc-side-nav-title"><a href="/docs/">Docs</a></h5></li>
	<li><h5 class="doc-side-nav-title">
	<a href="/docs/cpp.html" class='current'><b>C++ Devguide</b></a></h5></li>
	<li class="doc-side-nav-list-item">
	  <a href="/docs/cpp/quickstart" >
	  Quickstart</a></li>
	  
	<li><h6 class="doc-side-nav-title">
	  <a href="/docs/cpp/guides/" class='current'>
	Programming Guides</a></h6></li>
	
   <li class="doc-side-nav-list-item">
     <a href="/docs/cpp/guides/base" >
     Abseil Fundamentals</a></li>
   <li class="doc-side-nav-list-item">
     <a href="/docs/cpp/guides/synchronization" >
     Synchronization</a></li>
   <li class="doc-side-nav-list-item">
     <a href="/docs/cpp/guides/strings" class='current'>
     Strings</a></li>
	 
  <li><h6 class="doc-side-nav-title">
  <a href="/docs/cpp/platforms/" >
   Platforms Guide</a></h6></li>
   
   <li class="doc-side-nav-list-item">
	<a href="/docs/cpp/platforms/platforms" >
	Supported Platforms</a></li>
	<li class="doc-side-nav-list-item">
	<a href="/docs/cpp/platforms/feature_checks" >
	Feature Check Macros</a></li>
 </ul>

</div>
<div class="col-sm-7 markdown">
<p>The <code class="highlighter-rouge">absl/strings</code> library provides classes and utility functions for
manipulating and comparing strings, converting other types (such as integers)
into strings, or evaluating strings for other usages. Additionally, the
<code class="highlighter-rouge">strings</code> library also contains utility functions for “string-like” classes that
store data within contiguous memory.</p>

<p>This document outlines highlights and general use cases for the <code class="highlighter-rouge">strings</code>
library. For more detailed information about specific classes, functions, and
fields, consult source documentation within the particular header file.</p>

<p>Although “strings” are often thought of as a standard type in C++, they are not
a built-in type, but instead are provided in the Standard Library through the
<code class="highlighter-rouge">std::string</code> class. Fundamentally, a string consists of a size, and an array of
<code class="highlighter-rouge">char</code> characters.</p>

<h2 id="string_view">The <code class="highlighter-rouge">absl::string_view</code> Container</h2>

<p>Oftentimes, you need to access string data, but you don’t need to own it, and
you don’t need to modify it. For this reason, Abseil defines an
<code class="highlighter-rouge">absl::string_view</code> class, which points to a contiguous span of characters,
often part or all of another <code class="highlighter-rouge">std::string</code>, double-quoted string literal,
character array, or even another <code class="highlighter-rouge">string_view</code>. A <code class="highlighter-rouge">string_view</code>, as its name
implies, provides a read-only view of its associated string data.</p>

<p>Most C++ code has historically used either the (older) C <code class="highlighter-rouge">char*</code> pointer type or
the C++ <code class="highlighter-rouge">std::string</code> class to hold character data. Methods that wish to consume
data of both types would typically need to provide overloaded implementations if
they wanted to avoid copying data. A <code class="highlighter-rouge">string_view</code> also acts as a wrapper around
APIs that accept both types of character data; methods can simply declare that
they accept <code class="highlighter-rouge">absl::string_view</code>.</p>

<p><code class="highlighter-rouge">string_view</code> objects are very lightweight, so you should always pass them by
value within your methods and functions; don’t pass a <code class="highlighter-rouge">const absl::string_view
&amp;</code>. (Passing <code class="highlighter-rouge">absl::string_view</code> instead of <code class="highlighter-rouge">const absl::string_view &amp;</code> has the
same algorithmic complexity, but because of register allocation and parameter
passing rules, it is generally faster to pass by value in this case.)</p>

<p>As noted above, because the <code class="highlighter-rouge">string_view</code> does not own the underlying data
itself, it should only be used for read-only data. If you need to provide a
string constant to an external API user, for example, you would still internally
declare that string as <code class="highlighter-rouge">const char[]</code>; however, you would expose that data using
an <code class="highlighter-rouge">string_view</code>.</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">// If an API declare a string literal as const char ...
</span><span class="k">const</span> <span class="kt">char</span> <span class="n">kGreeting</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"hi"</span><span class="p">;</span>

<span class="c1">// API users could access this string data for reading using a string_view.
</span><span class="n">absl</span><span class="o">::</span><span class="n">string_view</span> <span class="n">GetGreeting</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">kGreeting</span><span class="p">;</span> <span class="p">}</span>
</code></pre>
</div>

<p>A <code class="highlighter-rouge">string_view</code> is also suitable for local variables if you know that the
lifetime of the underlying object is longer than the lifetime of your
<code class="highlighter-rouge">string_view</code> variable. However, beware of binding it to a temporary value:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">// BAD use of string_view: lifetime problem
</span><span class="n">absl</span><span class="o">::</span><span class="n">string_view</span> <span class="n">sv</span> <span class="o">=</span> <span class="n">obj</span><span class="p">.</span><span class="n">ReturnAString</span><span class="p">();</span>

<span class="c1">// GOOD use of string_view: str outlives sv
</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="n">obj</span><span class="p">.</span><span class="n">ReturnAString</span><span class="p">();</span>
<span class="n">absl</span><span class="o">::</span><span class="n">string_view</span> <span class="n">sv</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
</code></pre>
</div>

<p>Due to lifetime issues, a <code class="highlighter-rouge">string_view</code> is usually a poor choice for a return
value and almost always a poor choice for a data member. If you do use one this
way, it is your responsibility to ensure that the <code class="highlighter-rouge">string_view</code> does not outlive
the object it points to.</p>

<p>A <code class="highlighter-rouge">string_view</code> may represent a whole string or just part of a string. For
example, when splitting a string, <code class="highlighter-rouge">std::vector&lt;absl::string_view&gt;</code> is a natural
data type for the output.</p>

<h2 id="abslstrsplit-for-splitting-strings"><code class="highlighter-rouge">absl::StrSplit()</code> for Splitting Strings</h2>

<p>The <code class="highlighter-rouge">absl::StrSplit()</code> function provides an easy way to split strings into
substrings. <code class="highlighter-rouge">StrSplit()</code> takes an input string to be split, a delimiter on which
to split the string (e.g. a comma <code class="highlighter-rouge">,</code>), and (optionally), a predicate to act as
a filter on whether split elements will be included in the result set.
<code class="highlighter-rouge">StrSplit()</code> also adapts the returned collection to the type specified by the
caller.</p>

<p>Examples:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">// Splits the given string on commas. Returns the results in a
// vector of strings. (Data is copied once.)
</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">StrSplit</span><span class="p">(</span><span class="s">"a,b,c"</span><span class="p">,</span> <span class="sc">','</span><span class="p">);</span>  <span class="c1">// Can also use ","
// v[0] == "a", v[1] == "b", v[3] == "c"
</span>
<span class="c1">// Splits the string as in the previous example, except that the results
// are returned as `absl::string_view` objects, avoiding copies. Note that
// because we are storing the results within `absl::string_view` objects, we
// have to ensure that the input string outlives any results.
</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">absl</span><span class="o">::</span><span class="n">string_view</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">StrSplit</span><span class="p">(</span><span class="s">"a,b,c"</span><span class="p">,</span> <span class="sc">','</span><span class="p">);</span>
<span class="c1">// v[0] == "a", v[1] == "b", v[3] == "c"
</span></code></pre>
</div>

<p><code class="highlighter-rouge">StrSplit()</code> splits strings using a passed <em>Delimiter</em> object. (See
<a href="#Delimiters">Delimiters</a> below.) However, in many cases, you can simply pass a
string literal as the delimiter (which will be implicitly converted to an
<code class="highlighter-rouge">absl::ByString</code> delimiter).</p>

<p>Examples:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">// By default, empty strings are *included* in the output. See the
// `absl::SkipEmpty()` predicate below to omit them{#stringSplitting}.
</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">StrSplit</span><span class="p">(</span><span class="s">"a,b,,c"</span><span class="p">,</span> <span class="sc">','</span><span class="p">);</span>
<span class="c1">// v[0] == "a", v[1] == "b", v[3] == "", v[4] = "c"
</span>
<span class="c1">// You can also split an empty string
</span><span class="n">v</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">StrSplit</span><span class="p">(</span><span class="s">""</span><span class="p">,</span> <span class="sc">','</span><span class="p">);</span>
<span class="c1">// v[0] = ""
</span>
<span class="c1">// The delimiter need not be a single character
</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">StrSplit</span><span class="p">(</span><span class="s">"aCOMMAbCOMMAc"</span><span class="p">,</span> <span class="s">"COMMA"</span><span class="p">);</span>
<span class="c1">// v[0] == "a", v[1] == "b", v[2] == "c"
</span>
<span class="c1">// You can also use the empty string as the delimiter, which will split
// a string into its constituent characters.
</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">StrSplit</span><span class="p">(</span><span class="s">"abcd"</span><span class="p">,</span> <span class="s">""</span><span class="p">);</span>
<span class="c1">// v[0] == "a", v[1] == "b", v[2] == "c", v[3] = "d"
</span></code></pre>
</div>

<h3 id="adaptation-to-returned-types">Adaptation to Returned Types</h3>

<p>One of the more useful features of the <code class="highlighter-rouge">StrSplit()</code> API is its ability to adapt
its result set to the desired return type. <code class="highlighter-rouge">StrSplit()</code> returned collections may
contain <code class="highlighter-rouge">std::string</code>, <code class="highlighter-rouge">absl::string_view</code>, or any object that can be explicitly
created from an <code class="highlighter-rouge">absl::string_view</code>. This pattern works for all standard STL
containers including <code class="highlighter-rouge">std::vector</code>, <code class="highlighter-rouge">std::list</code>, <code class="highlighter-rouge">std::deque</code>, <code class="highlighter-rouge">std::set</code>,
<code class="highlighter-rouge">std::multiset</code>, <code class="highlighter-rouge">std::map</code>, and <code class="highlighter-rouge">std::multimap</code>, and even <code class="highlighter-rouge">std::pair</code>, which is
not actually a container.</p>

<p>Examples:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">// Stores results in a std::set&lt;std::string&gt;, which also performs de-duplication
// and orders the elements in ascending order.
</span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">StrSplit</span><span class="p">(</span><span class="s">"b,a,c,a,b"</span><span class="p">,</span> <span class="sc">','</span><span class="p">);</span>
<span class="c1">// v[0] == "a", v[1] == "b", v[3] == "c"
</span>
<span class="c1">// Stores results in a map. The map implementation assumes that the input
// is provided as a series of key/value pairs. For example, the 0th element
// resulting from the split will be stored as a key to the 1st element. If
// an odd number of elements are resolved, the last element is paired with
// a default-constructed value (e.g., empty string).
</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">StrSplit</span><span class="p">(</span><span class="s">"a,b,c"</span><span class="p">,</span> <span class="sc">','</span><span class="p">);</span>
<span class="c1">// m["a"] == "b", m["c"] == "" // last component value equals ""
</span>
<span class="c1">// Stores first two split strings as the members in a std::pair. Any split
// strings beyond the first two are omitted because std::pair can hold only two
// elements.
</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">StrSplit</span><span class="p">(</span><span class="s">"a,b,c"</span><span class="p">,</span> <span class="sc">','</span><span class="p">);</span>
<span class="c1">// p.first = "a", p.second = "b" ; "c" is omitted
</span></code></pre>
</div>

<h3 id="delimiters">Delimiters</h3>

<p>The <code class="highlighter-rouge">StrSplit()</code> API provides a number of “Delimiters” for providing special
delimiter behavior. A Delimiter implementation contains a <code class="highlighter-rouge">Find()</code> function that
knows how to find the first occurrence of itself in a given <code class="highlighter-rouge">absl::string_view</code>.
Models of the Delimiter concept represent specific kinds of delimiters, such as
single characters, substrings, or even regular expressions.</p>

<p>The following Delimiter abstractions are provided as part of the <code class="highlighter-rouge">StrSplit()</code>
API:</p>

<ul>
  <li><code class="highlighter-rouge">absl::ByString()</code> (default for <code class="highlighter-rouge">std::string</code> arguments)</li>
  <li><code class="highlighter-rouge">absl::ByChar()</code> (default for a <code class="highlighter-rouge">char</code> argument)</li>
  <li><code class="highlighter-rouge">absl::ByAnyChar()</code> (for mixing delimiters)</li>
  <li><code class="highlighter-rouge">absl::ByLength()</code> (for applying a delimiter a set number of times)</li>
  <li><code class="highlighter-rouge">absl::MaxSplits()</code> (for splitting a specific number of times)</li>
</ul>

<p>Examples:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">// Because a `string` literal is converted to an `absl::ByString`, the following
// two splits are equivalent.
</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">StrSplit</span><span class="p">(</span><span class="s">"a,b,c"</span><span class="p">,</span> <span class="s">","</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">StrSplit</span><span class="p">(</span><span class="s">"a,b,c"</span><span class="p">,</span> <span class="n">absl</span><span class="o">::</span><span class="n">ByString</span><span class="p">(</span><span class="s">","</span><span class="p">));</span>
<span class="c1">// v[0] == "a", v[1] == "b", v[3] == "c"
</span>
<span class="c1">// Because a `char` literal is converted to an `absl::ByChar`, the following two
// splits are equivalent.
</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">StrSplit</span><span class="p">(</span><span class="s">"a,b,c"</span><span class="p">,</span> <span class="sc">','</span><span class="p">);</span>
<span class="c1">// v[0] == "a", v[1] == "b", v[3] == "c"
</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">StrSplit</span><span class="p">(</span><span class="s">"a,b,c"</span><span class="p">,</span> <span class="n">absl</span><span class="o">::</span><span class="n">ByChar</span><span class="p">(</span><span class="sc">','</span><span class="p">));</span>
<span class="c1">// v[0] == "a", v[1] == "b", v[3] == "c"
</span>
<span class="c1">// Splits on any of the given characters ("," or ";")
</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">StrSplit</span><span class="p">(</span><span class="s">"a,b;c"</span><span class="p">,</span> <span class="n">absl</span><span class="o">::</span><span class="n">ByAnyChar</span><span class="p">(</span><span class="s">",;"</span><span class="p">));</span>
<span class="c1">// v[0] == "a", v[1] == "b", v[3] == "c"
</span>
<span class="c1">// Uses the `absl::MaxSplits` delimiter to limit the number of matches a
// delimiter can have. In this case, the delimiter of a literal comma is limited
// to matching at most one time. The last element in the returned collection
// will contain all unsplit pieces, which may contain instances of the
// delimiter.
</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">StrSplit</span><span class="p">(</span><span class="s">"a,b,c"</span><span class="p">,</span> <span class="n">absl</span><span class="o">::</span><span class="n">MaxSplits</span><span class="p">(</span><span class="sc">','</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
<span class="c1">// v[0] == "a", v[1] == "b,c"
</span>
<span class="c1">// Splits into equal-length substrings.
</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">StrSplit</span><span class="p">(</span><span class="s">"12345"</span><span class="p">,</span> <span class="n">absl</span><span class="o">::</span><span class="n">ByLength</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
<span class="c1">// v[0] == "12", v[1] == "34", v[3] == "5"
</span></code></pre>
</div>

<h3 id="filtering-predicates">Filtering Predicates</h3>

<p>Predicates can filter the results of a <code class="highlighter-rouge">StrSplit()</code> operation by determining
whether or not a resultant element is included in the result set. A filtering
predicate may be passed as an <em>optional</em> third argument to the <code class="highlighter-rouge">StrSplit()</code>
function.</p>

<p>The predicates must be unary functions (or functors) that take a single
<code class="highlighter-rouge">absl::string_view</code> argument and return a bool indicating whether the argument
should be included (<code class="highlighter-rouge">true</code>) or excluded (<code class="highlighter-rouge">false</code>).</p>

<p>One example where using predicates is useful: filtering out empty substrings. By
default, empty substrings may be returned by <code class="highlighter-rouge">StrSplit()</code> as separate elements
in the result set, which is similar to the way split functions work in other
programming languages.</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">// Empty strings *are* included in the returned collection.
</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">StrSplit</span><span class="p">(</span><span class="s">",a,,b,"</span><span class="p">,</span> <span class="sc">','</span><span class="p">);</span>
<span class="c1">// v[0] == "", v[1] == "a", v[2] == "", v[3] = "b", v[4] = ""
</span></code></pre>
</div>

<p>These empty strings can be filtered out of the result set by simply passing the
provided <code class="highlighter-rouge">SkipEmpty()</code> predicate as a third argument to the <code class="highlighter-rouge">StrSplit()</code>
function. <code class="highlighter-rouge">SkipEmpty()</code> does not consider a string containing all whitespace to
be empty. For that behavior use the <code class="highlighter-rouge">SkipWhitespace()</code> predicate.</p>

<p>Examples:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">// Uses absl::SkipEmpty() to omit empty strings. Strings containing whitespace
// are not empty and are therefore not skipped.
</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">StrSplit</span><span class="p">(</span><span class="s">",a, ,b,"</span><span class="p">,</span> <span class="sc">','</span><span class="p">,</span> <span class="n">absl</span><span class="o">::</span><span class="n">SkipEmpty</span><span class="p">());</span>
<span class="c1">// v[0] == "a", v[1] == " ", v[2] == "b"
</span>
<span class="c1">// Uses absl::SkipWhitespace() to skip all strings that are either empty or
// contain only whitespace.
</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">StrSplit</span><span class="p">(</span><span class="s">",a, ,b,"</span><span class="p">,</span> <span class="sc">','</span><span class="p">,</span>
                                            <span class="n">absl</span><span class="o">::</span><span class="n">SkipWhitespace</span><span class="p">());</span>
<span class="c1">// v[0] == "a", v[1] == "b"
</span></code></pre>
</div>

<h2 id="abslstrcat-and-abslstrappend-for-string-concatentation"><code class="highlighter-rouge">absl::StrCat()</code> and <code class="highlighter-rouge">absl::StrAppend()</code> for String Concatentation</h2>

<p>Most documentation on the usage of C++ strings mention that unlike other
languages, strings in C++ are mutable; however, modifying a string can be
expensive, as strings often contain a large amount of data, and many patterns
involve the creation of temporary copies, which may involve significant
overhead. Always look for ways to reduce creation of such temporaries.</p>

<p>For example, the following code is inefficient:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">// Inefficient code
</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s1</span><span class="p">;</span>
<span class="n">s1</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">+</span> <span class="s">" another string"</span><span class="p">;</span>
</code></pre>
</div>

<p>The assignment operator above creates a temporary string, copies <code class="highlighter-rouge">s1</code> into that
temporary string, concatenates that temporary string, and then assigns it back
to <code class="highlighter-rouge">s1</code>. Instead use the optimized <code class="highlighter-rouge">+=</code> operator for such concatenation:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">// Efficient code
</span><span class="n">s1</span> <span class="o">+=</span> <span class="s">" another string"</span><span class="p">;</span>
</code></pre>
</div>

<p>Good compilers may be able to optimize the preceding inefficient code. However,
operations that involve more than one concatenation cannot normally avoid
temporaries:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">// Inefficient code
</span><span class="n">string</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"A string"</span><span class="p">;</span>
<span class="n">string</span> <span class="n">another</span> <span class="o">=</span> <span class="s">" and another string"</span><span class="p">;</span>
<span class="n">s1</span> <span class="o">+=</span> <span class="s">" and some other string"</span> <span class="o">+</span> <span class="n">another</span><span class="p">;</span>
</code></pre>
</div>

<p>For that reason, Abseil provides the <code class="highlighter-rouge">absl::StrCat()</code> and <code class="highlighter-rouge">absl::StrAppend()</code>
functions for efficiently concatenating and appending strings. <code class="highlighter-rouge">absl::StrCat()</code>
and <code class="highlighter-rouge">absl::StrAppend()</code> are often more efficient than operators such as <code class="highlighter-rouge">+=</code>,
since they don’t require the creation of temporary <code class="highlighter-rouge">std::string</code> objects, and
their memory is preallocated during string construction.</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">// Inefficient code
</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"A string"</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">another</span> <span class="o">=</span> <span class="s">" and another string"</span><span class="p">;</span>
<span class="n">s1</span> <span class="o">+=</span> <span class="s">" and some other string"</span> <span class="o">+</span> <span class="n">another</span><span class="p">;</span>

<span class="c1">// Efficient code
</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"A string"</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">another</span> <span class="o">=</span> <span class="s">" and another string"</span><span class="p">;</span>
<span class="n">absl</span><span class="o">::</span><span class="n">StrAppend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">,</span> <span class="s">" and some other string"</span><span class="p">,</span> <span class="n">another</span><span class="p">);</span>
</code></pre>
</div>

<p>For this reason, you should get in the habit of preferring <code class="highlighter-rouge">absl::StrCat()</code> or
<code class="highlighter-rouge">absl::StrAppend()</code> over using the concatenation operators.</p>

<h3 id="abslstrcat"><code class="highlighter-rouge">absl::StrCat()</code></h3>

<p><code class="highlighter-rouge">absl::StrCat()</code> merges an arbitrary number of strings or numbers into one
string, and is designed to be the fastest possible way to construct a string out
of a mix of raw C strings, <code class="highlighter-rouge">absl::string_view</code> elements, <code class="highlighter-rouge">std::string</code> value,
and boolean and numeric values. <code class="highlighter-rouge">StrCat()</code> is generally more efficient on string
concatenations involving more than one unary operator, such as <code class="highlighter-rouge">a + b + c</code> or <code class="highlighter-rouge">a
+= b + c</code>, since they avoid the creation of temporary string objects during
string construction.</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">// absl::StrCat() can merge an arbitrary number of strings
</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s1</span><span class="p">;</span>
<span class="n">s1</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">StrCat</span><span class="p">(</span><span class="s">"A string "</span><span class="p">,</span> <span class="s">" another string"</span><span class="p">,</span> <span class="s">"yet another string"</span><span class="p">);</span>

<span class="c1">// StrCat() also can mix types, including std::string, string_view, literals,
// and more.
</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s1</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"Foo"</span><span class="p">;</span>
<span class="n">absl</span><span class="o">::</span><span class="n">string_view</span> <span class="n">sv1</span> <span class="o">=</span> <span class="n">MyFunction</span><span class="p">();</span>
<span class="n">s1</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">StrCat</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">sv1</span><span class="p">,</span> <span class="s">"a literal"</span><span class="p">);</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">StrCat()</code> provides automatic formatting for the following types:</p>

<ul>
  <li><code class="highlighter-rouge">std::string</code></li>
  <li><code class="highlighter-rouge">absl::string_view</code></li>
  <li>String literals</li>
  <li>Numeric values (floats, ints)</li>
  <li>Boolean values (convert to “0” or “1”)</li>
  <li>Hex values through use of the <code class="highlighter-rouge">absl::Hex()</code> conversion function</li>
</ul>

<p>Floating point values are converted to a string using the same format used by
STL’s std::basic_ostream::operator«, namely 6 digits of precision, using “e”
format when the magnitude is less than 0.001 or greater than or equal to 1e+6.</p>

<p>You can convert to hexadecimal output rather than decimal output using the
<code class="highlighter-rouge">absl::Hex</code> type. To do so, pass <code class="highlighter-rouge">Hex(my_int)</code> as a parameter to <code class="highlighter-rouge">StrCat()</code> or
<code class="highlighter-rouge">StrAppend()</code>. You may specify a minimum hex field width using an
<code class="highlighter-rouge">absl::PadSpec</code> enum, so the equivalent of <code class="highlighter-rouge">StringPrintf("%04x", my_int)</code> is
<code class="highlighter-rouge">absl::StrCat(absl::Hex(my_int, absl::kZeroPad4))</code>.</p>

<h3 id="abslstrappend"><code class="highlighter-rouge">absl::StrAppend()</code></h3>

<p>For clarity and performance, don’t use <code class="highlighter-rouge">absl::StrCat()</code> when appending to a
string. Use <code class="highlighter-rouge">absl::StrAppend()</code> instead. In particular, avoid using any of these
(anti-)patterns:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">str</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">absl</span><span class="o">::</span><span class="n">StrCat</span><span class="p">(...))</span>
<span class="n">str</span> <span class="o">+=</span> <span class="n">absl</span><span class="o">::</span><span class="n">StrCat</span><span class="p">(...)</span>
<span class="n">str</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">StrCat</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="p">...)</span>
</code></pre>
</div>

<h2 id="abslstrjoin-for-joining-elements-within-a-string"><code class="highlighter-rouge">absl::StrJoin()</code> for Joining Elements within a String</h2>

<p>Although similar to <code class="highlighter-rouge">absl::StrCat()</code> in some similar use cases,
<code class="highlighter-rouge">absl::StrJoin()</code> provides a more robust utility for joining a range of
elements, defining separator strings, and formatting the result as a string.</p>

<p>Ranges are specified by passing a container with <code class="highlighter-rouge">std::begin()</code> and <code class="highlighter-rouge">std::end()</code>
iterators, container-specific <code class="highlighter-rouge">begin()</code> and <code class="highlighter-rouge">end()</code> iterators, a
brace-initialized <code class="highlighter-rouge">std::initializer_list</code>, or a <code class="highlighter-rouge">std::tuple</code> of heterogeneous
objects. The separator string is specified as an <code class="highlighter-rouge">absl::string_view</code>.</p>

<p>Because the default formatter uses the <code class="highlighter-rouge">absl::AlphaNum</code> class,
<code class="highlighter-rouge">absl::StrJoin()</code>, like <code class="highlighter-rouge">absl::StrCat()</code>, will work out-of-the-box on
collections of strings, ints, floats, doubles, etc.</p>

<h3 id="examples">Examples</h3>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">,</span> <span class="s">"baz"</span><span class="p">};</span>
<span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">StrJoin</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s">"-"</span><span class="p">);</span>
<span class="c1">// Produces the string "foo-bar-baz"
</span>
<span class="c1">// Joins the values in the given `std::initializer_list&lt;&gt;` specified using
// brace initialization. This pattern also works with an initializer_list
// of ints or `absl::string_view` -- any `AlphaNum`-compatible type.
</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">StrJoin</span><span class="p">({</span><span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">,</span> <span class="s">"baz"</span><span class="p">},</span> <span class="s">"-"</span><span class="p">);</span>
<span class="c1">// Produces the string "foo-bar-baz"
</span>
<span class="c1">// Joins a collection of ints. This pattern also works with floats,
// doubles, int64s -- any `absl::StrCat()`-compatible type.
</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">};</span>
<span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">StrJoin</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s">"-"</span><span class="p">);</span>
<span class="c1">// Produces the string "1-2-3--4"
</span>
<span class="c1">// Joins a collection of pointer-to-int. By default, pointers are
// dereferenced and the pointee is formatted using the default format for
// that type; such dereferencing occurs for all levels of indirection, so
// this pattern works just as well for `std::vector&lt;int**&gt;` as for
// `std::vector&lt;int*&gt;`.
</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">z</span><span class="p">};</span>
<span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">StrJoin</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s">"-"</span><span class="p">);</span>
<span class="c1">// Produces the string "1-2-3"
</span>
<span class="c1">// Dereferencing of `std::unique_ptr&lt;&gt;` is also supported:
</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">v</span>
<span class="n">v</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="n">v</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
<span class="n">v</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
<span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">StrJoin</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s">"-"</span><span class="p">);</span>
<span class="c1">// Produces the string "1-2-3"
</span>
<span class="c1">// Joins a `std::map`, with each key-value pair separated by an equals
// sign. This pattern would also work with, say, a
// `std::vector&lt;std::pair&lt;&gt;&gt;`.
</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">"a"</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
  <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">"b"</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
  <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">"c"</span><span class="p">,</span> <span class="mi">3</span><span class="p">)};</span>
<span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">StrJoin</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">","</span><span class="p">,</span> <span class="n">strings</span><span class="o">::</span><span class="n">PairFormatter</span><span class="p">(</span><span class="s">"="</span><span class="p">));</span>
<span class="c1">// Produces the string "a=1,b=2,c=3"
</span></code></pre>
</div>

<h3 id="join-formatters">Join Formatters</h3>

<p><code class="highlighter-rouge">absl::StrJoin()</code> uses “Formatters” to format the elements to be joined (and
defaults to an <code class="highlighter-rouge">AlphaNumFormatter()</code> if no formatter is specified. A Formatter
is a function object that is responsible for formatting its argument as a string
and appending it to a given output string. Formatters may be implemented as
function objects, lambdas, or normal functions. You may provide your own
Formatter to enable <code class="highlighter-rouge">absl::StrJoin()</code> to work with arbitrary types.</p>

<p>The following is an example of a custom Formatter that simply uses
<code class="highlighter-rouge">std::to_string()</code> to format an integer as a string:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">MyFormatter</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">string</span><span class="o">*</span> <span class="n">out</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">out</span><span class="o">-&gt;</span><span class="n">append</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre>
</div>

<p>You would use the above formatter by passing an instance of it as the final
argument to <code class="highlighter-rouge">absl::StrJoin()</code>:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
<span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">StrJoin</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s">"-"</span><span class="p">,</span> <span class="n">MyFormatter</span><span class="p">());</span>
<span class="c1">// Produces the string "1-2-3-4"
</span></code></pre>
</div>

<p>The following standard formatters are provided within the <code class="highlighter-rouge">StrJoin()</code> API:</p>

<ul>
  <li><code class="highlighter-rouge">AlphaNumFormatter()</code> (the default)</li>
  <li><code class="highlighter-rouge">StreamFormatter()</code> formats its arguments using the « operator.</li>
  <li><code class="highlighter-rouge">PairFormatter()</code> formats a <code class="highlighter-rouge">std::pair</code> by putting a given separator between
the pair’s <code class="highlighter-rouge">.first</code> and <code class="highlighter-rouge">.second</code> members.</li>
  <li><code class="highlighter-rouge">DereferenceFormatter()</code> formats its argument by dereferencing it and then
applying the given formatter. This formatter is useful for formatting a
container of pointer-to-T. This pattern often shows up when joining repeated
fields in protocol buffers.</li>
</ul>

<h2 id="abslsubstitute-for-string-substitution"><code class="highlighter-rouge">absl::Substitute()</code> for String Substitution</h2>

<p>Formatting strings for display to users typically has different needs.
Traditionally, most C++ code used built-in functions such as <code class="highlighter-rouge">sprintf()</code> and
<code class="highlighter-rouge">snprintf()</code>; these functions have some problems in that they don’t support
<code class="highlighter-rouge">absl::string_view</code> and the memory of the formatted buffer must be managed.</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">// Bad. Need to worry about buffer size and null-terminations.
</span>
<span class="n">string</span> <span class="nf">GetErrorMessage</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">user</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">"Error in %s for user %s (id %i)"</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">buffer</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Better. Using absl::StrCat() avoids the pitfalls of sprintf() and is faster.
</span><span class="n">string</span> <span class="nf">GetErrorMessage</span><span class="p">(</span><span class="n">absl</span><span class="o">::</span><span class="n">string_view</span> <span class="n">op</span><span class="p">,</span> <span class="n">absl</span><span class="o">::</span><span class="n">string_view</span> <span class="n">user</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">absl</span><span class="o">::</span><span class="n">StrCat</span><span class="p">(</span><span class="s">"Error in "</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="s">" for user "</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="s">" ("</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="s">")"</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Best. Using absl::Substitute() is easier to read and to understand.
</span><span class="n">string</span> <span class="nf">GetErrorMessage</span><span class="p">(</span><span class="n">absl</span><span class="o">::</span><span class="n">string_view</span> <span class="n">op</span><span class="p">,</span> <span class="n">absl</span><span class="o">::</span><span class="n">string_view</span> <span class="n">user</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">absl</span><span class="o">::</span><span class="n">Substitute</span><span class="p">(</span><span class="s">"Error in $0 for user $1 ($2)"</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">absl::Substitute()</code> combines the efficiency and type-safe nature of
<code class="highlighter-rouge">absl::StrCat()</code> with the argument-binding of conventional functions like
<code class="highlighter-rouge">sprintf()</code>. <code class="highlighter-rouge">absl::Substitute</code> uses a format string that contains positional
identifiers indicated by a dollar sign ($) and single digit positional ids to
indicate which substitution arguments to use at that location within the format
string.</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">Substitute</span><span class="p">(</span><span class="s">"$1 purchased $0 $2. Thanks $1!"</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="s">"Bob"</span><span class="p">,</span> <span class="s">"Apples"</span><span class="p">);</span>
<span class="c1">// Produces the string "Bob purchased 5 Apples. Thanks Bob!"
</span>
<span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"Hi. "</span><span class="p">;</span>
<span class="n">SubstituteAndAppend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="s">"My name is $0 and I am $1 years old."</span><span class="p">,</span> <span class="s">"Bob"</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
<span class="c1">// Produces the string "Hi. My name is Bob and I am 5 years old."
</span></code></pre>
</div>

<p>Note however, that <code class="highlighter-rouge">absl::Subtitute()</code>, because it requires parsing a format =
string at run-time, is slower than <code class="highlighter-rouge">absl::StrCat()</code>. Choose <code class="highlighter-rouge">Substitute()</code> over
<code class="highlighter-rouge">StrCat()</code> only when code clarity is more important than speed.</p>

<h3 id="differences-from-stringprintf">Differences from <code class="highlighter-rouge">StringPrintf()</code></h3>

<p><code class="highlighter-rouge">absl::Substitute</code> differs from <code class="highlighter-rouge">StringPrintf()</code> in the following ways:</p>

<ul>
  <li>The format string does not identify the types of arguments. Instead, the
arguments are implicitly converted to strings.</li>
  <li>Substitutions in the format string are identified by a ‘$’ followed by a
single digit. You can use arguments out-of-order and use the same argument
multiple times.</li>
  <li>A ‘$$’ sequence in the format string means output a literal ‘$’ character.</li>
  <li><code class="highlighter-rouge">absl::Substitute()</code> is significantly faster than <code class="highlighter-rouge">StringPrintf()</code>. For very
large strings, it may be orders of magnitude faster.</li>
</ul>

<h3 id="supported-types">Supported Types</h3>

<p><code class="highlighter-rouge">absl::Substitute()</code> understands the following types:</p>

<ul>
  <li><code class="highlighter-rouge">absl::string_view</code>, <code class="highlighter-rouge">std::string</code>, <code class="highlighter-rouge">const char*</code> (null is equivalent to “”)</li>
  <li><code class="highlighter-rouge">int32_t</code>, <code class="highlighter-rouge">int64_t</code>, <code class="highlighter-rouge">uint32_t</code>, <code class="highlighter-rouge">uint64_t</code></li>
  <li><code class="highlighter-rouge">float</code>, <code class="highlighter-rouge">double</code></li>
  <li><code class="highlighter-rouge">bool</code> (Printed as “true” or “false”)</li>
  <li>pointer types other than char* (Printed as <code class="highlighter-rouge">0x&lt;lower case hex string&gt;</code>,
except that null is printed as “NULL”)</li>
</ul>

<h2 id="abslstrcontains-for-string-matching"><code class="highlighter-rouge">absl::StrContains()</code> for String Matching</h2>

<p>The Abseil strings library also contains simple utilities for performing string
matching checks. All of their function parameters are specified as
<code class="highlighter-rouge">absl::string_view</code>, meaning that these functions can accept <code class="highlighter-rouge">std::string</code>,
<code class="highlighter-rouge">absl::string_view</code> or nul-terminated C-style strings.</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">// Assume "msg" is a line from a logs entry
</span><span class="k">if</span> <span class="p">(</span><span class="n">absl</span><span class="o">::</span><span class="n">StrContains</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s">"ERROR"</span><span class="p">))</span> <span class="p">{</span>
  <span class="o">*</span><span class="n">has_error</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">absl</span><span class="o">::</span><span class="n">StrContains</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s">"WARNING"</span><span class="p">))</span> <span class="p">{</span>
  <span class="o">*</span><span class="n">has_warning</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Note: The order of parameters in these functions is designed to mimic the order
an equivalent member function would exhibit; e.g. <code class="highlighter-rouge">s.Contains(x)</code> ==&gt;
<code class="highlighter-rouge">absl::StrContains(s, x)</code>.</p>

<h2 id="numericConversion">Converting to and from Numeric Types</h2>

<p>Specialty functions for converting strings to numeric types within the
<code class="highlighter-rouge">absl/strings</code> library are defined within <a href="numbers.h">numbers.h</a>. The following
functions are of particular use:</p>

<ul>
  <li><code class="highlighter-rouge">absl::SimpleAtoi()</code> converts a string into integral types.</li>
  <li><code class="highlighter-rouge">absl::SimpleAtof()</code> converts a string into a float.</li>
  <li><code class="highlighter-rouge">absl::SimpleAtod()</code> converts a string into a double.</li>
  <li><code class="highlighter-rouge">absl::SimpleAtob()</code> converts a string into a boolean.</li>
</ul>

<p>For conversion of numeric types into strings, use <code class="highlighter-rouge">absl::StrCat()</code> and
<code class="highlighter-rouge">absl::StrAppend()</code>. You can use <code class="highlighter-rouge">StrCat/StrAppend</code> to convert <code class="highlighter-rouge">int32</code>,
<code class="highlighter-rouge">uint32</code>, <code class="highlighter-rouge">int64</code>, <code class="highlighter-rouge">uint64</code>, <code class="highlighter-rouge">float</code>, and <code class="highlighter-rouge">double</code> types into strings:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">string</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">StrCat</span><span class="p">(</span><span class="s">"The total is "</span><span class="p">,</span> <span class="n">cost</span> <span class="o">+</span> <span class="n">tax</span> <span class="o">+</span> <span class="n">shipping</span><span class="p">);</span>
</code></pre>
</div>

</div>

<div id="toc" class="toc col-sm-2"></div>
</div>
</div>
</div>




<footer>
    <div class="container">
        <div class="left-links">
            <img src="/img/typography_white.png" style="height:24px;"/>
            <p class="description">&copy;2017 Abseil | Live at Head</p>
        </div>
        <div class="right-links">
            <div class="col-md-4 col-sm-4 col-xs-12 footer-documentation">
                <ul class="toggle">
                    <a href="/about/"><p class="right-link-headers">About Abseil</p></a>
                    <li><a href="/about/intro"><p>Introduction</p></a></li>
                    <li><a href="/about/philosophy"><p>Philosophy</p></a></li>
                    <li><a href="/about/compatibility"><p>Compatibility</p></a></li>
                    <li><a href="/about/design/"><p>Design Notes</p><a></li>
                 </ul>
            </div>
            <hr class="footer-sections" />
            <div class="col-md-3 col-sm-3 col-xs-12 footer-resources">
                <ul class="toggle">
                    <a href="/docs/"><p class="right-link-headers">Dev Guides</p></a>
                    <li><a href="/docs/cpp.html"><p>C++</p></a></li>
                    <li><a href="/blog/"><p>Abseil Blog</p></a></li>
                </ul>
                </ul>
            </div>
            <hr class="footer-sections" />
            <div class="col-md-5 col-sm-5 col-xs-12 footer-community">
                <ul class="toggle">
                    <a href="/community/"><p class="right-link-headers">Community</p></a>
                    <li><a href="https://github.com/abseil/" target="_blank"><p class="github community-links">GitHub</p></a></li>
                    <li><a href="https://twitter.com/abseilio" target="_blank"><p class="twitter community-links">Twitter</p></a></li>
                    <li><a href="http://stackoverflow.com/tags/abseil/" target="_blank"><p class="stack-overflow community-links">Stack Overflow</p></a></li>
                </ul>
            </div>
        </div>
    </div>
</footer>


    <script src="/libs/bootstrap/js/bootstrap.min.js"></script>
    <!-- Include SlickJS for carousel -->
    <script src="/js/slick.min.js"></script>
    <script src="/js/jquery.visible.min.js"></script>
    <!-- Include the common site javascript -->
    <script src="/js/common.js" type="text/javascript" charset="utf-8"></script>
    <!-- GA -->
    <script src="/js/waves.js"></script>
    <script src="/js/buttons.js"></script>
    
    

    
	
	<!-- Global Site Tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-106933809-1"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments)};
	  gtag('js', new Date());

	  gtag('config', 'UA-106933809-1');
	</script>

  </body>
</html>
