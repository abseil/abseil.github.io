<!DOCTYPE html>
<html lang="en" itemscope itemtype="https://schema.org/WebPage">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="title" content="Abseil open-source foundational code">
    <meta name="description" content="Battle-tested, Mom-approved">
    <title>abseil / Synchronization Library</title>

    <!-- Fontawesome Icons -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
    
    <!-- Favicons -->
    <link rel="shortcut icon" type="image/x-icon" href="/favicons/favicon.ico" />
    
    <!-- Bootstrap -->
    <link href="/libs/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Site style using SASS, generated by from style.scss -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Slick styling -->
    <link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/jquery.slick/1.6.0/slick.css"/>
    <link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/jquery.slick/1.6.0/slick-theme.css"/>

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- metadata -->
    <meta name="og:title" content="abseil / Synchronization Library"/>
	 <meta name="og:description" content="An open-source collection of core C++ library code"/>
  </head>
  <body class=>

  	<nav id="sticky-nav">
  <div class="nav-container container">
    <div class="row">
      <div class="col-md-11 nofloat center-block">
        <a class="col-xs-2" href="/">
          <img class="nav-logo" src="/img/absl_18px.svg" alt="Abseil">
        </a>

        <div class="col-xs-2 col-xs-offset-8">
          <button type="button" class="hamburger navbar-toggle collapsed" data-target="#navbar-collapse-1">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
        </div>

        <ul class="nav col-xs-10">
          
          <li><a href="/about" >About</a></li>
          <li><a href="/docs/" class='current'>Docs</a></li>
		  <li><a href="/tips/" >Tips</a></li>
          <li><a href="/blog/" >Blog</a></li>
          <li><a href="/community/" >Community</a></li>
        </ul>

      </div>
    </div>
  </div>

  <div class="top-nav right">
    
    <li class="nav-item"><a href="/"><p>Home</p></a><div class="nav-toggle icon-close"></div></li>
    <hr>
    <li class="nav-item"><a href="/about" ><p>About</p></a></li>
    <hr>
    <li class="nav-item"><a href="/docs/" class='current'><p>Docs</p></a>
      <div class="nav-doc-toggle icon-caret"></div>
      <ul class="doc-list">
        <a href="/docs/cpp" ><li class="nav-doc-tab">C++ Devguide</li></a>
        <a href="/docs/cpp/quickstart" ><li class="nav-doc-tab">C++ Quick Start</li></a>
      </ul>
    </li>
    <hr>
    <li class="nav-item"><a href="/tips/" ><p>Tips</p></a></li>
    <hr>
    <li class="nav-item"><a href="/blog/" ><p>Blog</p></a></li>
    <hr>
    <li class="nav-item"><a href="/community/" ><p>Community</p></a></li>
  </div>
</nav>


<div class="nav-hero-container">
	<nav id="common-nav">
  <div class="nav-container container">
    <div class="row">
      <div class="col-md-11 nofloat center-block">
        <a class="col-xs-2" href="/">
          <img class="nav-logo" src="/img/absl_80px.png" alt="Abseil">
        </a>

        <div class="col-xs-2 col-xs-offset-8">
          <button type="button" class="hamburger navbar-toggle collapsed" data-target="#navbar-collapse-1">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
        </div>

        <ul class="nav col-xs-10">
          
          <li><a href="/about" >About</a></li>
          <li><a href="/docs/" class='current'>Docs</a></li>
          <li><a href="/tips/" >C++ Tips</a></li>
		  <li><a href="/blog/" >Blog</a></li>
          <li><a href="/community" >Community</a></li>
        </ul>

      </div>
    </div>
  </div>

  <div class="top-nav right">
    
    <li class="nav-item"><a href="/"><p>Home</p></a><div class="nav-toggle icon-close"></div></li>
    <hr>
    <li class="nav-item"><a href="/about/" ><p>About</p></a></li>
    <hr>
    <li class="nav-item"><a href="/docs/" class='current'><p>Docs</p></a>
      <div class="nav-doc-toggle icon-caret"></div>
      <ul class="doc-list">
        <a href="/docs/cpp/quickstart" ><li class="nav-doc-tab">Quickstart</li></a>
      </ul>
    </li>
    <hr>
    <li class="nav-item"><a href="/blog/" ><p>Blog</p></a></li>
    <hr>
    <li class="nav-item"><a href="/tips/" ><p>Tips</p></a></li>
    <hr>
    <li class="nav-item"><a href="/community/" ><p>Community</p></a></li>
  </div>
  <div class="container">
    <div class="row">
      <div class="col-md-11 nofloat center-block">
        <div class="col-xs-12">
          <h1 class="page-headline"></h1> 
        </div>
      </div>
    </div>
  </div>

</nav>

   <a href="https://github.com/abseil/" class="fork-btn" target="_blank"></a>

</div>



<div class="container">
<div class="row">
<div class="col-md-11 nofloat center-block ">
<div class="col-sm-3">
<ul class="doc-side-nav">
	
	<li><h5 class="doc-side-nav-title"><a href="/docs/">Docs</a></h5></li>
	<li><h5 class="doc-side-nav-title">
	<a href="/docs/cpp.html" class='current'><b>C++ Devguide</b></a></h5></li>
	<li class="doc-side-nav-list-item">
	  <a href="/docs/cpp/quickstart" >
	  Quickstart</a></li>
	  
	<li><h6 class="doc-side-nav-title">
	  <a href="/docs/cpp/guides/" class='current'>
	Programming Guides</a></h6></li>
	
   <li class="doc-side-nav-list-item">
     <a href="/docs/cpp/guides/base" >
     Abseil Fundamentals</a></li>
   <li class="doc-side-nav-list-item">
     <a href="/docs/cpp/guides/synchronization" class='current'>
     Synchronization</a></li>
   <li class="doc-side-nav-list-item">
     <a href="/docs/cpp/guides/strings" >
     Strings</a></li>
	 
  <li><h6 class="doc-side-nav-title">
  <a href="/docs/cpp/platforms/" >
   Platforms Guide</a></h6></li>
   
   <li class="doc-side-nav-list-item">
	<a href="/docs/cpp/platforms/platforms" >
	Supported Platforms</a></li>
	<li class="doc-side-nav-list-item">
	<a href="/docs/cpp/platforms/feature_checks" >
	Feature Check Macros</a></li>
 </ul>

</div>
<div class="col-sm-7 markdown">
<p>The Synchronization library includes abstractions and primitives for managing
tasks across different threads. This library encompasses the following
header files:</p>

<ul>
  <li><code class="highlighter-rouge">mutex.h</code><br />
Provides primitives for managing locks on resources. A mutex is the most
important primitive in this library and the building block for most all
concurrency utilities.</li>
  <li><code class="highlighter-rouge">notification.h</code><br />
Provides a simple mechanism for notifying threads of events.</li>
  <li><code class="highlighter-rouge">barrier.h</code> and <code class="highlighter-rouge">blocking_counter.h</code><br />
Provides synchronization abstractions for cumulative events.</li>
</ul>

<p>The Abseil <code class="highlighter-rouge">base</code> library also includes a number of concurrency-related header
files:</p>

<ul>
  <li><code class="highlighter-rouge">base/thread_annotations.h</code><br />
Provides macros for documenting the locking policy of multi-threaded code, and
providing warnings and errors for misuse of such locks.</li>
  <li><code class="highlighter-rouge">base/call_once.h</code><br />
Provides an Abseil version of <code class="highlighter-rouge">std::call_once()</code> for invoking a callable
object exactly once across all threads.</li>
</ul>

<p>This document will cover all of the above.</p>

<h2 id="synchronization-overview">Synchronization Overview</h2>

<p>In sequential (i.e. single-threaded) systems, we usually think of events as
happening in a specific total order: for any operations A and B, either A
happens before B, or B happens before A. In concurrent systems, this is no
longer the case: for some pairs of operations it may not be possible to say
which one happens earlier (i.e. events are only partially ordered), in which
case we say that they happen <em>concurrently</em>. Notice that this definition has
nothing to do with whether they “actually” happen simultaneously, but only with
whether we can <em>guarantee</em> that they won’t.</p>

<p>Concurrent operations may conflict if they are not used (or designed) properly
within a multi-threaded environment, resulting in the following problems:</p>

<ul>
  <li>Operations may require write access to shared resources. We call these issues
<em>memory access</em> issues.</li>
  <li>Operations may need to occur in a specific order. We sometimes call these
issues <em>synchronization</em> issues (although memory access issues are also
synchronization issues).</li>
</ul>

<p>In either case, lack of control on the shared resources or lack of control on
the operation order can lead to <em>race conditions</em>. The purpose of the
concurrency abstractions within this library is to address these issues and
avoid such race conditions.</p>

<h3 id="memory-access-issues">Memory Access Issues</h3>

<p>Memory access issues are often addressed through a variety of means, including:</p>

<ul>
  <li>Making the shared resource private or read-only (for data where this is
appropriate)</li>
  <li>Converting the data access into a “message passing” scheme, to provide
copies of the shared information for temporary use rather than direct
access to the memory.</li>
  <li>Locking access to the shared resource, typically for write operations, to
prevent more than one user from reading or writing concurrently.</li>
  <li>Using atomic operations to access to the shared resource, such as those
provided by <code class="highlighter-rouge">std::atomic</code>. Note that the rules for properly applying atomic
operations are quite complicated, which is one of many reasons you should
avoid atomics.</li>
</ul>

<p>Locking access to shared resources is usually addressed through
mutually-exclusive locks known as <em>mutexes</em>. Abseil provides its own <code class="highlighter-rouge">Mutex</code>
class for this purpose; similarly, the C++ standard library provides a
<code class="highlighter-rouge">std::mutex</code> class for the same purpose. (Reasons why we implement our own
<code class="highlighter-rouge">Mutex</code> class are discussed in <a href="/about/design/mutex">Mutex Design Notes</a>.)</p>

<p>Types that behave correctly regardless of the order, scheduling,
or interleaving of their operations are known as <em>thread-safe</em>. In most cases,
such types use mutexes and atomic operations underneath the hood
to guard access to the object’s internal state.</p>

<p>See <a href="#mutexes">Mutexes</a> below for more information.</p>

<h3 id="synchronization-operations">Synchronization Operations</h3>

<p>Synchronization issues other than simple memory access issues are often more
complex and require abstractions specifically built to address the underlying
problem, (again, often through mutexes and atomic operations, which are quite
tricky to implement properly). Synchronization operations are designed to
control the order of events in different threads.</p>

<p>Keep in mind that operations on “thread-safe” types aren’t necessarily
synchronization operations. When you read a value that another thread wrote, you
can’t assume that the write happens before the read; they may happen
concurrently.</p>

<p>For example:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">foo</span><span class="o">::</span><span class="n">counter</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">thread1</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">first</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>    <span class="c1">// (a)
</span>  <span class="n">second</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>   <span class="c1">// (b)
</span><span class="p">}</span>

<span class="kt">void</span> <span class="nf">thread2</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">second</span><span class="p">.</span><span class="n">value</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">CHECK</span><span class="p">(</span><span class="n">first</span><span class="p">.</span><span class="n">value</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>   <span class="c1">// ERROR
</span><span class="p">}</span>
</code></pre>
</div>

<p>Even if foo::counter were thread-safe (and you wouldn’t need to worry about data
races), you might think that the <code class="highlighter-rouge">CHECK()</code> will succeed, because line (a)
happens before line (b), and the <code class="highlighter-rouge">CHECK()</code> can’t be reached until line (b) has
executed. However, unless <code class="highlighter-rouge">Add()</code> and <code class="highlighter-rouge">value()</code> are also synchronization
operations, none of the operations in thread1 need necessarily happen before any
of the operations in thread2, and that <code class="highlighter-rouge">CHECK()</code> may fail.</p>

<p>Abseil provides several synchronization abstractions. See
<a href="#other-synchronization-operations">Synchronization Operations</a> for more 
information.</p>

<h2 id="mutexes">Mutexes</h2>

<p>The major primitive for use within concurrency tasks is a mutex, which is a
<em>mut</em>ually <em>ex</em>clusive lock that can be used to prevent multiple threads from
accessing and/or writing to a shared resource.</p>

<h3 id="abslmutex-and-stdmutex"><code class="highlighter-rouge">absl::Mutex</code> and <code class="highlighter-rouge">std::mutex</code></h3>

<p>Abseil provides its own <code class="highlighter-rouge">Mutex</code> class, and within Google, we use this class
instead of the similar <code class="highlighter-rouge">std::mutex</code>. <code class="highlighter-rouge">Mutex</code> provides most of the functionality
of <code class="highlighter-rouge">std::mutex</code> but adds the following additional features:</p>

<ul>
  <li><code class="highlighter-rouge">absl::Mutex</code> adds <em>conditional critical sections</em>, an alternative to
condition variables. <code class="highlighter-rouge">Mutex::Await()</code> and <code class="highlighter-rouge">Mutex::LockWhen()</code> allow the client
to wait for a condition without needing a condition variable; the client need
not write the while-loop, nor need they use <code class="highlighter-rouge">Signal()</code>. (See
<a href="#conditional-critical-sections">Condition</a> below.)</li>
  <li><code class="highlighter-rouge">Mutex</code>  intrinsically supports deadlock detection (when locks are not
acquired in a consistent order). The deadlock detector is enabled by default
in most non-opt build modes, and it can detect deadlock risks that even Clang’s
<a href="https://clang.llvm.org/docs/ThreadSanitizer.html">Thread Sanitizer</a> misses.
(See <a href="#Deadlock-detection">Deadlock Detection</a> below.)</li>
</ul>

<p>Additionally, <code class="highlighter-rouge">absl::Mutex</code> can act as a reader-writer lock (like
<code class="highlighter-rouge">std::shared_mutex</code>) with special <code class="highlighter-rouge">ReaderLock()</code> and <code class="highlighter-rouge">ReaderUnlock()</code> functions.
(See <a href="#reader-writer-locks">Reader-Writer Locks</a> below.)</p>

<p>We’ve found these features to be critically important for maintaining a large
and complex code base. We are not necessarily intending to compete with
<code class="highlighter-rouge">std::mutex</code> itself; if you find the features usable within your code base,
consider <code class="highlighter-rouge">absl::Mutex</code> and its utilities.</p>

<p>Like <code class="highlighter-rouge">std::mutex</code>, Abseil’s Mutex is not re-entrant (also known as
non-recursive). As well, it does not provide strict FIFO behaviour or fairness
in the short term; to do so would require significant overhead. However, it
tends to be approximately fair in the long term.</p>

<h3 id="mutex-basics">Mutex Basics</h3>

<p>The <code class="highlighter-rouge">absl::Mutex</code> class implements a mutually exclusive lock on on some
resource, allowing threads which also use the mutex to avoid concurrent access
to that resource, which is typically some variable or data structure with
associated invariants. For example, a financial transaction system may wish only
one writer to access certain data elements at one time. Mutexes are so common
that many words have been coined to describe their operation.</p>

<p>Each <code class="highlighter-rouge">Mutex</code> has two basic operations: <code class="highlighter-rouge">Mutex::Lock()</code> and <code class="highlighter-rouge">Mutex::Unlock()</code>.
Conceptually, it has just a single bit of abstract state: a boolean indicating
it is <code class="highlighter-rouge">true</code> (locked) or <code class="highlighter-rouge">false</code> (unlocked). When a <code class="highlighter-rouge">Mutex</code> is created, this
lock is initially <code class="highlighter-rouge">false</code> and the mutex is said to be <em>free</em> or <em>unlocked</em>.
<code class="highlighter-rouge">Lock()</code> blocks the caller until some moment when the mutex is free, and then
atomically changes this mutex state from <code class="highlighter-rouge">false</code> to <code class="highlighter-rouge">true</code>; the mutex is then
said to be <em>held</em> or <em>locked</em> by the caller. <code class="highlighter-rouge">Unlock()</code> sets this mutex state to
<code class="highlighter-rouge">false</code> once more.</p>

<p>Calling <code class="highlighter-rouge">Lock()</code> is often referred to as <em>locking</em> or <em>acquiring</em> a mutex, while
calling <code class="highlighter-rouge">Unlock()</code> is referred to as <em>unlocking</em> or <em>releasing</em> a mutex. An
action performed by a thread while holding a mutex is said to be performed
<em>under</em> the mutex. Data structures manipulated under the mutex, and their
invariants, are said to be <em>protected by</em> the mutex.</p>

<p>Clients of <code class="highlighter-rouge">Mutex</code> must obey these rules:</p>

<ol>
  <li>Each time a thread acquires a <code class="highlighter-rouge">Mutex</code> it must later release it.</li>
  <li>A thread may not attempt to release a <code class="highlighter-rouge">Mutex</code> unless it holds it.</li>
  <li>A thread may not attempt to acquire an exclusive lock on a <code class="highlighter-rouge">Mutex</code> it
already holds.</li>
</ol>

<p>Because <code class="highlighter-rouge">Lock()</code> acts atomically to change the state of the state of the mutex,
we are guaranteed that, if these rules are followed, only one thread may hold a
mutex at any given time.</p>

<p>These rules must be followed both to prevent concurrent access to the protected
resource and avoid <em>deadlock</em>, in which a thread blocks waiting for a lock to be
released. The last rule prevents <em>self-deadlock</em>, when a holder of a mutex
attempts to acquire a mutex it already holds. Such mutexes are known as
non-recursive (or non-reentrant) mutexes.</p>

<p>These rules are best followed by bracketing regions of code with
matching calls to <code class="highlighter-rouge">Lock()</code> and <code class="highlighter-rouge">Unlock()</code> a mutex in the same procedure.
Such sections of code are called <em>critical regions</em>. Much Google C++ code uses
the helper class <code class="highlighter-rouge">MutexLock</code>, which through RAII automatically acquires a mutex
on construction and releases it when the lock goes out of scope.</p>

<h3 id="mutexes-and-invariants">Mutexes and Invariants</h3>

<p>Most mutexes are used to ensure some invariant state can only be changed
atomically while the mutex is held. The programmer is required to re-establish
the invariant before releasing the mutex; code can then assume the invariant
holds whenever acquiring the mutex, even in the face of updates that
<em>temporarily</em> invalidate the invariant during the critical section. However, one
cannot guarantee the invariant is true in a thread that does not hold the mutex,
because the mutex holder may be changing the monitored state at that moment.</p>

<p>For example, suppose <code class="highlighter-rouge">Mutex mu</code> protects the invariant that <code class="highlighter-rouge">a + b == 0</code>. This
code is then legal:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">mu</span><span class="p">.</span><span class="n">Lock</span><span class="p">();</span>
<span class="n">assert</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// invariant assumed to hold
</span><span class="n">a</span><span class="o">++</span><span class="p">;</span>                <span class="c1">// invariant temporarily invalidated
</span><span class="n">b</span><span class="o">--</span><span class="p">;</span>                <span class="c1">// invariant restored before mu is released
</span><span class="n">mu</span><span class="p">.</span><span class="n">Unlock</span><span class="p">();</span>
</code></pre>
</div>

<p>while this code is erroneous:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">mu</span><span class="p">.</span><span class="n">Lock</span><span class="p">();</span>
<span class="n">assert</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// invariant assumed to hold
</span><span class="n">a</span><span class="o">++</span><span class="p">;</span>                <span class="c1">// invariant invalidated
</span><span class="n">mu</span><span class="p">.</span><span class="n">Unlock</span><span class="p">();</span>        <span class="c1">// BUG: mutex released while invariant invalid
</span><span class="n">mu</span><span class="p">.</span><span class="n">Lock</span><span class="p">();</span>
<span class="n">b</span><span class="o">--</span><span class="p">;</span>                <span class="c1">// attempt to restore the invariant,
</span>                    <span class="c1">// but the damage is already done
</span><span class="n">mu</span><span class="p">.</span><span class="n">Unlock</span><span class="p">();</span>
</code></pre>
</div>

<p>The following does not invalidate the invariant, but incorrectly assumes
it is true when the lock is not held:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">mu</span><span class="p">.</span><span class="n">Lock</span><span class="p">();</span>
<span class="n">assert</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// correct: invariant assumed to hold
</span><span class="n">mu</span><span class="p">.</span><span class="n">Unlock</span><span class="p">();</span>
<span class="n">assert</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// BUG: can't assume invariant without lock
</span></code></pre>
</div>

<p>The invariant holds only when evaluated on state observed within a single
critical section:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">mu</span><span class="p">.</span><span class="n">Lock</span><span class="p">();</span>
<span class="n">assert</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>    <span class="c1">// correct: invariant assumed to hold
</span><span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>              <span class="c1">// takes a temporary copy of "a"
</span><span class="n">mu</span><span class="p">.</span><span class="n">Unlock</span><span class="p">();</span>
<span class="n">mu</span><span class="p">.</span><span class="n">Lock</span><span class="p">();</span>
<span class="n">assert</span><span class="p">(</span><span class="n">temp</span> <span class="o">+</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// BUG: can't assume invariant on state
</span>                       <span class="c1">// from two distinct critical sections
</span><span class="n">mu</span><span class="p">.</span><span class="n">Unlock</span><span class="p">();</span>
</code></pre>
</div>

<h3 id="the-mutexlock-wrapper">The <code class="highlighter-rouge">MutexLock</code> Wrapper</h3>

<p>Forgetting to acquire and release locks on a <code class="highlighter-rouge">Mutex</code> often leads to errors in
your code. The Abseil concurrency library includes a <code class="highlighter-rouge">MutexLock</code> wrapper class
to make acquiring and releasing a <code class="highlighter-rouge">Mutex</code> easier. The class uses RAII to
acquire the mutex and automatically releases it when the class goes out of
scope.</p>

<p>Example:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Class</span> <span class="n">Foo</span> <span class="p">{</span>

  <span class="n">Foo</span><span class="o">::</span><span class="n">Bar</span><span class="o">*</span> <span class="n">Baz</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">MutexLock</span> <span class="n">l</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock_</span><span class="p">);</span>
    <span class="p">...</span>
    <span class="k">return</span> <span class="n">bar</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">private</span><span class="o">:</span>
    <span class="n">Mutex</span> <span class="n">lock_</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="conditional-mutex-behavior">Conditional Mutex Behavior</h3>

<p>An Abseil <code class="highlighter-rouge">Mutex</code> can be configured to block threads until a certain condition
occurs. Such conditional behavior is accomplished in two ways: a traditional
<em>conditional variable</em> <code class="highlighter-rouge">CondVar</code> (similar to the <code class="highlighter-rouge">std::condition_variable</code>
available to <code class="highlighter-rouge">std::mutex</code>) or through a mechanism unique to Abseil’s mutex:
<em>conditional critical sections</em>, using a <code class="highlighter-rouge">Mutex::Condition</code>.</p>

<p>Conditional Critical Sections (using the <code class="highlighter-rouge">Condition</code> construction) are generally
preferred as use of separate condition variables has proven to be error prone.
The <code class="highlighter-rouge">Mutex</code> contains a number of member functions (e.g. <code class="highlighter-rouge">Mutex::Await()</code>) that
are hard to get wrong. Generally, prefer use of <code class="highlighter-rouge">Condition</code>; in rare cases, when
there are multiple threads waiting on distinctly different conditions, however,
a battery of <code class="highlighter-rouge">CondVar</code>s may be more efficient.</p>

<h4 id="conditional-critical-sections">Conditional Critical Sections</h4>

<p>Abseil’s <code class="highlighter-rouge">Mutex</code> has been extended through the addition of <em>conditional critical
sections</em>, an alternative to condition variables. Member functions such as
<code class="highlighter-rouge">Mutex::Await()</code> and <code class="highlighter-rouge">Mutex::LockWhen()</code> use intrinsic <code class="highlighter-rouge">Condition</code> predicates
to allow a client to wait for a condition without needing a condition variable;
the client need not write the while-loop, nor need they use <code class="highlighter-rouge">Signal()</code>.</p>

<p>Clients can imagine that a mutex contains an imaginary condition variable
<code class="highlighter-rouge">mu.cv</code>; with that assumption, these corresponding code fragments on the left
and right are equivalent:</p>

<table width="100%">
  <tbody>
    <tr>
      <th>Conditional critical sections</th>
      <th>Condition variables</th>
    </tr>
    <tr>
      <td width="50%">
<pre>
mu.Lock();
... // arbitrary code A
mu.Await(Condition(f, arg));


... // arbitrary code B
mu.Unlock();

mu.LockWhen(Condition(f, arg));



... // arbitrary code C
mu.Unlock();</pre>
 </td>
      <td width="50%">
<pre>
mu.Lock();
... // arbitrary code A
while (!f(arg)) {
  mu.cv.Wait(&amp;mu);
}
... // arbitrary code B
mu.Unlock();

mu.Lock();
while (!f(arg)) {
  mu.cv.Wait(&amp;mu);
}
... // arbitrary code C
 mu.Unlock();</pre>
 </td>
    </tr>
  </tbody>
</table>

<p>When <code class="highlighter-rouge">LockWhen()</code> and <code class="highlighter-rouge">Await()</code> are used, the condition must be encapsulated in
a function (<code class="highlighter-rouge">f</code> in the examples) with a <code class="highlighter-rouge">void *</code> argument (or by a lambda). As
with condition variables, the condition must be a function of state protected by
the mutex. The minor inconvenience of requiring a function is rewarded by
eliminating the need for the condition variable and the while-loop, which are
now hidden inside the <code class="highlighter-rouge">Mutex</code> implementation.</p>

<p>Even better, <code class="highlighter-rouge">Mutex::Unlock()</code> will take care of calling <code class="highlighter-rouge">Signal</code> or
<code class="highlighter-rouge">SignalAll()</code> to wake waiters whose conditions are now true; its performance is
usually as good as or better than that achieved with a condition variable. Thus,
the example of the previous subsection could be written as:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">f</span><span class="p">(</span><span class="kt">bool</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">arg</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// Waiter
</span><span class="n">mu</span><span class="p">.</span><span class="n">LockWhen</span><span class="p">(</span><span class="n">Condition</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cond_expr</span><span class="p">));</span>
<span class="c1">// cond_expr now holds
</span><span class="p">...</span>
<span class="n">mu</span><span class="p">.</span><span class="n">Unlock</span><span class="p">();</span>

<span class="c1">// Waker
</span><span class="n">mu</span><span class="p">.</span><span class="n">Lock</span><span class="p">();</span>
<span class="n">Make_cond_expr_True</span><span class="p">();</span>
<span class="c1">// cond_expr now holds
</span><span class="n">mu</span><span class="p">.</span><span class="n">Unlock</span><span class="p">();</span>
</code></pre>
</div>

<p>In rare cases, when many threads may be waiting with many different and
usually-false conditions, it may be better to use multiple condition variables.
In general, we recommend conditional critical sections for simplicity.</p>

<p>The call <code class="highlighter-rouge">mu.LockWhen(Condition(f, arg))</code> is equivalent to
<code class="highlighter-rouge">mu.Lock(); mu.Await(Condition(f, arg))</code>.  Similarly, the call
<code class="highlighter-rouge">mu.Await(Condition(f, arg))</code> is equivalent to
<code class="highlighter-rouge">mu.Unlock(); mu.LockWhen(Condition(f, arg))</code>.</p>

<p>The variants <code class="highlighter-rouge">LockWhenWithTimeout()</code> and <code class="highlighter-rouge">AwaitWithTimeout()</code> allow a thread to
wait either for a condition to become true or for some time to elapse. They each
return <code class="highlighter-rouge">true</code> iff the condition is true:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">mu</span><span class="p">.</span><span class="n">LockWhenWithTimeout</span><span class="p">(</span><span class="n">Condition</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cond_expr</span><span class="p">),</span> <span class="mi">1000</span> <span class="cm">/*ms*/</span><span class="p">))</span> <span class="p">{</span>
  <span class="c1">// mu held; cond_expr true
</span><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="c1">// mu held; cond_expr false; 1000ms timeout expired
</span><span class="p">}</span>
<span class="n">mu</span><span class="p">.</span><span class="n">Unlock</span><span class="p">();</span>
</code></pre>
</div>

<p>These calls are analogous to <code class="highlighter-rouge">cv.WaitWithTimeout()</code>.</p>

<h4 id="condvar-condition-variables"><code class="highlighter-rouge">CondVar</code> Condition Variables</h4>

<p>Condition variables serve the same purpose as conditional critical sections;
they are a means for blocking a thread until some condition has been satisfied.
Usually, conditional critical sections are easier to use, but condition
variables may be more familiar to programmers because they are included in the
POSIX standard and Java language.</p>

<p>Viewed in isolation, a condition variable allows threads to block and to be
woken by other threads. However, condition variables are designed to be used in
a specific way; a condition variable interacts with a mutex to make it easy to
wait for an arbitrary condition on state protected by the mutex.</p>

<p>Suppose that a thread is to wait for some boolean expression <code class="highlighter-rouge">cond_expr</code> to
become <code class="highlighter-rouge">true</code>, where the state associated with <code class="highlighter-rouge">cond_expr</code> is protected by a
mutex <code class="highlighter-rouge">mu</code>. The programmer would write:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">// Waiter
</span><span class="n">mu</span><span class="p">.</span><span class="n">Lock</span><span class="p">();</span>
<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">cond_expr</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cv</span><span class="p">.</span><span class="n">Wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mu</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// cond_expr now holds
</span><span class="p">...</span>
<span class="n">mu</span><span class="p">.</span><span class="n">Unlock</span><span class="p">();</span>
</code></pre>
</div>

<p>The <code class="highlighter-rouge">Wait()</code> call atomically unlocks <code class="highlighter-rouge">mu</code> (which the thread must hold), and
blocks on the condition variable <code class="highlighter-rouge">cv</code>. When another thread signals the condition
variable, the thread will reacquire the <code class="highlighter-rouge">mu</code>, and go around the mandatory
while-loop to recheck <code class="highlighter-rouge">cond_expr</code>.</p>

<p>Another thread that makes cond_expr true might execute:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">// Waker
</span><span class="n">mu</span><span class="p">.</span><span class="n">Lock</span><span class="p">();</span>
<span class="n">Make_cond_expr_True</span><span class="p">();</span>
<span class="c1">// cond_expr now holds
</span><span class="n">cv</span><span class="p">.</span><span class="n">Signal</span><span class="p">();</span>
<span class="n">mu</span><span class="p">.</span><span class="n">Unlock</span><span class="p">();</span>
</code></pre>
</div>

<p>The call to <code class="highlighter-rouge">Signal()</code> wakes at least one of the threads waiting on <code class="highlighter-rouge">cv</code>. Many
threads may be blocked on a condition variable at any given time; if it makes
sense to wake more than one such thread <code class="highlighter-rouge">SignalAll()</code> can be used. (The
<code class="highlighter-rouge">SignalAll()</code> functionality is often referred to as broadcast in other
implementations.)</p>

<p>A single condition variable can be used by threads waiting for different
conditions. However, in this case, <code class="highlighter-rouge">SignalAll()</code> must be used when any of the
conditions becomes <code class="highlighter-rouge">true</code>, because the <code class="highlighter-rouge">CondVar</code> implementation cannot otherwise
guarantee to wake the correct thread. It can be more efficient to use one
condition variable for each different condition; any number of condition
variables can be used with a single mutex.</p>

<p>Both <code class="highlighter-rouge">Signal()</code> and <code class="highlighter-rouge">SignalAll()</code> are efficient if there are no threads to wake.
Clients should call <code class="highlighter-rouge">Signal()</code> or <code class="highlighter-rouge">SignalAll()</code> inside the critical section that
makes the condition true.</p>

<p>The call <code class="highlighter-rouge">WaitWithTimeout()</code> allows a thread to wait until either a condition is
<code class="highlighter-rouge">true</code>, or until some time has elapsed. Like <code class="highlighter-rouge">Wait()</code>, <code class="highlighter-rouge">WaitWithTimeout()</code>
always reacquires the mutex before returning.</p>

<p>Example:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">static</span> <span class="k">const</span> <span class="n">int64</span> <span class="n">kMSToWait</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>  <span class="c1">// we'll wait at most 1000ms
</span><span class="n">int64</span> <span class="n">ms_left_to_wait</span> <span class="o">=</span> <span class="n">kMSToWait</span><span class="p">;</span>    <span class="c1">// ms to wait at any given time
</span><span class="n">int64</span> <span class="n">deadline_ms</span> <span class="o">=</span> <span class="n">GetCurrentTimeMillis</span><span class="p">()</span> <span class="o">+</span> <span class="n">ms_left_to_wait</span><span class="p">;</span>
<span class="n">mu</span><span class="p">.</span><span class="n">Lock</span><span class="p">();</span>
<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">cond_expr</span> <span class="o">&amp;&amp;</span> <span class="n">ms_left_to_wait</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cv</span><span class="p">.</span><span class="n">WaitWithTimeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mu</span><span class="p">,</span> <span class="n">ms_left_to_wait</span><span class="p">);</span>
  <span class="n">ms_left_to_wait</span> <span class="o">=</span> <span class="n">deadline_ms</span> <span class="o">-</span> <span class="n">GetCurrentTimeMillis</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">cond_expr</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// cond_expr true
</span><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="c1">// cond_expr false; 1000ms timeout expired
</span><span class="p">}</span>
<span class="n">mu</span><span class="p">.</span><span class="n">Unlock</span><span class="p">();</span>
</code></pre>
</div>

<h3 id="reader-writer-locks">Reader-Writer Locks</h3>

<p>A reader-writer (shared-exclusive) lock has two locking modes. If the lock is
not free, it may be held either in write (a.k.a. exclusive) mode by a single
thread, or in read (a.k.a. shared) mode by one or more threads.</p>

<p>It is natural to use a reader-writer lock to protect a resource or data
structure that is read often, but modified infrequently. Critical sections that
modify the protected state must acquire the lock in write mode, while those that
merely read the state may acquire the lock in read mode.</p>

<p>Note: reader-writer locks can reduce lock contention in some situations, but
most locks are not contended enough for this to make a difference. When you use
shared locks, the onus is on you to ensure that the code in reader critical
sections really doesn’t mutate the data (logically or physically), and any
mistakes here can lead to subtle race conditions.</p>

<p>Any <code class="highlighter-rouge">Mutex</code> can be used as a reader-writer lock.  The <code class="highlighter-rouge">Lock()</code> call acquires the
lock in write mode and must be paired with a call to <code class="highlighter-rouge">Unlock()</code>. The
<code class="highlighter-rouge">ReaderLock()</code> call acquires the lock in read mode and must be paired with a
call to <code class="highlighter-rouge">ReaderUnlock()</code>. <code class="highlighter-rouge">absl::Mutex</code> does not provide operations to convert
from a read lock to a write lock or vice versa without first releasing the lock.</p>

<p>Both condition variables and <code class="highlighter-rouge">mu.Await()</code> may be used with <code class="highlighter-rouge">Mutex</code> read-mode
critical sections as well as with write-mode critical sections.</p>

<p><code class="highlighter-rouge">Mutex</code> does not allow readers to starve writers or vice versa. This leads to
the slightly surprising effect that a request for a read lock may block even if
the lock is already held by a reader. If this could not happen, a waiting writer
could be prevented ever from making progress by two or more readers that kept
the lock permanently in read mode, without any one holding the lock
indefinitely.</p>

<p>Beware that future maintainers may add mutations to “reader” critical sections
accidentally, thus introducing errors.  For example, self-optimizing data
structures such as splay trees or LRU caches may modify the data structure on
every read.  Even simple data structures may keep track of usage statistics.
Therefore, reader locks should be used with care, and their use should be easy
for developers to recognize. It can help to forbid modifications using a pointer
to a <code class="highlighter-rouge">const</code> data structure, though care must be still be exercised because of
C++’s <code class="highlighter-rouge">mutable</code> keyword.</p>

<p>We recommend using <code class="highlighter-rouge">Mutex</code> as a simple mutex initially; introduce reader locks
only when you know you have lock contention and you know that writes are
infrequent.</p>

<h3 id="thread-annotations">Thread Annotations</h3>

<p>The major drawbacks of <code class="highlighter-rouge">absl::Mutex</code> are drawbacks of any mutex type: you have
to remember to lock it before entering a critical section, you have to remember
to unlock it when you leave, and you have to avoid deadlock.</p>

<p>To help solve these problems, Abseil provides thread-safety annotations (in
<code class="highlighter-rouge">base/thread_annotations.h</code>) to specify which variables are guarded by which
mutexes, which mutexes should be held when calling which functions, what order
mutexes should be acquired in, and so forth. These constraints are then checked
at compile time, and although this mechanism is not foolproof, it does catch
many common <code class="highlighter-rouge">Mutex</code> usage errors. Besides being part of the code documentation,
annotations can also be used by the compiler or analysis tools to identify and
warn about potential thread safety issues.</p>

<h4 id="annotation-guidelines">Annotation Guidelines</h4>

<p>Every data object (whether a global variable in namespace scope or a data member
in class scope) which requires protection from a mutex should have an annotation
<code class="highlighter-rouge">GUARDED_BY</code> indicating which mutex protects it:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">accesses_</span> <span class="n">GUARDED_BY</span><span class="p">(</span><span class="n">mu_</span><span class="p">);</span> <span class="c1">// count of accesses
</span></code></pre>
</div>

<p>Every mutex should have a complementary comment indicating which variables and
also any non-obvious invariants it protects:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Mutex</span> <span class="n">mu_</span><span class="p">;</span>       <span class="c1">// protects accesses_, list_, count_
</span>                 <span class="c1">// invariant: count_ == number of elements in linked-list list_
</span></code></pre>
</div>

<p>Whenever a thread can hold two mutexes concurrently, either one (or both) of the
mutexes should be annotated with <code class="highlighter-rouge">ACQUIRED_BEFORE</code> or <code class="highlighter-rouge">ACQUIRED_AFTER</code> to
indicate which mutex must be acquired first:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Mutex</span> <span class="n">mu0_</span> <span class="n">ACQUIRED_BEFORE</span><span class="p">(</span><span class="n">mu1_</span><span class="p">);</span> <span class="c1">// protects foo_
</span></code></pre>
</div>

<p>If the mutex acquisition order is not consistent, deadlock may result. See
<a href="#deadlock-detection">Deadlock Detection</a> for utilities within the Concurrency
library to detect deadlock.</p>

<p>Each routine should be annotated or have a comment indicating which mutexes must
and must not be held on entry. These annotations allow implementors to edit
routines without examining their call sites, and allows clients to use routines
without reading their bodies.</p>

<p>The annotations <code class="highlighter-rouge">EXCLUSIVE_LOCKS_REQUIRED</code>, <code class="highlighter-rouge">SHARED_LOCKS_REQUIRED</code>,
and <code class="highlighter-rouge">LOCKS_EXCLUDED</code> are used to document such information. Since we currently
use GCC’s “attributes” to implement annotations, they can only be applied to the
function declarations, not the definitions (unless they are inside a class
definition).</p>

<p>If a routine acquires <code class="highlighter-rouge">mu</code>, we must annotate its declaration with
<code class="highlighter-rouge">LOCKS_EXCLUDED(mu)</code>:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">// Function declaration with an annotation
</span><span class="kt">void</span> <span class="n">CountAccesses</span><span class="p">()</span> <span class="n">LOCKS_EXCLUDED</span><span class="p">(</span><span class="n">mu_</span><span class="p">);</span>

<span class="c1">// Function definition
</span><span class="kt">void</span> <span class="nf">CountAccesses</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="o">-&gt;</span><span class="n">mu_</span><span class="p">.</span><span class="n">Lock</span><span class="p">();</span>
  <span class="k">this</span><span class="o">-&gt;</span><span class="n">accesses_</span><span class="o">++</span><span class="p">;</span>
  <span class="k">this</span><span class="o">-&gt;</span><span class="n">mu_</span><span class="p">.</span><span class="n">Unlock</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<p>If a routine expects to be called with <code class="highlighter-rouge">mu</code> held, we must annotate it with
<code class="highlighter-rouge">EXCLUSIVE_LOCKS_REQUIRED(mu)</code> or <code class="highlighter-rouge">SHARED_LOCKS_REQUIRED(mu)</code> depending on
whether the routine needs a writer or reader lock:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">// Function declaration with an annotation
</span><span class="kt">void</span> <span class="n">CountAccessesUnlocked</span><span class="p">()</span> <span class="n">EXCLUSIVE_LOCKS_REQUIRED</span><span class="p">(</span><span class="n">mu_</span><span class="p">);</span>

<span class="c1">// Function definition
</span><span class="kt">void</span> <span class="nf">CountAccessesUnlocked</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="o">-&gt;</span><span class="n">accesses_</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Without such annotations/comments, working with mutexes is significantly
harder.  We <strong>strongly recommend</strong> their use.</p>

<h3 id="deadlock">Deadlock</h3>

<p>A deadlock (sometimes called a <em>deadly embrace</em>) occurs when an <em>activity</em>
attempts to acquire a limited <em>resource</em> that has been exhausted and cannot be
replenished unless that activity makes progress.</p>

<p>When considering deadlocks involving only mutexes, each activity is
typically represented by a thread, and the resources are mutexes that
are exhausted when held, and replenished when released.</p>

<p>The simplest mutex-related deadlock is the <em>self-deadlock</em>:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">mu</span><span class="p">.</span><span class="n">Lock</span><span class="p">();</span>
<span class="n">mu</span><span class="p">.</span><span class="n">Lock</span><span class="p">();</span>      <span class="c1">// BUG: deadlock: thread already holds mu
</span></code></pre>
</div>

<p>Deadlocks involving two resources, such as a mutex and a bounded-sized
thread pool, are easily generated too, but deadlocks involving three or
more resources are less common.  A two-mutex deadlock results when thread
T0 attempts to acquire M1 while holding M0 at the same time that thread
T1 attempts to acquire M0 while holding M1; each thread will wait
indefinitely for the other.</p>

<h4 id="deadlock-detection">Deadlock Detection</h4>

<p>Fortunately, deadlocks are among the easiest bugs to debug and avoid.
Debugging is typically easy because the address space stops exactly
where the bug occurs.  A stack trace of the threads is usually all that
is required to see what the threads are waiting for and what resources they
hold.</p>

<p>Additionally, the <code class="highlighter-rouge">absl::Mutex</code> API provides additional deadlock detection. Such
detection is enabled only when the application is compiled in debug mode and the
flag <code class="highlighter-rouge">-synch_deadlock_detection</code> is non-zero. When enabled, the API detects two
additional types of deadlock cases:</p>

<ul>
  <li>Mutexes acquired in an inconsistent order. The deadlock detector maintains an
<em>acquired-before</em> graph for mutexes in a process. An error is generated if
potential deadlock (a cycle) is detected in that graph.</li>
  <li>Mutexes which are released by threads which do no hold them.</li>
</ul>

<p>If <code class="highlighter-rouge">-synch_deadlock_detection=1</code>, a message is printed for each lock-order
error. If <code class="highlighter-rouge">-synch_deadlock_detection=2</code>, the first lock-order error causes the
process to abort.</p>

<p>The following calls are not recommended for production code, but are useful when
deadlock detection is enabled:</p>

<ul>
  <li><code class="highlighter-rouge">Mutex::AssertHeld()</code>: abort with high probability if <code class="highlighter-rouge">mu</code> is not held
exclusively by the calling thread.</li>
  <li><code class="highlighter-rouge">Mutex::AssertReaderHeld()</code>: abort with high probability if <code class="highlighter-rouge">mu</code> is not
held in some mode by the calling thread.</li>
  <li><code class="highlighter-rouge">Mutex::ForgetDeadlockInfo()</code>: forget ordering information gathered for
this mutex. This routine should be used if the ordering of mutexes changes
during execution (this is rare).</li>
</ul>

<p>Note that deadlock detection introduces significant overhead; it should not be
enabled in production binaries.</p>

<h2 id="other-synchronization-operations">Other Synchronization Operations</h2>

<p>Most concurrency issues that are not restricted to memory access issues fall
under the broad category of “synchronization” operations. Within a concurrent
system, a synchronization operation generally encompasses operations for
which a strict ordering must be ensured.</p>

<p>Abseil contains a number of synchronization abstractions:</p>

<ul>
  <li><code class="highlighter-rouge">call_once()</code>, which allows a function to be executed exactly once across all
threads.</li>
  <li>A <code class="highlighter-rouge">Notification</code>, which allows threads to receive notification of a single
occurrence of a single event.</li>
  <li>A <code class="highlighter-rouge">Barrier</code>, which blocks threads until a prespecified threshold of threads
utilizes the barrier, at which point the barrier is unblocked.</li>
  <li>A <code class="highlighter-rouge">BlockingCounter</code>, which allows a thread to block for a pre-specified number
of actions.</li>
</ul>

<h3 id="call_once"><code class="highlighter-rouge">call_once()</code></h3>

<p><code class="highlighter-rouge">absl::call_once()</code> is a fast implementation of the C++ standard library
<code class="highlighter-rouge">std::call_once()</code>, for invoking a given function at most once, across all
threads. You pass three arguments to <code class="highlighter-rouge">call_once()</code>: a <code class="highlighter-rouge">once_flag</code> to coordinate
and identify unique callers, a function to invoke, and the arguments to invoke
with the function.</p>

<p>The first call to <code class="highlighter-rouge">call_once()</code> with a particular <code class="highlighter-rouge">once_flag</code> argument (that
does not throw an exception) will run the passed function with the provided
arguments; other calls with the same <code class="highlighter-rouge">once_flag</code> argument will not run the
function, but will wait for the provided function to finish running (if it is
still running).</p>

<p>This mechanism provides a safe, simple, and fast mechanism for one-time
initialization in a multi-threaded process:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyInitClass</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
  <span class="p">...</span>
  <span class="n">absl</span><span class="o">::</span><span class="n">once_flag</span> <span class="n">once_</span><span class="p">;</span>

  <span class="n">MyInitClass</span><span class="o">*</span> <span class="nf">Init</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">absl</span><span class="o">::</span><span class="n">call_once</span><span class="p">(</span><span class="n">once_</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">MyInitClass</span><span class="o">::</span><span class="n">Init</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ptr_</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="notification"><code class="highlighter-rouge">Notification</code></h3>

<p>A <code class="highlighter-rouge">Notification</code> allows threads to receive notification of a single occurrence
of a single event. Threads sign up for notification using one of the
notification’s <code class="highlighter-rouge">WaitForNotification*()</code> member functions.
<code class="highlighter-rouge">Notification::Notify()</code> is used to notify those waiting threads that the event
has occurred, and may be only called once for any given notification.</p>

<p>Example:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">// Create the notification
</span><span class="n">Notification</span> <span class="n">notification_</span><span class="p">;</span>

<span class="c1">// Client waits for notification
</span><span class="kt">void</span> <span class="nf">Foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">notification_</span><span class="p">.</span><span class="n">WaitForNotification</span><span class="p">();</span>
  <span class="c1">// Do something based on that notification
</span><span class="p">}</span>

<span class="c1">//
</span><span class="kt">void</span> <span class="nf">Bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Do a bunch of stuff that needs to be done before notification
</span>  <span class="n">notification_</span><span class="p">.</span><span class="n">Notify</span><span class="p">();</span>
<span class="p">}</span>

</code></pre>
</div>

<h3 id="barrier">Barrier</h3>

<p>An <code class="highlighter-rouge">absl::Barrier</code> blocks threads until a prespecified threshold of threads
utilizes the barrier. A thread utilizes the <code class="highlighter-rouge">Barrier</code> by calling <code class="highlighter-rouge">Block()</code> on
the barrier, which will block that thread; no call to <code class="highlighter-rouge">Block()</code> will return
until the specified number of threads have called it.</p>

<p>Example:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Barrier</span> <span class="o">*</span><span class="n">barrier_</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Barrier</span><span class="p">(</span><span class="n">num_active_threads</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">Foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">barrier_</span><span class="o">-&gt;</span><span class="n">Block</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">delete</span> <span class="n">barrier_</span><span class="p">;</span>  <span class="c1">// This thread is responsible for destroying barrier_;
</span>  <span class="p">}</span>
  <span class="c1">// Do something now that the Barrier has been reached.
</span><span class="p">}</span>
</code></pre>
</div>

<h3 id="blockingcounter">BlockingCounter</h3>

<p>An <code class="highlighter-rouge">absl::BlockingCounter</code> blocks all threads for a pre-specified number of
actions. Threads call <code class="highlighter-rouge">Wait()</code> on a blocking counter to block until the
specified number of events occur; worker threads then call <code class="highlighter-rouge">DecrementCount()</code> on
the counter upon completion of their work. Once the counter’s internal “count”
reaches zero, the blocked thread unblocks.</p>

<p>Example:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">Foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">BlockingCounter</span> <span class="n">things_to_process</span><span class="p">(</span><span class="n">things</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="n">Process</span><span class="p">(</span><span class="o">&amp;</span><span class="n">things_to_process</span><span class="p">)</span>
  <span class="n">things_to_process</span><span class="p">.</span><span class="n">Wait</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">Process</span><span class="p">(</span><span class="n">BlockingCounter</span><span class="o">*</span> <span class="n">things</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Do stuff
</span>  <span class="n">things</span><span class="o">-&gt;</span><span class="n">DecrementCount</span><span class="p">();</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

</div>

<div id="toc" class="toc col-sm-2"></div>
</div>
</div>
</div>




<footer>
    <div class="container">
        <div class="left-links">
            <img src="/img/typography_white.png" style="height:24px;"/>
            <p class="description">&copy;2017 Abseil | Live at Head</p>
        </div>
        <div class="right-links">
            <div class="col-md-4 col-sm-4 col-xs-12 footer-documentation">
                <ul class="toggle">
                    <a href="/about/"><p class="right-link-headers">About Abseil</p></a>
                    <li><a href="/about/intro"><p>Introduction</p></a></li>
                    <li><a href="/about/philosophy"><p>Philosophy</p></a></li>
                    <li><a href="/about/compatibility"><p>Compatibility</p></a></li>
                    <li><a href="/about/design/"><p>Design Notes</p><a></li>
                 </ul>
            </div>
            <hr class="footer-sections" />
            <div class="col-md-3 col-sm-3 col-xs-12 footer-resources">
                <ul class="toggle">
                    <a href="/docs/"><p class="right-link-headers">Dev Guides</p></a>
                    <li><a href="/docs/cpp.html"><p>C++</p></a></li>
                    <li><a href="/blog/"><p>Abseil Blog</p></a></li>
                </ul>
                </ul>
            </div>
            <hr class="footer-sections" />
            <div class="col-md-5 col-sm-5 col-xs-12 footer-community">
                <ul class="toggle">
                    <a href="/community/"><p class="right-link-headers">Community</p></a>
                    <li><a href="https://github.com/abseil/" target="_blank"><p class="github community-links">GitHub</p></a></li>
                    <li><a href="https://twitter.com/abseilio" target="_blank"><p class="twitter community-links">Twitter</p></a></li>
                    <li><a href="http://stackoverflow.com/tags/abseil/" target="_blank"><p class="stack-overflow community-links">Stack Overflow</p></a></li>
                </ul>
            </div>
        </div>
    </div>
</footer>


    <script src="/libs/bootstrap/js/bootstrap.min.js"></script>
    <!-- Include SlickJS for carousel -->
    <script src="/js/slick.min.js"></script>
    <script src="/js/jquery.visible.min.js"></script>
    <!-- Include the common site javascript -->
    <script src="/js/common.js" type="text/javascript" charset="utf-8"></script>
    <!-- GA -->
    <script src="/js/waves.js"></script>
    <script src="/js/buttons.js"></script>
    
    

    
	
	<!-- Global Site Tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-106933809-1"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments)};
	  gtag('js', new Date());

	  gtag('config', 'UA-106933809-1');
	</script>

  </body>
</html>
