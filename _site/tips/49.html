<!DOCTYPE html>
<html lang="en" itemscope itemtype="https://schema.org/WebPage">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="title" content="Abseil open-source foundational code">
    <meta name="description" content="Battle-tested, Mom-approved">
    <title>abseil / Tip of the Week #49: Argument-Dependent Lookup</title>

    <!-- Fontawesome Icons -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
    
    <!-- Favicons -->
    <link rel="shortcut icon" type="image/x-icon" href="/favicons/favicon.ico" />
    
    <!-- Bootstrap -->
    <link href="/libs/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Site style using SASS, generated by from style.scss -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Slick styling -->
    <link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/jquery.slick/1.6.0/slick.css"/>
    <link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/jquery.slick/1.6.0/slick-theme.css"/>

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- metadata -->
    <meta name="og:title" content="abseil / Tip of the Week #49: Argument-Dependent Lookup"/>
	 <meta name="og:description" content="An open-source collection of core C++ library code"/>
  </head>
  <body class=>

  	<nav id="sticky-nav">
  <div class="nav-container container">
    <div class="row">
      <div class="col-md-11 nofloat center-block">
        <a class="col-xs-2" href="/">
          <img class="nav-logo" src="/img/absl_18px.svg" alt="Abseil">
        </a>

        <div class="col-xs-2 col-xs-offset-8">
          <button type="button" class="hamburger navbar-toggle collapsed" data-target="#navbar-collapse-1">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
        </div>

        <ul class="nav col-xs-10">
          
          <li><a href="/about" >About</a></li>
          <li><a href="/docs/" >Docs</a></li>
		  <li><a href="/tips/" class='current'>Tips</a></li>
          <li><a href="/blog/" >Blog</a></li>
          <li><a href="/community/" >Community</a></li>
        </ul>

      </div>
    </div>
  </div>

  <div class="top-nav right">
    
    <li class="nav-item"><a href="/"><p>Home</p></a><div class="nav-toggle icon-close"></div></li>
    <hr>
    <li class="nav-item"><a href="/about" ><p>About</p></a></li>
    <hr>
    <li class="nav-item"><a href="/docs/" ><p>Docs</p></a>
      <div class="nav-doc-toggle icon-caret"></div>
      <ul class="doc-list">
        <a href="/docs/cpp" ><li class="nav-doc-tab">C++ Devguide</li></a>
        <a href="/docs/cpp/quickstart" ><li class="nav-doc-tab">C++ Quick Start</li></a>
      </ul>
    </li>
    <hr>
    <li class="nav-item"><a href="/tips/" class='current'><p>Tips</p></a></li>
    <hr>
    <li class="nav-item"><a href="/blog/" ><p>Blog</p></a></li>
    <hr>
    <li class="nav-item"><a href="/community/" ><p>Community</p></a></li>
  </div>
</nav>


<div class="nav-hero-container">
	<nav id="common-nav">
  <div class="nav-container container">
    <div class="row">
      <div class="col-md-11 nofloat center-block">
        <a class="col-xs-2" href="/">
          <img class="nav-logo" src="/img/absl_80px.png" alt="Abseil">
        </a>

        <div class="col-xs-2 col-xs-offset-8">
          <button type="button" class="hamburger navbar-toggle collapsed" data-target="#navbar-collapse-1">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
        </div>

        <ul class="nav col-xs-10">
          
          <li><a href="/about" >About</a></li>
          <li><a href="/docs/" >Docs</a></li>
          <li><a href="/tips/" class='current'>C++ Tips</a></li>
		  <li><a href="/blog/" >Blog</a></li>
          <li><a href="/community" >Community</a></li>
        </ul>

      </div>
    </div>
  </div>

  <div class="top-nav right">
    
    <li class="nav-item"><a href="/"><p>Home</p></a><div class="nav-toggle icon-close"></div></li>
    <hr>
    <li class="nav-item"><a href="/about/" ><p>About</p></a></li>
    <hr>
    <li class="nav-item"><a href="/docs/" ><p>Docs</p></a>
      <div class="nav-doc-toggle icon-caret"></div>
      <ul class="doc-list">
        <a href="/docs/cpp/quickstart" ><li class="nav-doc-tab">Quickstart</li></a>
      </ul>
    </li>
    <hr>
    <li class="nav-item"><a href="/blog/" ><p>Blog</p></a></li>
    <hr>
    <li class="nav-item"><a href="/tips/" class='current'><p>Tips</p></a></li>
    <hr>
    <li class="nav-item"><a href="/community/" ><p>Community</p></a></li>
  </div>
  <div class="container">
    <div class="row">
      <div class="col-md-11 nofloat center-block">
        <div class="col-xs-12">
          <h1 class="page-headline"></h1> 
        </div>
      </div>
    </div>
  </div>

</nav>

   <a href="https://github.com/abseil/" class="fork-btn" target="_blank"></a>

</div>



<div class="container">
<div class="row">
<div class="col-md-12 nofloat center-block ">
<div class="col-sm-3">
<ul class="doc-side-nav">
   <li><h5 class="doc-side-nav-title">
    <a href="/tips/">C++ Tips</a></h5>
   </li>
   

   
     
   
     
   
     
   
     
   
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/1">TotW #1: string_view</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/42">TotW #42: Prefer Factory Functions to Initializer Methods</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/49">TotW #49: Argument-Dependent Lookup</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/55">TotW #55: Name Counting and unique_ptr</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/64">TotW #64: Raw String Literals</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/65">TotW #65: Putting Things in their Place</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/74">TotW #74: Delegating and Inheriting Constructors</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/77">TotW #77: Temporaries, Moves, and Copies</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/86">TotW #86: Enumerating with Class</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/94">TotW #94: Callsite Readability and bool Parameters</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/99">TotW #99: Nonmember Interface Etiquette</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/101">TotW #101: Return Values, References, and Lifetimes</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/107">TotW #107: Reference Lifetime Extension</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/109">TotW #109: Meaningful `const` in Function Declarations</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/112">TotW #112: emplace vs. push_back</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/119">TotW #119: Using-declarations and namespace aliases</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/122">TotW #122: Test Fixtures, Clarity, and Dataflow</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/123">TotW #123: <code>absl::optional</code> and <code>std::unique_ptr</code></a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/126">TotW #126: `make_unique` is the new `new`</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/130">TotW #130: Namespace Naming</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/131">TotW #131: Special Member Functions and `= default`</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/135">TotW #135: Test the Contract, not the Implementation</a></h6>
     </li>
     
   
 </ul>

</div>
<div class="col-sm-8 markdown">
<h1>Tip of the Week #49: Argument-Dependent Lookup</h1>
<p>Originally posted as totw/49 on 2013-07-14</p>

<p><em>“…whatever disappearing trail of its legalistic argle-bargle one chooses to
follow…” –Antonin Scalia, <a href="http://www.supremecourt.gov/opinions/12pdf/12-307_6j37.pdf">U.S. v Windsor dissenting opinion</a></em></p>

<h2 id="overview">Overview</h2>

<p>A function call expression such as <code class="highlighter-rouge">func(a,b,c)</code>, in which the function is named
without the <code class="highlighter-rouge">::</code> scope operator, is called unqualified. When C++ code refers to
a function by an unqualified name, the compiler performs a search for a matching
function declaration. What is surprising to some people (and different from
other languages) is that in addition to the caller’s lexical scope, the set of
search scopes is augmented by namespaces associated with the function argument
types. This additional lookup is called <em>Argument-Dependent Lookup</em> (ADL). It’s
definitely happening in your code, so you’ll be much better off with a basic
understanding of how it works.</p>

<h2 id="name-lookup-basics">Name Lookup Basics</h2>

<p>A function call must be mapped to a single function definition by the compiler.
This matching is done in two independent serial processing stages. First, <em>name
lookup</em> applies some scope searching rules to produce a set of overloads
matching the name of the function. Then <em>overload resolution</em> takes those
overloads produced by that name lookup and tries to choose a best match for the
arguments given at the call site. Keep this distinction in mind. Name lookup
comes first, and it doesn’t try to make any determination as to whether a
function is a good match or not. It doesn’t even consider the argument count. It
just searches scopes for a function name. Overload resolution is a complex topic
in its own right, but it’s not our focus right now. Just know that it’s a
separate processing stage that gets its inputs from name lookup.</p>

<p>When an unqualified function call is encountered, several independent search
sequences can occur for that function name, each attempting to match the name to
a set of overloads. The most obvious search is the outward search starting from
the lexical scope of the call site:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">b</span> <span class="p">{</span>
<span class="kt">void</span> <span class="n">func</span><span class="p">();</span>
<span class="k">namespace</span> <span class="n">internal</span> <span class="p">{</span>
<span class="kt">void</span> <span class="n">test</span><span class="p">()</span> <span class="p">{</span> <span class="n">func</span><span class="p">();</span> <span class="p">}</span> <span class="c1">// ok: finds b::func().
</span><span class="p">}</span> <span class="c1">// b::internal
</span><span class="p">}</span> <span class="c1">// b
</span></code></pre>
</div>

<p>This name lookup has nothing to do with ADL yet (<code class="highlighter-rouge">func()</code> has no arguments). It
is simply a search outward from the site of the function call, proceeding
outward from local function scope (if applicable), to class scope, enclosing
class scope, and base classes (if applicable), then to namespace scope, and out
into enclosing namespaces, and finally the global <code class="highlighter-rouge">::</code> namespace.</p>

<p>As name lookup progresses through a sequence of increasingly widening scopes,
the process stops as soon as any function with the target name is found, whether
or not that function’s arguments are compatible with the arguments supplied by
the call site. When a scope is encountered containing at least one function
declaration with the target name, the overloads in that scope become the result
of that name lookup.</p>

<p>This is illustrated in the example below:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">b</span> <span class="p">{</span>
<span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">);</span>  <span class="c1">// b::func
</span><span class="k">namespace</span> <span class="n">internal</span> <span class="p">{</span>
<span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>  <span class="c1">// b::internal::func
</span><span class="k">namespace</span> <span class="n">deep</span> <span class="p">{</span>
<span class="kt">void</span> <span class="n">test</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">s</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>
  <span class="n">func</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>  <span class="c1">// error: finds only b::internal::func(int).
</span><span class="p">}</span>
<span class="p">}</span>  <span class="c1">// b::internal::deep
</span><span class="p">}</span>  <span class="c1">// b::internal
</span><span class="p">}</span>  <span class="c1">// b
</span></code></pre>
</div>

<p>It’s tempting but incorrect to think a <code class="highlighter-rouge">func(s)</code> expression will overlook the
obviously bad match of <code class="highlighter-rouge">b::internal::func(int)</code>, and continue looking to the
next outward enclosing scope to find <code class="highlighter-rouge">b::func(const string&amp;)</code>. However, name
lookup doesn’t consider argument types. It finds something called <code class="highlighter-rouge">func</code> and
stops in <code class="highlighter-rouge">b::internal</code>, leaving the evaluation of “obviously bad” to the
overload resolution phase. The <code class="highlighter-rouge">b::func(const string&amp;)</code> function is never even
seen by overload resolution.</p>

<p>An important implication of the scoped search order is that overloads in a scope
appearing earlier in the search order will hide overloads from later scopes.</p>

<h2 id="argument-dependent-lookup">Argument-Dependent Lookup</h2>

<p>If a function call passes arguments, a few more parallel name lookups are
launched. These extra lookups begin in each associated namespace of each of the
function call’s arguments. A scope containing a name match doesn’t stop all of
the lookups, only the one that encountered the match.</p>

<h2 id="the-simple-case">The Simple Case</h2>

<p>Consider the following code:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">aspace</span> <span class="p">{</span>
<span class="k">struct</span> <span class="n">A</span> <span class="p">{};</span>
<span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span><span class="p">);</span>  <span class="c1">// found by ADL name lookup on 'a'.
</span><span class="p">}</span>  <span class="c1">// namespace aspace
</span>
<span class="k">namespace</span> <span class="n">bspace</span> <span class="p">{</span>
<span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>  <span class="c1">// found by lexical scope name lookup
</span><span class="kt">void</span> <span class="nf">test</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">aspace</span><span class="o">::</span><span class="n">A</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="c1">// aspace::func(const aspace::A&amp;)
</span><span class="p">}</span>
<span class="p">}</span>  <span class="c1">// namespace bspace
</span></code></pre>
</div>

<p>Two name lookups are launched to resolve the call to <code class="highlighter-rouge">func(a)</code>. The lexical
scope name lookup starts in the local function scope of <code class="highlighter-rouge">bspace::test()</code>. It
finds no <code class="highlighter-rouge">func</code> there and proceeds to the scope of namespace <code class="highlighter-rouge">bspace</code>, in which
it finds <code class="highlighter-rouge">func(int)</code> and stops. The other name lookup, which is due to ADL,
starts in the namespace associated with the argument <code class="highlighter-rouge">a</code>. In this case, that’s
only namespace <code class="highlighter-rouge">aspace</code>. That lookup finds <code class="highlighter-rouge">aspace::func(const aspace::A&amp;)</code> and
stops. Overload resolution therefore receives two candidates. These are
‘bspace::func(int)’ from lexical name lookup, and ‘aspace::func(const
aspace::A&amp;)’ from the single ADL lookup. In overload resolution, the <code class="highlighter-rouge">func(a)</code>
call resolves to <code class="highlighter-rouge">aspace::func(const aspace::A&amp;)</code>. The <code class="highlighter-rouge">bspace::func(int)</code>
overload is not a good match for the argument type and so it is rejected by
overload resolution.</p>

<p>The lexical name search and each of the additional ADL-triggered name searches
can be considered to occur in parallel, with each returning a set of candidate
function overloads. The results of all such searches are thrown in a bag and
they compete via overload resolution to determine the best match. If there’s a
tie for best match, the compiler issues an ambiguity error; “There can be only
one.” If no overload is a good match, that’s an error too. So more precisely,
“there must be exactly one”, which doesn’t sound as cool in a movie trailer.</p>

<h2 id="type-associated-namespaces">Type-Associated Namespaces</h2>

<p>The previous example was the simple case, but a more sophisticated type can have
many namespaces associated with it. The set of namespaces associated with a type
includes any namespace of any type that appears as a part of the argument type’s
full name, including its template parameter types. It also includes the
namespaces of direct and indirect base classes. For example, a single argument
that expands to the type <code class="highlighter-rouge">a::A&lt;b::B, c::internal::C*&gt;</code> will produce searches
beginning in the <code class="highlighter-rouge">a</code>, <code class="highlighter-rouge">b</code> and <code class="highlighter-rouge">c::internal</code> namespaces (and any other namespaces
associated with the constituent types <code class="highlighter-rouge">a::A</code>, <code class="highlighter-rouge">b::B</code>, or <code class="highlighter-rouge">c::internal::C</code>), each
looking for the called function name. The following example shows a few of these
effects:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">aspace</span> <span class="p">{</span>
<span class="k">struct</span> <span class="n">A</span> <span class="p">{};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">AGeneric</span> <span class="p">{};</span>
<span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span><span class="p">);</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">find_me</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
<span class="p">}</span>  <span class="c1">// namespace aspace
</span>
<span class="k">namespace</span> <span class="n">bspace</span> <span class="p">{</span>
<span class="k">typedef</span> <span class="n">aspace</span><span class="o">::</span><span class="n">A</span> <span class="n">AliasForA</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">B</span> <span class="o">:</span> <span class="n">aspace</span><span class="o">::</span><span class="n">A</span> <span class="p">{};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">BGeneric</span> <span class="p">{};</span>
<span class="kt">void</span> <span class="nf">test</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ok: base class namespace searched.
</span>  <span class="n">func</span><span class="p">(</span><span class="n">B</span><span class="p">());</span>
  <span class="c1">// ok: template parameter namespace searched.
</span>  <span class="n">find_me</span><span class="p">(</span><span class="n">BGeneric</span><span class="o">&lt;</span><span class="n">aspace</span><span class="o">::</span><span class="n">A</span><span class="o">&gt;</span><span class="p">());</span>
  <span class="c1">// ok: template namespace searched.
</span>  <span class="n">find_me</span><span class="p">(</span><span class="n">aspace</span><span class="o">::</span><span class="n">AGeneric</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>
<span class="p">}</span>
<span class="p">}</span>  <span class="c1">// namespace bspace
</span></code></pre>
</div>

<h2 id="tips">Tips</h2>

<p>With the fundamental name lookup mechanism fresh in your mind, consider the
following tips which may help you when you are working with real C++ code.</p>

<h2 id="type-aliases">Type Aliases</h2>

<p>Sometimes determining the set of namespaces associated with a type will take a
bit of detective work. <code class="highlighter-rouge">typedef</code> and using declarations can introduce aliases
for a type. In those cases the aliases are fully resolved and expanded to their
source types before the list of namespaces to search are chosen. This is one way
in which <code class="highlighter-rouge">typedef</code> and using declarations can be a bit misleading, because they
can lead you to make incorrect predictions about which namespaces will be
searched by ADL. This is demonstrated below:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">cspace</span> <span class="p">{</span>
<span class="c1">// ok: note that this searches aspace, not bspace.
</span><span class="kt">void</span> <span class="n">test</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">func</span><span class="p">(</span><span class="n">bspace</span><span class="o">::</span><span class="n">AliasForA</span><span class="p">());</span>
<span class="p">}</span>
<span class="p">}</span>  <span class="c1">// namespace cspace
</span></code></pre>
</div>

<h2 id="caveat-iterator">Caveat Iterator</h2>

<p>Be careful with iterators. You don’t really know with what namespaces they are
associated, so don’t rely on ADL for resolving function calls involving
iterators. They might just be pointers to the elements, or they might be in some
namespace private to the implementation that has nothing to do with the
container’s namespace.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">d</span> <span class="p">{</span>
<span class="kt">int</span> <span class="n">test</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
  <span class="c1">// maybe this compiles, maybe not!
</span>  <span class="k">return</span> <span class="n">count</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">}</span>  <span class="c1">// namespace d
</span></code></pre>
</div>

<p>The above code has a dependency on whether <code class="highlighter-rouge">std::vector&lt;int&gt;::iterator</code> is
<code class="highlighter-rouge">int*</code> (which is possible) or some type in a namespace that has a count overload
(like <code class="highlighter-rouge">std::count()</code>). It’s possible that this will work on some platforms and not
others, or that it will work in debug builds with instrumented iterators, but
not in optimized builds. It’s better to just qualify the function name. If you
want to call <code class="highlighter-rouge">std::count()</code>, spell it that way.</p>

<h2 id="overloaded-operators">Overloaded Operators</h2>

<p>An operator (e.g. <code class="highlighter-rouge">+</code> or <code class="highlighter-rouge">&lt;&lt;</code>) can be thought of as a kind of function name,
e.g. <code class="highlighter-rouge">operator+(a,b)</code> or <code class="highlighter-rouge">operator&lt;&lt;(a,b)</code>, and are also unqualified. One of the
most important uses of ADL is the search for <code class="highlighter-rouge">operator&lt;&lt;</code> used during logging.
Usually we see something like <code class="highlighter-rouge">std::cout &lt;&lt; obj;</code> for some <code class="highlighter-rouge">obj</code>, let’s say of
type <code class="highlighter-rouge">O::Obj</code>. This statement is like an unqualified function call of the form
<code class="highlighter-rouge">operator&lt;&lt;(std::ostream&amp;, const O::Obj&amp;)</code>, which will find overloads in the
<code class="highlighter-rouge">std</code> namespace from the <code class="highlighter-rouge">std::ostream</code> parameter, the <code class="highlighter-rouge">O</code> namespace from the
<code class="highlighter-rouge">O::Obj</code> parameter, and of course any overloads picked up from the lexical scope
search from the call site.</p>

<p>It’s important to place such operators in the same namespace as the user-defined
type they’re meant to operate upon: in this case within namespace <code class="highlighter-rouge">O</code>. If the
<code class="highlighter-rouge">operator&lt;&lt;</code> is placed in an outer namespace like <code class="highlighter-rouge">::</code> (the global namespace),
that operator will work for a while until someone quite innocently places an
unrelated <code class="highlighter-rouge">operator&lt;&lt;</code> in namespace ‘O’ for some other type. It takes a bit of
discipline but saves a lot of confusion later to follow the simple rule of
defining all operators and other associated nonmember functions next to the
type’s definition in the same namespace.</p>

<h2 id="fundamental-types">Fundamental Types</h2>

<p>Note that the fundamental types (e.g. <code class="highlighter-rouge">int</code>, <code class="highlighter-rouge">double</code>, etc) are not associated
with the global namespace. They are associated with no namespace. They do not
contribute any namespaces to ADL. Pointer and array types are associated with
their pointee or element types.</p>

<h2 id="refactoring-gotchas">Refactoring Gotchas</h2>

<p>Refactorings that change the types of arguments to an unqualified function call
can affect which, if any, overloads are considered. Just moving a type into a
namespace and leaving behind a typedef in the old namespace for compatibility
doesn’t help, and really just makes the problem harder to diagnose. Be careful
when moving types to new namespaces.</p>

<p>Similarly, moving a function to a new namespace and leaving behind a <code class="highlighter-rouge">using</code>
declaration might mean that unqualified calls won’t find it anymore. Sadly, they
might still compile by finding a different function you didn’t intend them to
find. Be careful when moving functions to new namespaces.</p>

<h2 id="final-thought">Final Thought</h2>

<p>Relatively few programmers understand the exact rules and corner cases involved
with function lookups. The language spec contains 13 pages of rules about what
exactly goes into a name search, including special cases, details about friend
functions, and enclosing class scopes to keep your head spinning for years.
Despite all this complexity, if you keep the basic idea of parallel name
searches in mind, you’ll be on solid footing for understanding how your function
calls and operators are resolving. You will now be able to see how seemingly
remote declarations end up being chosen when you invoke functions or operators.
And you’ll be a little better able to diagnose puzzling build errors like
ambiguities or name-hiding effects when they happen.</p>


</div>

<div id="toc" class="col-sm-1"></div>
<br />
<a href="http://feeds.feedburner.com/abseilio"
    title="Subscribe to Abseil Blog &amp; Tips"
    rel="alternate"
    type="application/rss+xml">
    <img src="//feedburner.google.com/fb/images/pub/feed-icon32x32.png"
         alt="Subscribe to the Abseil Blog" style="border:0;">
    </img>
</a>
</div>
</div>
</div>




<footer>
    <div class="container">
        <div class="left-links">
            <img src="/img/typography_white.png" style="height:24px;"/>
            <p class="description">&copy;2017 Abseil | Live at Head</p>
        </div>
        <div class="right-links">
            <div class="col-md-4 col-sm-4 col-xs-12 footer-documentation">
                <ul class="toggle">
                    <a href="/about/"><p class="right-link-headers">About Abseil</p></a>
                    <li><a href="/about/intro"><p>Introduction</p></a></li>
                    <li><a href="/about/philosophy"><p>Philosophy</p></a></li>
                    <li><a href="/about/compatibility"><p>Compatibility</p></a></li>
                    <li><a href="/about/design/"><p>Design Notes</p><a></li>
                 </ul>
            </div>
            <hr class="footer-sections" />
            <div class="col-md-3 col-sm-3 col-xs-12 footer-resources">
                <ul class="toggle">
                    <a href="/docs/"><p class="right-link-headers">Dev Guides</p></a>
                    <li><a href="/docs/cpp.html"><p>C++</p></a></li>
                    <li><a href="/blog/"><p>Abseil Blog</p></a></li>
                </ul>
                </ul>
            </div>
            <hr class="footer-sections" />
            <div class="col-md-5 col-sm-5 col-xs-12 footer-community">
                <ul class="toggle">
                    <a href="/community/"><p class="right-link-headers">Community</p></a>
                    <li><a href="https://github.com/abseil/" target="_blank"><p class="github community-links">GitHub</p></a></li>
                    <li><a href="https://twitter.com/abseilio" target="_blank"><p class="twitter community-links">Twitter</p></a></li>
                    <li><a href="http://stackoverflow.com/tags/abseil/" target="_blank"><p class="stack-overflow community-links">Stack Overflow</p></a></li>
                </ul>
            </div>
        </div>
    </div>
</footer>


    <script src="/libs/bootstrap/js/bootstrap.min.js"></script>
    <!-- Include SlickJS for carousel -->
    <script src="/js/slick.min.js"></script>
    <script src="/js/jquery.visible.min.js"></script>
    <!-- Include the common site javascript -->
    <script src="/js/common.js" type="text/javascript" charset="utf-8"></script>
    <!-- GA -->
    <script src="/js/waves.js"></script>
    <script src="/js/buttons.js"></script>
    
    

    
	
	<!-- Global Site Tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-106933809-1"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments)};
	  gtag('js', new Date());

	  gtag('config', 'UA-106933809-1');
	</script>

  </body>
</html>
