<!DOCTYPE html>
<html lang="en" itemscope itemtype="https://schema.org/WebPage">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="title" content="Abseil open-source foundational code">
    <meta name="description" content="Battle-tested, Mom-approved">
    <title>abseil / Tip of the Week #130: Namespace Naming</title>

    <!-- Fontawesome Icons -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
    
    <!-- Favicons -->
    <link rel="shortcut icon" type="image/x-icon" href="/favicons/favicon.ico" />
    
    <!-- Bootstrap -->
    <link href="/libs/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Site style using SASS, generated by from style.scss -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Slick styling -->
    <link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/jquery.slick/1.6.0/slick.css"/>
    <link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/jquery.slick/1.6.0/slick-theme.css"/>

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- metadata -->
    <meta name="og:title" content="abseil / Tip of the Week #130: Namespace Naming"/>
	 <meta name="og:description" content="An open-source collection of core C++ library code"/>
  </head>
  <body class=>

  	<nav id="sticky-nav">
  <div class="nav-container container">
    <div class="row">
      <div class="col-md-11 nofloat center-block">
        <a class="col-xs-2" href="/">
          <img class="nav-logo" src="/img/absl_18px.svg" alt="Abseil">
        </a>

        <div class="col-xs-2 col-xs-offset-8">
          <button type="button" class="hamburger navbar-toggle collapsed" data-target="#navbar-collapse-1">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
        </div>

        <ul class="nav col-xs-10">
          
          <li><a href="/about" >About</a></li>
          <li><a href="/docs/" >Docs</a></li>
		  <li><a href="/tips/" class='current'>Tips</a></li>
          <li><a href="/blog/" >Blog</a></li>
          <li><a href="/community/" >Community</a></li>
        </ul>

      </div>
    </div>
  </div>

  <div class="top-nav right">
    
    <li class="nav-item"><a href="/"><p>Home</p></a><div class="nav-toggle icon-close"></div></li>
    <hr>
    <li class="nav-item"><a href="/about" ><p>About</p></a></li>
    <hr>
    <li class="nav-item"><a href="/docs/" ><p>Docs</p></a>
      <div class="nav-doc-toggle icon-caret"></div>
      <ul class="doc-list">
        <a href="/docs/cpp" ><li class="nav-doc-tab">C++ Devguide</li></a>
        <a href="/docs/cpp/quickstart" ><li class="nav-doc-tab">C++ Quick Start</li></a>
      </ul>
    </li>
    <hr>
    <li class="nav-item"><a href="/tips/" class='current'><p>Tips</p></a></li>
    <hr>
    <li class="nav-item"><a href="/blog/" ><p>Blog</p></a></li>
    <hr>
    <li class="nav-item"><a href="/community/" ><p>Community</p></a></li>
  </div>
</nav>


<div class="nav-hero-container">
	<nav id="common-nav">
  <div class="nav-container container">
    <div class="row">
      <div class="col-md-11 nofloat center-block">
        <a class="col-xs-2" href="/">
          <img class="nav-logo" src="/img/absl_80px.png" alt="Abseil">
        </a>

        <div class="col-xs-2 col-xs-offset-8">
          <button type="button" class="hamburger navbar-toggle collapsed" data-target="#navbar-collapse-1">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
        </div>

        <ul class="nav col-xs-10">
          
          <li><a href="/about" >About</a></li>
          <li><a href="/docs/" >Docs</a></li>
          <li><a href="/tips/" class='current'>C++ Tips</a></li>
		  <li><a href="/blog/" >Blog</a></li>
          <li><a href="/community" >Community</a></li>
        </ul>

      </div>
    </div>
  </div>

  <div class="top-nav right">
    
    <li class="nav-item"><a href="/"><p>Home</p></a><div class="nav-toggle icon-close"></div></li>
    <hr>
    <li class="nav-item"><a href="/about/" ><p>About</p></a></li>
    <hr>
    <li class="nav-item"><a href="/docs/" ><p>Docs</p></a>
      <div class="nav-doc-toggle icon-caret"></div>
      <ul class="doc-list">
        <a href="/docs/cpp/quickstart" ><li class="nav-doc-tab">Quickstart</li></a>
      </ul>
    </li>
    <hr>
    <li class="nav-item"><a href="/blog/" ><p>Blog</p></a></li>
    <hr>
    <li class="nav-item"><a href="/tips/" class='current'><p>Tips</p></a></li>
    <hr>
    <li class="nav-item"><a href="/community/" ><p>Community</p></a></li>
  </div>
  <div class="container">
    <div class="row">
      <div class="col-md-11 nofloat center-block">
        <div class="col-xs-12">
          <h1 class="page-headline"></h1> 
        </div>
      </div>
    </div>
  </div>

</nav>

   <a href="https://github.com/abseil/" class="fork-btn" target="_blank"></a>

</div>



<div class="container">
<div class="row">
<div class="col-md-12 nofloat center-block ">
<div class="col-sm-3">
<ul class="doc-side-nav">
   <li><h5 class="doc-side-nav-title">
    <a href="/tips/">C++ Tips</a></h5>
   </li>
   

   
     
   
     
   
     
   
     
   
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/1">TotW #1: string_view</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/42">TotW #42: Prefer Factory Functions to Initializer Methods</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/49">TotW #49: Argument-Dependent Lookup</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/55">TotW #55: Name Counting and unique_ptr</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/64">TotW #64: Raw String Literals</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/65">TotW #65: Putting Things in their Place</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/74">TotW #74: Delegating and Inheriting Constructors</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/77">TotW #77: Temporaries, Moves, and Copies</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/86">TotW #86: Enumerating with Class</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/94">TotW #94: Callsite Readability and bool Parameters</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/99">TotW #99: Nonmember Interface Etiquette</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/101">TotW #101: Return Values, References, and Lifetimes</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/107">TotW #107: Reference Lifetime Extension</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/109">TotW #109: Meaningful `const` in Function Declarations</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/112">TotW #112: emplace vs. push_back</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/119">TotW #119: Using-declarations and namespace aliases</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/122">TotW #122: Test Fixtures, Clarity, and Dataflow</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/123">TotW #123: <code>absl::optional</code> and <code>std::unique_ptr</code></a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/126">TotW #126: `make_unique` is the new `new`</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/130">TotW #130: Namespace Naming</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/131">TotW #131: Special Member Functions and `= default`</a></h6>
     </li>
     
   
     
     <li><h6 class="doc-side-nav-list-item">
         <a href="/tips/135">TotW #135: Test the Contract, not the Implementation</a></h6>
     </li>
     
   
 </ul>

</div>
<div class="col-sm-8 markdown">
<h1>Tip of the Week #130: Namespace Naming</h1>
<p>Originally posted as totw/130 on 2017-02-17</p>

<p>By Titus Winters <a href="mailto:titus@google.com">(titus@google.com)</a></p>

<p><em>The precision of naming takes away from the uniqueness of seeing</em> — Pierre
Bonnard</p>

<p>The earliest commit of the Google C++ Style Guide contains the guidance that
many people are still using for namespace naming. Roughly, this can be
summarized as “namespaces are derived from package paths.” Following on
the heels of Java’s package naming requirements, this makes a lot of sense: we
want to be able to uniquely identify symbols in C++ and we want there to be
uniqueness and consistency in namespace choice.</p>

<p>Except in actuality, we don’t. We just didn’t realize for almost a decade.</p>

<h2 id="name-lookup">Name Lookup</h2>

<p>Let’s start with how name lookup works in C++ and how it’s different from Java.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">foo</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">bar</span> <span class="p">{</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Baz</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>In C++, lookup on an unqualified name (<code class="highlighter-rouge">Baz</code>) will search expanding scopes for a
symbol of the same name: first in <code class="highlighter-rouge">f()</code> (the function), then in <code class="highlighter-rouge">bar</code>, then in
<code class="highlighter-rouge">foo</code>, then in the global namespace.</p>

<p>In Java, there is no such thing as an unqualified symbol: either a symbol is
a qualified name:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">f</span><span class="o">()</span> <span class="o">{</span>
  <span class="n">com</span><span class="o">.</span><span class="na">google</span><span class="o">.</span><span class="na">foo</span><span class="o">.</span><span class="na">bar</span><span class="o">.</span><span class="na">Baz</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">com</span><span class="o">.</span><span class="na">google</span><span class="o">.</span><span class="na">foo</span><span class="o">.</span><span class="na">bar</span><span class="o">.</span><span class="na">Baz</span><span class="o">();</span>
<span class="o">}</span>
</code></pre>
</div>

<p>Or it is imported, either as a single package member or via wildcard:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">com.google.foo.bar.Baz</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.google.foo.bar.*</span><span class="o">;</span>
</code></pre>
</div>

<p>In no case is <code class="highlighter-rouge">Baz</code> looked for outside of the package that is explicitly
provided: wildcards don’t descend into child packages, nor is search extended
into parent packages. As it turns out, this difference in how parent
packages/namespaces are handled within Java and C++ is fundamental to why
structural namespace naming (making the namespace structure match the package
hierarchy) is a mistake within C++.</p>

<h2 id="the-problem">The Problem</h2>

<p>The fundamental problem for building namespaces out of packages is that we
rarely rely on fully-qualified lookup in C++, normally writing <code class="highlighter-rouge">std::unique_ptr</code>
rather than <code class="highlighter-rouge">::std::unique_ptr</code>. Coupled with lookup in enclosing namespaces,
this means that for code in a deeply nested package
(<code class="highlighter-rouge">::division::section::team::subteam::project</code>, for example) any symbol that is not
fully qualified (<code class="highlighter-rouge">std::unique_ptr</code>) can in fact reference any of</p>

<ul>
  <li><code class="highlighter-rouge">::std::unique_ptr</code></li>
  <li><code class="highlighter-rouge">::division::std::unique_ptr</code></li>
  <li><code class="highlighter-rouge">::division::section::std::unique_ptr</code></li>
  <li><code class="highlighter-rouge">::division::section::team::std::unique_ptr</code></li>
  <li><code class="highlighter-rouge">::division::section::team::subteam::std::unique_ptr</code></li>
  <li><code class="highlighter-rouge">::division::section::team::subteam::project::std::unique_ptr</code></li>
</ul>

<p>And what’s worse: unqualified search starts at the bottom of that list <em>and
stops as soon as there is a namespace match</em>. This means that your build can be
broken if any of your transitive includes add a previously unused namespace that
matches the leading namespace of any symbol you use out of an unqualified
namespace. Strictly speaking, this doesn’t even have to be a build break: if
someone adds something with a matching name and a syntactically-compatible API,
the implementation of that API may be completely incompatible and cause
widespread havoc at runtime. Obviously this isn’t too bad with <code class="highlighter-rouge">std</code> - nobody
should ever be adding a nested namespace <code class="highlighter-rouge">std</code> -  but what about more common
namespaces? How about things like <code class="highlighter-rouge">testing</code>?</p>

<p>Names aren’t chosen to be unique. Since teams commonly create local utility
packages to handle common tasks relating to the infrastructure they rely on, we
wind up with local <code class="highlighter-rouge">util</code> and <code class="highlighter-rouge">pipeline</code> packages - and
sub-namespaces. This is a recipe for unnecessary and unintended collisions.</p>

<p>For comparison, the problem in Java is far reduced: if you wildcard-import from
two packages in Java and one adds a new symbol with the same name as the other
package, your build can break. This is easily and completely solved by
forbidding wildcard imports as is done in many Java styles.</p>

<h2 id="two-consistent-options-three-approaches">Two Consistent Options, Three Approaches</h2>

<p>There are two features that prevent this build-break-at-a-distance:</p>

<ul>
  <li>If no leaf namespace (<code class="highlighter-rouge">search::foo::bar</code>) matches any top-level namespace
(<code class="highlighter-rouge">::bar</code>) or a sub-namespace of any parent of that leaf (<code class="highlighter-rouge">search::bar</code>), no
name collisions will occur.</li>
  <li>If there are no unqualified lookups, there will be no problems.</li>
</ul>

<p>There are (at least) three ways to achieve this:</p>

<ul>
  <li>Always fully qualify everything outside of the current namespace. This is
very verbose and sort of weird: nothing in C++ (including the standard
library) is written with leading <code class="highlighter-rouge">::</code> on every symbol.</li>
  <li>Build some tooling to identify introduction of new namespaces and ensure
that it doesn’t overlap with any other namespace in the same hierarchy. That
is, do not add <code class="highlighter-rouge">search::bar</code> if there is a <code class="highlighter-rouge">::bar</code> or a <code class="highlighter-rouge">search::foo::bar</code>.</li>
  <li>Don’t nest deeply: a single top-level namespace per project gets the same
result without long/complicated names, with less exposure to accidents,
without causing surprise for new engineers, and without the need to build any
tooling.</li>
</ul>

<p>The current style guide suggests the <a href="http://google.github.io/styleguide/cppguide.html#Namespace_Names">last
option</a>, but
allows for the old style (namespaces match package names) if necessary. This is
largely because the Google didn’t want to cause too much anxiety or
trigger anyone re-namespacing things. That said, if we had it to do over again
in a fresh codebase we would unambiguously say this: one top-level namespace for
public interfaces per project. Ensure uniqueness of namespaces via a common
database. Thus we get (only) top-level namespaces like <code class="highlighter-rouge">absl</code>, and can have no
ambiguity in lookup (barring collision between local symbols and those in the
global namespace, but modern rules discourage the global namespace anyway).</p>

<p>Because there is so much code that existed before this change, and so much code
following the old pattern even after this change, we find ourselves in a sort of
half-way space, with some namespaces that often need to be fully qualified
(<code class="highlighter-rouge">::util</code>), and some that are obviously unique and never need to be (<code class="highlighter-rouge">std</code>).</p>

<h2 id="but-it-keeps-things-organized">But It Keeps Things Organized!</h2>

<p>I regularly hear people express that small/nested namespaces “keep things
organized.” Putting things in their place feels right - why lump together
something like <code class="highlighter-rouge">StrCat()</code> and <code class="highlighter-rouge">make_unique()</code> other than being in Abseil these
have nothing to do with one another! Wouldn’t an <code class="highlighter-rouge">absl::strings::utilities</code>
namespace help differentiate from <code class="highlighter-rouge">absl::smart_ptrs</code>?</p>

<p>In other languages this would probably be good - better organization with no
downside. However, because of how lookup works (expanding into successive layers
of containing namespace scopes) your fine-grained namespace is impacted by every
symbol (and sub-namespace) added in every parent namespace. That is: while you
don’t exactly “contain” the names from parent namespaces, name/namespace
collisions matter nearly as much as if you do. Small/deeply-nested namespaces
don’t <em>shield</em> you from this, they <em>exacerbate</em> it.</p>

<h2 id="best-practices">Best Practices</h2>

<p>Practically speaking, the following is the best we can do given the
realities of most codebases:</p>

<ul>
  <li>Have a database of some form for a codebase to identify the unique namespaces.</li>
  <li>When introducing a new namespace, use that database and introduce it as
a top-level.</li>
  <li>If for some reason the above is impossible, never <em>ever</em> introduce a
sub-namespace that matches a well-known top-level namespace. No
sub-namespaces for <code class="highlighter-rouge">absl</code>, <code class="highlighter-rouge">testing</code>, <code class="highlighter-rouge">util</code>, etc. Try to give
sub-namespaces unique names that are unlikely to collide with future
top-levels.</li>
  <li>When declaring namespace aliases and using-declarations, use fully qualified
names, unless you are referring to a name inside the current namespace, as
per <a href="/tips/119">TotW 119</a>.</li>
  <li>For code in <code class="highlighter-rouge">util</code> or other commonly-abused namespaces, try to avoid full
qualification, but qualify if necessary.</li>
</ul>

<p>The advice in <a href="/tips/119">TotW 119</a> also helps, for <code class="highlighter-rouge">.cc</code> files: our concern with
fully-qualifying is not that it is bad, but that it is <em>weird</em> compared to C++
code in the rest of the world. Limited use in using-declarations strikes an
acceptable balance. However, even complete adherence to this suggestion doesn’t
fully mitigate the dangers from unqualified name lookup because we still have
header files and don’t want to fully qualify every symbol in every header.</p>

</div>

<div id="toc" class="col-sm-1"></div>
<br />
<a href="http://feeds.feedburner.com/abseilio"
    title="Subscribe to Abseil Blog &amp; Tips"
    rel="alternate"
    type="application/rss+xml">
    <img src="//feedburner.google.com/fb/images/pub/feed-icon32x32.png"
         alt="Subscribe to the Abseil Blog" style="border:0;">
    </img>
</a>
</div>
</div>
</div>




<footer>
    <div class="container">
        <div class="left-links">
            <img src="/img/typography_white.png" style="height:24px;"/>
            <p class="description">&copy;2017 Abseil | Live at Head</p>
        </div>
        <div class="right-links">
            <div class="col-md-4 col-sm-4 col-xs-12 footer-documentation">
                <ul class="toggle">
                    <a href="/about/"><p class="right-link-headers">About Abseil</p></a>
                    <li><a href="/about/intro"><p>Introduction</p></a></li>
                    <li><a href="/about/philosophy"><p>Philosophy</p></a></li>
                    <li><a href="/about/compatibility"><p>Compatibility</p></a></li>
                    <li><a href="/about/design/"><p>Design Notes</p><a></li>
                 </ul>
            </div>
            <hr class="footer-sections" />
            <div class="col-md-3 col-sm-3 col-xs-12 footer-resources">
                <ul class="toggle">
                    <a href="/docs/"><p class="right-link-headers">Dev Guides</p></a>
                    <li><a href="/docs/cpp.html"><p>C++</p></a></li>
                    <li><a href="/blog/"><p>Abseil Blog</p></a></li>
                </ul>
                </ul>
            </div>
            <hr class="footer-sections" />
            <div class="col-md-5 col-sm-5 col-xs-12 footer-community">
                <ul class="toggle">
                    <a href="/community/"><p class="right-link-headers">Community</p></a>
                    <li><a href="https://github.com/abseil/" target="_blank"><p class="github community-links">GitHub</p></a></li>
                    <li><a href="https://twitter.com/abseilio" target="_blank"><p class="twitter community-links">Twitter</p></a></li>
                    <li><a href="http://stackoverflow.com/tags/abseil/" target="_blank"><p class="stack-overflow community-links">Stack Overflow</p></a></li>
                </ul>
            </div>
        </div>
    </div>
</footer>


    <script src="/libs/bootstrap/js/bootstrap.min.js"></script>
    <!-- Include SlickJS for carousel -->
    <script src="/js/slick.min.js"></script>
    <script src="/js/jquery.visible.min.js"></script>
    <!-- Include the common site javascript -->
    <script src="/js/common.js" type="text/javascript" charset="utf-8"></script>
    <!-- GA -->
    <script src="/js/waves.js"></script>
    <script src="/js/buttons.js"></script>
    
    

    
	
	<!-- Global Site Tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-106933809-1"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments)};
	  gtag('js', new Date());

	  gtag('config', 'UA-106933809-1');
	</script>

  </body>
</html>
