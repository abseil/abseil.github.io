<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Software Engineering at Google</title>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> </script>
    <link rel="stylesheet" type="text/css" href="theme/html/html.css">
  </head>
  <body data-type="book">
    <section xmlns="http://www.w3.org/1999/xhtml" data-type="chapter" id="version_control_and_branch_management">
<h1>Version Control and Branch Management</h1>

<p class="byline">Written by Titus Winters</p>

<p class="byline">Edited by Lisa Carey</p>

<p>Perhaps no software engineering tool is quite as universally adopted throughout the industry as version control. <a contenteditable="false" data-primary="version control" data-type="indexterm" id="ix_verctl">&nbsp;</a>One can hardly imagine any software organization larger than a few people that doesn’t rely on a formal Version Control System (VCS) to manage its source code and coordinate activities between engineers.<a contenteditable="false" data-primary="VCSs (version control systems)" data-seealso="version control" data-type="indexterm" id="id-RRUbsph5">&nbsp;</a>&nbsp;</p>

<p>In this chapter, we’re going to look at why the use of version control has become such an unambiguous norm in software engineering, and we describe the various possible approaches to version control and branch management, including how we do it at scale across all of Google. We’ll also examine the pros and cons of various approaches; although we believe everyone should use version control, some version control policies <a contenteditable="false" data-primary="trunk-based development" data-type="indexterm" id="id-RRUOCJI5">&nbsp;</a>and processes might<a contenteditable="false" data-primary="DevOps" data-secondary="trunk-based development popularized by" data-type="indexterm" id="id-oOU3s2Ik">&nbsp;</a> work better for your organization (or in general) than others. In particular, we find “trunk-based development” as popularized by DevOps<sup><a data-type="noteref" id="ch01fn148-marker" href="#ch01fn148">1</a></sup> (one repository, no dev branches) to be a particularly scalable policy approach, and we’ll provide some suggestions as to why that is.</p>

<section data-type="sect1" id="what_is_version_controlquestion_markone">
<h1>What Is Version Control?</h1>

<div data-type="note" id="id-o4S3szck"><h6>Note</h6>
<p>This section might be a little basic for many readers: use of version control is, after all, fairly ubiquitous. If you want to skip ahead, we suggest jumping to the section <a data-type="xref" href="#source_of_truth">Source of Truth</a>.</p>
</div>

<p>A VCS is a system<a contenteditable="false" data-primary="version control" data-secondary="about" data-type="indexterm" id="id-agURC0Hgcy">&nbsp;</a> that tracks revisions (versions) of files over time. A VCS maintains some metadata about the set of files being managed, and collectively a copy of the files and metadata is called a repository<sup><a data-type="noteref" id="ch01fn150-marker" href="#ch01fn150">2</a></sup> (repo for short). <a contenteditable="false" data-primary="repositories" data-type="indexterm" id="id-dBUOHgH2c1">&nbsp;</a>A VCS helps coordinate the activities of teams by allowing multiple developers to work on the same set of files simultaneously. Early VCSs did this by granting one person at a time the right to edit a file—that style of locking is enough to establish sequencing (an agreed-upon “which is newer,” an important feature of VCS). More advanced systems ensure that changes to a <em>collection</em> of files submitted at once are treated as a single unit (<em>atomicity</em> when a logical change touches multiple files).<a contenteditable="false" data-primary="atomicity for commits in VCSs" data-type="indexterm" id="id-g8U2cGH1c1">&nbsp;</a> Systems like CVS (a popular VCS from the 90s) that didn’t have this atomicity for a commit were subject to corruption and lost changes.<a contenteditable="false" data-primary="CVS (Concurrent Versions System)" data-type="indexterm" id="id-LRUDTdHQcN">&nbsp;</a> Ensuring atomicity removes the chance of previous <a contenteditable="false" data-primary="changes to code" data-secondary="tracking in VCSs" data-type="indexterm" id="id-2mUDf2Hgc9">&nbsp;</a>changes being overwritten unintentionally, but requires tracking which version was last synced to—at commit time, the commit is rejected if any file in the commit has been modified at head since the last time the local developer synced. Especially in such a change-tracking VCS, a developer’s working copy of the managed files will therefore need metadata of its own. Depending on the design of the VCS, this copy of the repository can be a repository itself, or might contain a reduced amount of metadata—such a reduced copy is usually a “client” or “workspace.”</p>

<p>This seems like a lot of complexity: why is a VCS necessary? What is it about this sort of tool that has allowed it to become one of the few nearly universal tools for software development and software engineering?</p>

<p>Imagine for a moment working without a VCS. For a (very) small group of distributed developers working on a project of limited scope without any understanding of version control, the simplest and lowest-infrastructure solution is to just pass copies of the project back and forth. This works best when edits are nonsimultaneous (people are working in different time zones, or at least with different working hours). If there’s any chance for people to not know which version is the most current, we immediately have an annoying problem: tracking which version is the most up to date. Anyone who has attempted to collaborate in a non-networked environment will likely recall the horrors of copying back-and-forth files named <em>Presentation v5 - final - redlines - Josh’s version v2</em>. And as we shall see, when there isn’t a single agreed-upon source of truth, collaboration becomes high friction and error prone.</p>

<p>Introducing shared storage requires slightly more infrastructure (getting access to shared storage), but provides an easy and obvious solution. Coordinating work in a shared drive might suffice for a while with a small enough number of people but still requires out-of-band collaboration to avoid overwriting one another’s work. Further, working directly in that shared storage means that any development task that doesn’t keep the build working continuously will begin to impede everyone on the team—if I’m making a change to some part of this system at the same time that you kick off a build, your build won’t work. Obviously, this doesn’t scale well.</p>

<p>In practice, lack<a contenteditable="false" data-primary="file locking in VCSs" data-type="indexterm" id="id-enUACjTRcK">&nbsp;</a> of file locking and lack of <a contenteditable="false" data-primary="merges" data-secondary="merge tracking in VCSs" data-type="indexterm" id="id-g8UpsaT1c1">&nbsp;</a>merge tracking will inevitably lead to collisions and work being overwritten. Such a system is very likely to introduce out-of-band coordination to decide who is working on any given file. If that file-locking is encoded in software, we’ve begun reinventing an early-generation version control like RCS (among others). <a contenteditable="false" data-primary="RCS (Revision Control System)" data-type="indexterm" id="id-LRU5H9TQcN">&nbsp;</a>After you realize that granting write permissions a file at a time is too coarse grained and you begin wanting line-level tracking—we’re definitely reinventing version control. It seems nearly inevitable that we’ll want some structured mechanism to govern these collaborations. Because we seem to just be reinventing the wheel in this hypothetical, we might as well use an off-the-shelf tool.</p>

<section data-type="sect2" id="why_is_version_control_importantquestio">
<h2>Why Is Version Control Important?</h2>

<p>While version control is practically <a contenteditable="false" data-primary="version control" data-secondary="importance of" data-type="indexterm" id="ix_verctlimp">&nbsp;</a>ubiquitous now, this was not always the case.<a contenteditable="false" data-primary="VCSs (version control systems)" data-secondary="early" data-type="indexterm" id="id-2mU1slsWf6c1">&nbsp;</a> The very first VCSs date back to the 1970s (SCCS) and 1980s (RCS)—many years later than the first references to software engineering as a distinct discipline. Teams participated in “the <a href="https://arxiv.org/pdf/1805.02742.pdf">multiperson development of multiversion software</a>” before the industry had any formal notion of version control. Version control evolved as a response to the novel challenges of digital collaboration. It took decades of evolution and dissemination for reliable, consistent use of version control to evolve into the norm that it is today.<sup><a data-type="noteref" id="ch01fn151-marker" href="#ch01fn151">3</a></sup> So how did it become so important, and, given that it seems like a self-evident solution, why might anyone resist the idea of VCS?</p>

<p>Recall that<a contenteditable="false" data-primary="software engineering" data-secondary="programming versus" data-tertiary="version control systems and" data-type="indexterm" id="id-2mU9C2HWf6c1">&nbsp;</a> software engineering is programming integrated over time; we’re drawing a distinction (in dimensionality) between the instantaneous production of source code and the act of maintaining that product over time. That basic distinction goes a long way to explaining the importance of, and hesitation toward, VCS: at the most fundamental level, version control is the engineer’s primary tool for managing the interplay between raw source and time.<a contenteditable="false" data-primary="time" data-secondary="in version control systems" data-type="indexterm" id="id-BRUesdHdfRcb">&nbsp;</a> We can conceptualize VCS as a way to extend a standard filesystem. <a contenteditable="false" data-primary="filesystems, VCS as way to extend" data-type="indexterm" id="id-nMUzHdHQf3co">&nbsp;</a>A filesystem is a mapping from filename to contents. A VCS extends that to provide a mapping from (filename, time) to contents, along with the metadata necessary to track last sync points and audit history. Version control makes the consideration of time an explicit part of the operation: unnecessary in a programming task, critical in a software engineering task.<a contenteditable="false" data-primary="branch management" data-secondary="branch names in VCSs" data-type="indexterm" id="id-41UDhyHdfyce">&nbsp;</a> In most cases, a VCS also allows for an extra input to that mapping (a branch name) to allow for parallel mappings; thus:</p>

<pre data-type="programlisting">
VCS<span>(</span>filename<span>,</span> time<span>,</span> branch<span>)</span> <span>=&gt;</span> file contents</pre>

<p>In the default usage, that branch input will have a commonly understood default: we call that “head,” “default,” or “trunk” to denote main branch.</p>

<p>The (minor) remaining hesitation toward consistent use of version control comes almost directly from conflating programming and software engineering—we teach programming, we train programmers, we interview for jobs based on programming problems and techniques. It’s perfectly reasonable for a new hire, even at a place like Google, to have little or no experience with code that is worked on by more than one person or for more than a couple weeks. Given that experience and understanding of the problem, version control seems like an alien solution. Version control is solving a problem that our new hire hasn’t necessarily experienced: an “undo,” not for a single file but for an entire project, adding a lot of complexity for sometimes nonobvious benefits.</p>

<p>In some software groups, the same result plays out when management views the job of the techies as “software development” (sit down and write code) rather than “software engineering” (produce code, keep it working and useful for some extended period). With a mental model of programming as the primary task and little understanding of the interplay between code and the passage of time, it’s easy to see something described as “go back to a previous version to undo a mistake” as a weird, high-overhead luxury.</p>

<p>In addition to allowing separate storage and reference to versions over time, version control helps us bridge the gap between single-developer and multideveloper processes. In practical terms, this is why version control is so critical to software engineering, because it allows us to scale up teams and organizations, even though we use it only infrequently as an “undo” button. Development is inherently a branch-and-merge process, both when coordinating between multiple developers or a single developer at different points in time. <a contenteditable="false" data-primary="merges" data-secondary="branch-and-merge process, development as" data-type="indexterm" id="id-NRU8CJfBfxc2">&nbsp;</a>A VCS removes the question of “which is more recent?” Use of modern version control automates error-prone operations like tracking which set of changes have been applied. Version control is how we coordinate between multiple developers and/or multiple points in time.</p>

<p>Because VCS has become so thoroughly embedded in the process of software engineering, even legal and regulatory practices have caught up. VCS allows a formal record of every change to every line of code, which is increasingly necessary for satisfying audit requirements. When mixing between in-house development and appropriate use of third-party sources, VCS helps track provenance and origination for every line of code.</p>

<p>In addition to the technical and regulatory aspects of tracking source over time and handling sync/branch/merge operations, version control triggers some nontechnical changes in behavior. The ritual of committing to version control and producing a commit log is a trigger for a moment of reflection: what have you accomplished since your last commit? Is the source in a state that you’re happy with? The moment of introspection associated with committing, writing up a summary, and marking a task complete might have value on its own for many people. The start of the commit process is a perfect time to run through a checklist, run static analyses (see <a data-type="xref" href="ch20.html#static_analysis-id00082">Static Analysis</a>), check test coverage, run tests and dynamic analysis, and so on.</p>

<p>Like any process, version control comes with some overhead: someone must configure and manage your version control system, and individual developers must use it. But make no mistake about it: these can almost always be pretty cheap. Anecdotally, most experienced software engineers will instinctively use version control for any project that lasts more than a day or two, even for a single-developer project. The consistency of that result argues that the trade-off in terms of value (including risk reduction) versus overhead must be a pretty easy one. But we’ve promised to acknowledge that context matters and to encourage engineering leaders to think for themselves. It is always worth considering alternatives, even on something as fundamental as version control.</p>

<p>In truth, it’s difficult to envision any task that can be considered modern software engineering that doesn’t immediately adopt a VCS. Given that you understand the value and need for version control, you are likely now asking what type of version control you need.<a contenteditable="false" data-primary="version control" data-secondary="importance of" data-startref="ix_verctlimp" data-type="indexterm" id="id-KRUwC5u6f8cL">&nbsp;</a></p>
</section>

<section data-type="sect2" id="centralized_vcs_versus_distributed_vcs">
<h2>Centralized VCS Versus Distributed VCS</h2>

<p>At the most simplistic level, all modern VCSs are equivalent<a contenteditable="false" data-primary="version control" data-secondary="centralized vs. distributed VCSs" data-type="indexterm" id="ix_verctlcd">&nbsp;</a> to one another: so long as your system has a notion of atomically committing changes to a batch of files, everything else is just UI. You could build the same general semantics (not workflow) of any modern VCS out of another one and a pile of simple shell scripts. Thus, arguing about which VCS is “better” is primarily a matter of user experience—the core functionality is the same, the differences come in user experience, naming, edge-case features, and performance. Choosing a VCS is like choosing a filesystem format: when choosing among a modern-enough format, the differences are fairly minor, and the more important question by far is the content you fill that system with and the way you <em>use</em> it. However, major architectural differences in VCSs can make configuration, policy, and scaling decisions easier or more difficult, so it’s important to be aware of the big architectural differences, chiefly the decision between centralized or decentralized.</p>

<section data-type="sect3" id="centralized_vcs">
<h3>Centralized VCS</h3>

<p>In centralized VCS implementations, the model is one of a single central repository (likely stored on some shared compute resource for your organization).<a contenteditable="false" data-primary="centralized version control systems (VCSs)" data-type="indexterm" id="id-nMUMCnsKHqtdcq">&nbsp;</a> Although a developer can have files checked out and accessible on their local workstation, operations that interact on the version control status of those files need to be communicated to the central server (adding files, syncing, updating existing files, etc.). Any code that is committed by a developer is committed into that central repository. The first VCS implementations were all centralized VCSs.</p>

<p>Going back to the 1970s and early 1980s, we see that the earliest of these VCSs, such as RCS, focused on locking and preventing multiple simultaneous edits.<a contenteditable="false" data-primary="RCS (Revision Control System)" data-type="indexterm" id="id-41UECyH0HMtocN">&nbsp;</a> You could copy the contents<a contenteditable="false" data-primary="file locking in VCSs" data-type="indexterm" id="id-8RU7skHwHxtAcp">&nbsp;</a> of a repository, but if you wanted to edit a file, you might need to acquire a lock, enforced by the VCS, to ensure that only you are making edits. &nbsp;When you’ve completed an edit, you release the lock. The model worked fine when any given change was a quick thing, or if there was rarely more than one person that wanted the lock for a file at any given time. Small edits like tweaking config files worked OK, as did working on a small team that either kept disjointed working hours or that rarely worked on overlapping files for extended periods. This sort of simplistic locking has inherent problems with scale: it can work fine for a few people, but has the potential to fall apart with larger groups if any of those locks become contended.<sup><a data-type="noteref" id="ch01fn152-marker" href="#ch01fn152">4</a></sup></p>

<p>As a response to this scaling problem, the VCSs that were popular through the 90s and early 2000s operated at a higher level. These more modern centralized VCSs avoid the exclusive locking but track which changes you’ve synced, requiring your edit to be based on the most-current version of every file in your commit.<a contenteditable="false" data-primary="CVS (Concurrent Versions System)" data-type="indexterm" id="id-8RU5CEhwHxtAcp">&nbsp;</a> CVS wrapped and refined RCS by (mostly) operating on batches of files at a time and allowing multiple developers to check out a file at the same time: so long as your base version contained all of the changes in the repository, you’re allowed to commit.<a contenteditable="false" data-primary="Subversion" data-type="indexterm" id="id-NRUGs0hDH4tnco">&nbsp;</a> Subversion advanced further by <a contenteditable="false" data-primary="atomicity for commits in VCSs" data-type="indexterm" id="id-kEULHEh2HDt9c5">&nbsp;</a>providing true atomicity for commits, version tracking, and better tracking for unusual operations (renames, use of symbolic links, etc.). The centralized repository/checked-out client model continues today within Subversion as well as most commercial VCSs.</p>
</section>

<section data-type="sect3" id="distributed_vcs">
<h3>Distributed VCS</h3>

<p>Starting in the mid-2000s, many popular VCSs followed the Distributed Version Control System (DVCS) paradigm, seen<a contenteditable="false" data-primary="distributed version control systems (DVCSs)" data-type="indexterm" id="id-41UECRsohMtocN">&nbsp;</a> in systems like Git and Mercurial. The <span class="keep-together">primary</span> conceptual difference between DVCS and more traditional centralized VCS (Subversion, CVS) is the question: “Where can you commit?” or perhaps, “Which copies of these files count as a repository?”</p>

<p>A DVCS world does not enforce the constraint of a central repository: if you have a copy (clone, fork) of the repository, you have a repository that you can commit to as well as all of the metadata necessary to query for information about things like revision history. A standard workflow is to clone some existing repository, make some edits, commit them locally, and then push some set of commits to another repository, which may or may not be the original source of the clone. Any notion of centrality is purely conceptual, a matter of policy, not fundamental to the technology or the underlying protocols.<a contenteditable="false" data-primary="DVCSs" data-see="distributed version control systems" data-type="indexterm" id="id-8RU5CkH9hxtAcp">&nbsp;</a></p>

<p>The DVCS model allows for better offline operation and collaboration without inherently declaring one particular repository to be the source of truth. One repository isn’t necessary “ahead” or “behind” because changes aren’t inherently projected into a linear timeline. However, considering common <em>usage</em>, both the centralized and DVCS models are largely interchangeable: whereas a centralized VCS provides a clearly defined central repository through technology, most DVCS ecosystems define a central repository for a project as a matter of policy.<a contenteditable="false" data-primary="repositories" data-secondary="central repository for a project in DVCSs" data-type="indexterm" id="id-kEUlsEhGhDt9c5">&nbsp;</a> That is, most DVCS projects are built around one conceptual source of truth (a particular repository on GitHub, for instance). DVCS models tend to assume a more distributed use case and have found particularly strong adoption in the open source world.</p>

<p>Generally speaking, the dominant source control <a contenteditable="false" data-primary="Git" data-type="indexterm" id="id-kEUmCdIGhDt9c5">&nbsp;</a>system today<a contenteditable="false" data-primary="source control" data-secondary="Git as dominant system" data-type="indexterm" id="id-6RUJsxIqh2t7cv">&nbsp;</a> is Git, which implements DVCS.<sup><a data-type="noteref" id="ch01fn153-marker" href="#ch01fn153">5</a></sup> When in doubt, use that—there’s some value in doing what everyone else does. If your use cases are expected to be unusual, gather some data and evaluate the trade-offs.</p>

<p>Google has a complex relationship with DVCS: our main repository is based on a (massive) custom in-house centralized VCS. There are periodic attempts to integrate more standard external options and to match the workflow that our engineers (especially Nooglers) have come to expect from external development. Unfortunately, those attempts to move toward more common tools like Git have been stymied by the sheer size of the codebase and userbase, to say nothing of Hyrum’s Law effects tying us to a particular VCS and interface for that VCS.<sup><a data-type="noteref" id="ch01fn154-marker" href="#ch01fn154">6</a></sup> This is perhaps not surprising: most existing tools don’t scale well with 50,000 engineers and tens of millions of <span class="keep-together">commits.</span><sup><a data-type="noteref" id="ch01fn155-marker" href="#ch01fn155">7</a></sup> The DVCS model, which often (but not always) includes transmission of history and metadata, requires a lot of data to spin up a repository to work out of.</p>

<p>In our workflow, centrality and in-the-cloud storage for the codebase seem to be critical to scaling. The DVCS model is built around the idea of downloading the entire codebase and having access to it locally. In practice, over time and as your organization scales up, any given developer is going to operate on a relatively smaller percentage of the files in a repository, and a small fraction of the versions of those files. As we grow (in file count and engineer count), that transmission becomes almost entirely waste. The only need for locality for most files occurs when building, but distributed (and reproducible) build systems seem to scale better for that task as well (see <span class="keep-together"><a data-type="xref" href="ch18.html#build_systems_and_build_philosophy">Build Systems and Build Philosophy</a></span>).<a contenteditable="false" data-primary="version control" data-secondary="centralized vs. distributed VCSs" data-startref="ix_verctlcd" data-type="indexterm" id="id-KRUJsJTqhBtgc4">&nbsp;</a></p>
</section>
</section>

<section data-type="sect2" id="source_of_truth">
<h2>Source of Truth</h2>

<p>Centralized VCSs (Subversion, CVS, Perforce, etc.) bake<a contenteditable="false" data-primary="source of truth" data-type="indexterm" id="ix_srctr">&nbsp;</a> the source-of-truth notion into the very design of the system: whatever is most recently committed at trunk is the current version.<a contenteditable="false" data-primary="centralized version control systems (VCSs)" data-secondary="source of truth in" data-type="indexterm" id="id-nMUxsnsxS3co">&nbsp;</a><a contenteditable="false" data-primary="version control" data-secondary="source of truth" data-type="indexterm" id="ix_verctlsot">&nbsp;</a> When a developer goes to check out the project, by default that trunk version is what they will be presented with. Your changes are “done” when they have been recommitted on top of that version.</p>

<p>However, unlike centralized VCS, there is no <em>inherent</em> notion of which copy of the distributed <a contenteditable="false" data-primary="distributed version control systems (DVCSs)" data-secondary="source of truth" data-type="indexterm" id="id-41U7syHjSyce">&nbsp;</a>repository is the single source of truth in DVCS systems. In theory, it’s possible to pass around commit tags and PRs with no centralization or coordination, allowing disparate branches of development to propagate unchecked, and thus risking a conceptual return to the world of <em>Presentation v5 - final - redlines - Josh’s version v2</em>. Because of this, DVCS requires more explicit policy and norms than a centralized VCS does.</p>

<p>Well-managed projects using DVCS declare one specific branch in one specific repository to be the source of truth and thus avoid the more chaotic possibilities. We see this in practice with the spread of hosted DVCS solutions like GitHub or GitLab—users can clone and fork the repository for a project, but there is still a single primary repository: things are “done” when they are in the trunk branch on that repository.</p>

<p>It isn’t an accident that centralization and Source of Truth has crept back into the usage even in a DVCS world. To help illustrate just how important this Source of Truth idea is, let’s imagine what happens when we don’t have a clear source of truth.</p>

<section data-type="sect3" id="scenario_no_clear_source_of_truth">
<h3>Scenario: no clear source of truth</h3>

<p>Imagine that your team adheres to the DVCS philosophy enough to avoid defining a specific branch+repository as the ultimate source of truth.<a contenteditable="false" data-primary="distributed version control systems (DVCSs)" data-secondary="scenario, no clear source of truth" data-type="indexterm" id="id-kEUmCRs5cqS9c5">&nbsp;</a><a contenteditable="false" data-primary="source of truth" data-secondary="scenario, no clear source of truth" data-type="indexterm" id="id-6RUJs3sAc8S7cv">&nbsp;</a></p>

<p>In some respects, this is reminiscent of the <em>Presentation v5 - final - redlines - Josh’s version v2</em> model—after you pull from a teammate’s repository, it isn’t necessarily clear which changes are present and which are not. In some respects, it’s better than that because the DVCS model tracks the merging of individual patches at a much finer granularity than those ad hoc naming schemes, but there’s a difference between the DVCS knowing <em>which</em> changes are incorporated and every engineer being sure they have <em>all</em> the past/relevant changes represented.</p>

<p>Consider what it takes to ensure that a release build includes all of the features that have been developed by each developer for the past few weeks. What (noncentralized, scalable) mechanisms are there to do that? Can we design policies that are fundamentally better than having everyone sign off? Are there any that require only sublinear human effort as the team scales up? Is that going to continue working as the number of developers on the team scales up? As far as we can see: probably not. Without a central Source of Truth, someone is going to keep a list of which features are potentially ready to be included in the next release. Eventually that bookkeeping is reproducing the model of having a centralized Source of Truth.</p>

<p>Further imagine: when a new developer joins the team, where do they get a fresh, known-good copy of the code?</p>

<p>DVCS enables a lot of great workflows and interesting usage models. But if you’re concerned with finding a system that requires sublinear human effort to manage as the team grows, it’s pretty important to have one repository (and one branch) actually defined to be the ultimate source of truth.</p>

<p>There is some relativity in that Source of Truth. That is, for a given project, that Source of Truth might be different for a different organization. This caveat is important: it’s reasonable for engineers at Google or Red Hat to have different Sources of Truth for <a contenteditable="false" data-primary="Linux" data-secondary="kernel patches, sources of truth for" data-type="indexterm" id="id-MRUvC1TQcoSEcO">&nbsp;</a>Linux Kernel patches, still different than Linus (the Linux Kernel maintainer) himself would. DVCS works fine when organizations and their Sources of Truth are hierarchical (and invisible to those outside the organization)—that is perhaps the most practically useful effect of the DVCS model. A Red Hat engineer can commit to the local Source of Truth repository, and changes can be pushed from there upstream periodically, while Linus has a completely different notion of what is the Source of Truth. So long as there is no choice or uncertainty as to where a change should be pushed, we can avoid a large class of chaotic scaling problems in the DVCS model.</p>

<p>In all of this thinking, we’re assigning special significance to the trunk branch. But of course, “trunk” in your VCS is only the technology default, and an organization can choose different policies on top of that. Perhaps the default branch has been abandoned and all work actually happens on some custom development branch—other than needing to provide a branch name in more operations, there’s nothing inherently broken in that approach; it’s just nonstandard. There’s an (oft-unspoken) truth when discussing version control: the technology is only one part of it for any given organization; there is almost always an equal amount of policy and usage convention on top of that.</p>

<p>No topic in version control has more policy and convention than the discussion of how to use and manage branches. We look at branch management in more detail in the next section.<a contenteditable="false" data-primary="source of truth" data-startref="ix_srctr" data-type="indexterm" id="id-QRU6CAtVc2SJcl">&nbsp;</a><a contenteditable="false" data-primary="version control" data-secondary="source of truth" data-startref="ix_verctlsot" data-type="indexterm" id="id-ybUmsatwcjS4ck">&nbsp;</a></p>
</section>
</section>

<section data-type="sect2" id="version_control_versus_dependency_manag">
<h2>Version Control Versus Dependency Management</h2>

<p>There’s a lot of conceptual similarity between discussions of version control policies and dependency management (see <a data-type="xref" href="ch21.html#dependency_management">Dependency Management</a>). <a contenteditable="false" data-primary="dependencies" data-secondary="dependency management versus version control" data-type="indexterm" id="id-41U7sRsLUyce">&nbsp;</a><a contenteditable="false" data-primary="version control" data-secondary="versus dependency management" data-secondary-sortas="dependency" data-type="indexterm" id="id-8RUnHesKU0cm">&nbsp;</a>The differences are primarily in two forms: VCS policies are largely about how you manage your own code, and are usually much finer grained. Dependency management is more challenging because we primarily focus on projects managed and controlled by other organizations, at a higher granularity, and these situations mean that you don’t have perfect control. We’ll discuss a lot more of these high-level issues later<a contenteditable="false" data-primary="version control" data-startref="ix_verctl" data-type="indexterm" id="id-NRUmhEsbUxc2">&nbsp;</a> in the book.&nbsp;</p>
</section>
</section>

<section data-type="sect1" id="branch_management">
<h1>Branch Management</h1>

<p>Being able to track different revisions in version control opens up a variety of different approaches for how to<a contenteditable="false" data-primary="branch management" data-type="indexterm" id="ix_brnch">&nbsp;</a> manage those different versions.<a contenteditable="false" data-primary="version control" data-secondary="branch management" data-type="indexterm" id="ix_VCbrn">&nbsp;</a> Collectively, these different approaches fall under the term <em>branch management</em>, in contrast to a single “trunk.”</p>

<section data-type="sect2" id="work_in_progress_is_akin_to_a_branch">
<h2>Work in Progress Is Akin to a Branch</h2>

<p>Any discussion that an organization has about branch management policies ought to at least acknowledge<a contenteditable="false" data-primary="branch management" data-secondary="work in progress is akin to a branch" data-type="indexterm" id="id-dBUBC3sEHWTM">&nbsp;</a> that every piece of work-in-progress in the organization is equivalent to a branch. This is more explicitly the case with a DVCS in which developers are more likely to make numerous local staging commits before pushing back to the upstream Source of Truth.<a contenteditable="false" data-primary="source of truth" data-secondary="work in progress and branches" data-type="indexterm" id="id-5RUBsWspH3TD">&nbsp;</a><a contenteditable="false" data-primary="centralized version control systems (VCSs)" data-secondary="uncommitted local changes and committed changes on a branch" data-type="indexterm" id="id-enUbHOsEHzTM">&nbsp;</a>&nbsp; This is still true of centralized VCSs: uncommitted local changes aren’t conceptually different than committed changes on a branch, other than potentially being more difficult to find and diff against. Some centralized systems even make this explicit.<a contenteditable="false" data-primary="Perforce, revision mumbers for a change" data-type="indexterm" id="id-g8UEhesEHmTv">&nbsp;</a> For example, when using Perforce, every change is given two revision numbers: one indicating the implicit branch point where the change was created, and one indicating where it was recommitted, as illustrated in <a data-type="xref" href="#two_revision_numbers_in_perforce">Figure 16-1</a>. Perforce users can query to see who has outstanding changes to a given file, inspect the pending changes in other users' uncommitted changes, and more.</p>

<figure id="two_revision_numbers_in_perforce"><img alt="Two revision numbers in Perforce" src="images/seag_1601.png">
<figcaption><span class="label">Figure 16-1. </span>Two revision numbers in Perforce</figcaption>
</figure>

<p>This “uncommitted work is akin to a branch” idea is particularly relevant when thinking about refactoring tasks. <a contenteditable="false" data-primary="refactorings" data-secondary="uncommitted work as akin to a branch" data-type="indexterm" id="id-enUACdhEHzTM">&nbsp;</a>Imagine a developer being told, “Go rename Widget to OldWidget.” Depending on an organization’s branch management policies and understanding, what counts as a branch, and which branches matter, this could have several interpretations:</p>

<ul>
	<li>
	<p>Rename Widget on the trunk branch in the Source of Truth repository</p>
	</li>
	<li>
	<p>Rename Widget on all branches in the Source of Truth repository</p>
	</li>
	<li>
	<p>Rename Widget on all branches in the Source of Truth repository, and find all devs with outstanding changes to files that reference Widget</p>
	</li>
</ul>

<p>If we were to speculate, attempting to support that “rename this everywhere, even in outstanding changes” use case is part of why commercial centralized VCSs tend to track things like “which engineers have this file open for editing?” (We don’t think this is a scalable way to <em>perform</em> a refactoring task, but we understand the point of view.)</p>
</section>

<section data-type="sect2" id="dev_branches">
<h2>Dev Branches</h2>

<p>In the age before<a contenteditable="false" data-primary="branch management" data-secondary="dev branches" data-type="indexterm" id="ix_brnchdev">&nbsp;</a> consistent unit testing (see <a data-type="xref" href="ch11.html#testing_overview">Testing Overview</a>), when the <a contenteditable="false" data-primary="dev branches" data-type="indexterm" id="ix_devbr">&nbsp;</a>introduction of any given change had a high risk of regressing functionality elsewhere in the system, it made sense to treat <em>trunk</em> specially. “We don’t commit to trunk,” your Tech Lead might say, “until new changes have gone through a full round of testing. Our team uses feature-specific development branches instead.”</p>

<p>A development branch (usually “dev branch”) is a halfway point between “this is done but not committed” and “this is what new work is based on.” The problem that these are<a contenteditable="false" data-primary="product stability, dev branches and" data-type="indexterm" id="id-enUACBH3hzTM">&nbsp;</a> attempting to solve (instability of the product) is a legitimate one—but one that we have found to be solved far better with more extensive use of tests, Continuous Integration (CI) (see <a data-type="xref" href="ch23.html#continuous_integration">Continuous Integration</a>), and quality enforcement practices like thorough code review.<a contenteditable="false" data-primary="continuous integration (CI)" data-secondary="dev branches and" data-type="indexterm" id="id-LRU5HdHAhmT3">&nbsp;</a></p>

<p>We believe that a version control policy that makes extensive use of dev branches as a means toward product stability is inherently misguided. The same set of commits are going to be merged to trunk eventually.<a contenteditable="false" data-primary="merges" data-secondary="dev branches and" data-type="indexterm" id="id-g8UVC5hzhmTv">&nbsp;</a> Small merges are easier than big ones. Merges done by the engineer who authored those changes are easier than batching unrelated changes and merging later (which will happen eventually if a team is sharing a dev branch).<a contenteditable="false" data-primary="presubmits" data-secondary="testing on merges in dev branch" data-type="indexterm" id="id-LRUpsGhAhmT3">&nbsp;</a> If presubmit testing on the merge reveals any new problems, the same argument applies: it’s easier to determine whose changes are responsible for a regression if there is only one engineer involved. Merging a large dev branch implies that more changes are happening in that test run, making failures more difficult to isolate. Triaging and root-causing the problem is difficult; fixing it is even worse.</p>

<p>Beyond the lack of expertise and inherent problems in merging a single branch, there are significant scaling risks when relying on dev branches. This is a very common productivity drain for a software organization. When there are multiple branches being developed in isolation for long periods, coordinating merge operations becomes significantly more expensive (and possibly riskier) than they would be with trunk-based development.</p>

<section data-type="sect3" id="how_did_we_become_addicted_to_dev_branc">
<h3>How did we become addicted to dev branches?</h3>

<p>It’s easy to see how organizations fall into this trap: they see, “Merging this long-lived development branch reduced stability” and conclude, “Branch merges are risky.” Rather than solve that with “Better testing” and “Don’t use branch-based development strategies,” they focus on slowing down and coordinating the symptom: the branch merges.<a contenteditable="false" data-primary="merges" data-secondary="coordination of dev branch merging" data-type="indexterm" id="id-BRUGCQsMc8hDTW">&nbsp;</a> Teams begin developing new branches based on other in-flight branches. Teams working on a long-lived dev branch might or might not regularly have that branch synched with the main development branch. As the organization scales up, the number of development branches grows as well, and the more effort is placed on coordinating that branch merge strategy. Increasing effort is thrown at coordination of branch merges—a task that inherently doesn’t scale. Some unlucky engineer becomes the Build Master/Merge Coordinator/Content Management Engineer, focused on acting as the single point coordinator to merge all the disparate branches in the organization. Regularly scheduled meetings attempt to ensure that the organization has “worked out the merge strategy for the week.”<sup><a data-type="noteref" id="ch01fn156-marker" href="#ch01fn156">8</a></sup> The teams that aren’t chosen to merge often need to re-sync and retest after each of these large merges.</p>

<p>All of that effort in merging and retesting is <em>pure overhead</em>. The alternative requires a different<a contenteditable="false" data-primary="trunk-based development" data-type="indexterm" id="id-41U7syHQcWhWTN">&nbsp;</a> paradigm: trunk-based development, rely heavily on testing and CI, keep the build green, and disable incomplete/untested features at runtime. Everyone is responsible to sync to trunk and commit; no “merge strategy” meetings, no large/expensive merges. And, no heated discussions about which version of a library should be used—there can be only one. There must be a single Source of Truth. In the end, there will be a single revision used for a release: narrowing down to a single source of truth is just the “shift left” approach for identifying what is and is not being included.<a contenteditable="false" data-primary="branch management" data-secondary="dev branches" data-startref="ix_brnchdev" data-type="indexterm" id="id-8RUnHkH1c8hWTp">&nbsp;</a><a contenteditable="false" data-primary="dev branches" data-startref="ix_devbr" data-type="indexterm" id="id-NRUmh8HQcahzTo">&nbsp;</a></p>
</section>
</section>

<section data-type="sect2" id="release_branches">
<h2>Release Branches</h2>

<p>If the period <a contenteditable="false" data-primary="branch management" data-secondary="release branches" data-type="indexterm" id="id-enUACOslIzTM">&nbsp;</a>between<a contenteditable="false" data-primary="release branches" data-type="indexterm" id="id-g8Upses9ImTv">&nbsp;</a> releases (or the release lifetime) for a product is longer than a few hours, it may be sensible to create a release branch that represents the exact code that went into the release build for your product. If any critical flaws are discovered between the actual release of that product into the wild and the next release cycle, fixes can be cherry-picked (a minimal, targeted merge) from trunk to your release branch.</p>

<p>By comparison to dev branches, release branches are generally benign: it isn’t the technology of branches that is troublesome, it’s the usage. The primary difference between a dev branch and a release branch is the expected end state: a dev branch is expected to merge back to trunk, and could even be further branched by another team. A release branch is expected to be abandoned eventually.</p>

<p>In the highest-functioning technical organizations that Google’s DevOps Research and Assessment (DORA) organization has identified, release branches are practically nonexistent. <a contenteditable="false" data-primary="DevOps Research and Assessment (DORA)" data-secondary="research on release branches" data-type="indexterm" id="id-LRUjCGh8ImT3">&nbsp;</a>Organizations that have achieved Continuous Deployment (CD)—the ability to release from <a contenteditable="false" data-primary="continuous deployment (CD), release branches and" data-type="indexterm" id="id-2mU1snhVIET1">&nbsp;</a>trunk many times a day—likely tend to skip release branches: it’s much easier to simply add the fix and redeploy. Thus, cherry-picks and branches seem like unnecessary overhead. Obviously, this is more applicable to organizations that deploy digitally (such as web services and apps) than those that push any form of tangible release to customers; it is generally valuable to know exactly what has been pushed to customers.</p>

<p>That same DORA research also suggests a strong positive correlation between “trunk-based development,” “no long-lived dev branches,” and good technical outcomes.<a contenteditable="false" data-primary="trunk-based development" data-secondary="correlation with good technical outcomes" data-type="indexterm" id="id-2mU9CKIVIET1">&nbsp;</a> The underlying idea in both of those ideas seems clear: branches are a drag on productivity. In many cases we think complex branch and merge strategies are a perceived safety crutch—an attempt to keep trunk stable. As we see throughout this book, there are other ways to achieve that <a contenteditable="false" data-primary="branch management" data-startref="ix_brnch" data-type="indexterm" id="id-BRUes6IKI4Tb">&nbsp;</a>outcome.<a contenteditable="false" data-primary="version control" data-secondary="branch management" data-startref="ix_VCbrn" data-type="indexterm" id="id-nMUzHQIZIRTo">&nbsp;</a></p>
</section>
</section>

<section data-type="sect1" id="version_control_at_google">
<h1>Version Control at Google</h1>

<p>At Google, the vast majority of our source is managed in a single repository (monorepo) shared among roughly 50,000 engineers.<a contenteditable="false" data-primary="version control" data-secondary="at Google" data-type="indexterm" id="ix_VCGoo">&nbsp;</a> Almost all projects that are owned by Google live there, except large open source projects like Chromium and Android. This includes public-facing products like Search, Gmail, our advertising products, our Google Cloud Platform offerings, as well as the internal infrastructure necessary to support and develop all of those products.</p>

<p>We rely on an in-house-developed centralized VCS called Piper, built to run as a distributed microservice in our production environment.<a contenteditable="false" data-primary="Piper" data-type="indexterm" id="id-dBUBCgH9f1">&nbsp;</a><a contenteditable="false" data-primary="centralized version control systems (VCSs)" data-secondary="in-house-developed, Piper at Google" data-type="indexterm" id="id-5RUBs4H9fb">&nbsp;</a> This has allowed us to use Google-standard storage, communication, and Compute as a Service technology to provide a globally available VCS storing more than 80 TB of content and metadata. The Piper monorepo is then simultaneously edited and committed to by many thousands of engineers every day. Between humans and semiautomated processes that make use of version control (or improve things checked into VCS), we’ll regularly handle 60,000 to 70,000 commits to the repository per work day. Binary artifacts are fairly common because the full repository isn’t transmitted and thus the normal costs of binary artifacts don’t really apply. Because of the focus on Google-scale from the earliest conception, operations in this VCS ecosystem are still cheap at human scale: it takes perhaps 15 seconds total to create a new client at trunk, add a file, and commit an (unreviewed) change to Piper. This low-latency interaction and well-understood/well-designed scaling simplifies a lot of the developer experience.</p>

<p>By virtue of Piper being an in-house product, we have the ability to customize it and enforce whatever source control policies we choose. <a contenteditable="false" data-primary="ownership of code" data-secondary="granular ownership in Google monorepo" data-type="indexterm" id="id-5RU3C5h9fb">&nbsp;</a>For instance, we have a notion of granular ownership in the monorepo: at every level of the file hierarchy, we can find OWNERS files that list the usernames of engineers that are allowed to approve commits within that subtree of the repository (in addition to the OWNERS that are listed at higher levels in the tree). In an environment with many repositories, this might have been achieved by having separate repositories with filesystem permissions enforcement controlling commit access or via a Git “commit hook” (action triggered at commit time) to do a separate permissions check. By controlling the VCS, we can make the concept of ownership and approval more explicit and enforced by the VCS during an attempted commit operation. The model is also flexible: ownership is just a text file, not tied to a physical separation of repositories, so it is trivial to update as the result of a team transfer or organization restructuring.</p>

<section data-type="sect2" id="one_version">
<h2>One Version</h2>

<p>The incredible scaling powers of Piper alone wouldn’t allow the sort of collaboration that we rely upon. <a contenteditable="false" data-primary="One-Version Rule" data-type="indexterm" id="id-g8UVCes9IWfv">&nbsp;</a><a contenteditable="false" data-primary="version control" data-secondary="at Google" data-tertiary="One-Version Rule" data-type="indexterm" id="id-LRUpsLs8IQf3">&nbsp;</a>As we said earlier: version control is also about policy. In addition to our VCS, one key feature of Google’s version control policy is what we’ve come to refer to as "One Version." This <a contenteditable="false" data-primary="source of truth" data-secondary="One Version as single source of truth" data-type="indexterm" id="id-2mUEHlsVIGf1">&nbsp;</a>extends the "Single Source of Truth" concept we looked at earlier—ensuring that a developer knows which branch and repository is their source of truth—to something like “For every dependency in our repository, there must be only one version of that dependency to choose.”<sup><a data-type="noteref" id="ch01fn157-marker" href="#ch01fn157">9</a></sup> For third-party packages, this means that there can be only a single version of that package checked into our repository, in the steady state.<sup><a data-type="noteref" id="ch01fn158-marker" href="#ch01fn158">10</a></sup> For internal packages, this means no forking without repackaging/renaming: it must be technologically safe to mix both the original and the fork into the same project with no special effort. This is a powerful feature for our ecosystem: there are very few packages with restrictions like “If you include this package (A), you cannot include other package (B).”</p>

<p>This notion of having a single copy on a single branch in a single repository as our Source of Truth is intuitive but also has some subtle depth in application. Let’s investigate a scenario in which we have a monorepo (and thus arguably have fulfilled the letter of the law on Single Source of Truth), but have allowed forks of our libraries to propagate on trunk.</p>
</section>

<section data-type="sect2" id="scenario_multiple_available_versions">
<h2>Scenario: Multiple Available Versions</h2>

<p>Imagine the following scenario: some team discovers a bug in common infrastructure<a contenteditable="false" data-primary="version control" data-secondary="at Google" data-tertiary="scenario, multiple available versions" data-type="indexterm" id="id-LRUjCLsQcQf3">&nbsp;</a> code (in our case, Abseil or Guava or the like). Rather than fix it in place, the team decides to fork that infrastructure and tweak it to work around the bug—without renaming the library or the symbols. It informs other teams near them, “Hey, we have an improved version of Abseil checked in over here: check it out.” A few other teams build libraries that themselves rely on this new fork.</p>

<p>As we’ll see in <a data-type="xref" href="ch21.html#dependency_management">Dependency Management</a>, we’re now in a dangerous situation. If any project in the codebase comes to depend on both the original and the forked versions of Abseil simultaneously, in the best case, the build fails. In the worst case, we’ll be subjected to difficult-to-understand runtime bugs stemming from linking in two mismatched versions of the same library. The “fork” has effectively added a coloring/partitioning property to the codebase: the transitive dependency set for any given target must include exactly one copy of this library. Any link added from the “original flavor” partition of the codebase to the “new fork” partition will likely break things. This means that in the end that something as simple as “adding a new dependency” becomes an operation that might require running all tests for the entire codebase, to ensure that we haven’t violated one of these partitioning requirements. That’s expensive, unfortunate, and doesn’t scale well.</p>

<p>In some cases, we might be able to hack things together in a way to allow a resulting executable to function correctly.<a contenteditable="false" data-primary="Java" data-secondary="shading in" data-type="indexterm" id="id-BRUGCLhMcJfb">&nbsp;</a><a contenteditable="false" data-primary="shading (in Java)" data-type="indexterm" id="id-nMUxs2hBc7fo">&nbsp;</a> Java, for instance, has a relatively standard practice called <a href="https://oreil.ly/RuWX3"><em>shading</em></a>, which tweaks the names of the internal dependencies of a library to hide those dependencies from the rest of the application. When dealing with functions, this is technically sound, even if it is theoretically a bit of a hack. When dealing with types that can be passed from one package to another, shading solutions work neither in theory nor in practice. As far as we know, any technological trickery that allows multiple isolated versions of a library to function in the same binary share this limitation: that approach will work for functions, but there is no good (efficient) solution to shading types—multiple versions for any library that provides a vocabulary type (or any higher-level construct) will fail. Shading and related approaches are patching over the underlying issue: multiple versions of the same dependency are needed. (We’ll discuss how to minimize that in general in <a data-type="xref" href="ch21.html#dependency_management">Dependency Management</a>.)</p>

<p>Any policy system that allows for multiple versions in the same codebase is allowing for the possibility of these costly incompatibilities. It’s possible that you’ll get away with it for a while (we certainly have a number of small violations of this policy), but in general, any multiple-version situation has a very real possibility of leading to big problems.</p>
</section>

<section data-type="sect2" id="the_quotation_markone_versionquotation">
<h2>The “One-Version” Rule</h2>

<p>With that example in mind, on top of the Single Source of Truth model, we can hopefully <a contenteditable="false" data-primary="One-Version Rule" data-type="indexterm" id="id-2mU9ClsvTGf1">&nbsp;</a>understand the depth <a contenteditable="false" data-primary="version control" data-secondary="at Google" data-tertiary="One-Version Rule" data-type="indexterm" id="id-BRUesQszTJfb">&nbsp;</a>of this seemingly simple rule for source control and branch management:</p>

<blockquote>
<p>Developers must never have a choice of “What version of this component should I depend upon?”</p>
</blockquote>

<p>Colloquially, this becomes something like a “One-Version Rule.” In practice, “One-Version” is not hard and fast,<sup><a data-type="noteref" id="ch01fn159-marker" href="#ch01fn159">11</a></sup> but phrasing this around limiting the versions that can be <em>chosen</em> when adding a new dependency conveys a very powerful understanding.</p>

<p>For an individual developer, lack of choice can seem like an arbitrary impediment. Yet we see again and again that for an organization, it’s a critical component in efficient scaling. <a contenteditable="false" data-primary="consistency within the codebase" data-secondary="One-Version Rule and" data-type="indexterm" id="id-41UECOI7Tefe">&nbsp;</a>Consistency has a profound importance at all levels in an organization. From one perspective, this is a direct side effect of discussions about consistency and ensuring the ability to leverage consistent “choke points.”</p>
</section>

<section data-type="sect2" id="left_parenthesisnearlyright_parenthesis">
<h2>(Nearly) No Long-Lived Branches</h2>

<p>There are several deeper<a contenteditable="false" data-primary="version control" data-secondary="at Google" data-tertiary="few long-lived branches" data-type="indexterm" id="id-BRUGCQsdfJfb">&nbsp;</a> ideas and policies<a contenteditable="false" data-primary="branch management" data-secondary="few long-lived branches at Google" data-type="indexterm" id="id-nMUxsnsQf7fo">&nbsp;</a> implicit in our One-Version Rule; foremost among them: development branches should be minimal, or at best be very short lived.<a contenteditable="false" data-primary="DevOps Research and Assessment (DORA)" data-secondary="no long-lived branches and" data-type="indexterm" id="id-41U5HRsdfefe">&nbsp;</a> This follows from a lot of published work over the past 20 years, from Agile processes to DORA research results on trunk-based development and even Phoenix Project<sup><a data-type="noteref" id="ch01fn160-marker" href="#ch01fn160">12</a></sup> lessons on “reducing work-in-progress.” When we include the idea of pending work as akin to a dev branch, this further reinforces that work should be done in small increments against trunk, committed regularly.<a contenteditable="false" data-primary="dev branches" data-secondary="no long-lived branches and" data-type="indexterm" id="id-NRUEIEsBfVf2">&nbsp;</a></p>

<p>As a counterexample: in a development community that depends heavily on long-lived development branches, it isn’t difficult to imagine opportunity for choice creeping back in.</p>

<p>Imagine this scenario: some infrastructure team is working on a new Widget, better than the old one. Excitement grows. Other newly started projects ask, “Can we depend on your new Widget?” Obviously, this can be handled if you’ve invested in codebase visibility policies, but the deep problem happens when the new Widget is “allowed” but only exists in a parallel branch. Remember: new development must not have a choice when adding a dependency. That new Widget should be committed to trunk, disabled from the runtime until it’s ready, and hidden from other developers by visibility if possible—or the two Widget options should be designed such that they can coexist, linked into the same programs.</p>

<p>Interestingly, there is already evidence of this being important in the industry. In Accelerate<a contenteditable="false" data-primary="trunk-based development" data-secondary="predictive relationship between high-performing organizations and" data-type="indexterm" id="id-8RU5CvI0fOfm">&nbsp;</a> and the most recent State of DevOps reports, DORA points out that there is a predictive relationship between trunk-based development and high-performing software organizations.<a contenteditable="false" data-primary="DevOps Research and Assessment (DORA)" data-secondary="predictive relationship between trunk-based development and high-performing organizations" data-type="indexterm" id="id-NRUGsBIBfVf2">&nbsp;</a> Google is not the only organization to have discovered this—nor did we necessarily have expected outcomes in mind when these policies evolved—it just seemed like nothing else worked. DORA’s result certainly matches our <span class="keep-together">experience.</span></p>

<p>Our policies<a contenteditable="false" data-primary="large-scale changes" data-secondary="importance of trunk-based development and" data-type="indexterm" id="id-NRU8C4cBfVf2">&nbsp;</a> and tools for large-scale changes (LSCs; see <a data-type="xref" href="ch22.html#large-scale_changes">Large-Scale Changes</a>) put additional weight on the importance of trunk-based development: broad/shallow changes that are applied across the codebase are already a massive (often tedious) undertaking when modifying everything checked in to the trunk branch. Having an unbounded number of additional dev branches that might need to be refactored at the same time would be an awfully large tax on executing those types of changes, finding an ever-expanding set of hidden branches. In a DVCS model, it might not even be possible to identify all of those branches.</p>

<p>Of course, our experience is not universal. You might find yourself in unusual situations that require longer-lived dev branches in parallel to (and regularly merged with) trunk.</p>

<p>Those scenarios should be rare, and should be understood to be expensive. Across the roughly 1,000 teams that work in the Google monorepo, there are only a couple that have such a dev branch.<sup><a data-type="noteref" id="ch01fn161-marker" href="#ch01fn161">13</a></sup> Usually these exist for a very specific (and very unusual) reason. Most of those reasons boil down to some variation of “We have an unusual requirement for compatibility over time.” Oftentimes this is a matter of ensuring compatibility for data at rest across versions: readers and writers of some file format need to agree on that format over time even if the reader or writer implementations are modified. Other times, long-lived dev branches might come from promising API compatibility over time—when One Version isn’t enough and we need to promise that an older version of a microservice client still works with a newer server (or vice versa). That can be a very challenging requirement, something that you should not promise lightly for an actively evolving API, and something you should treat carefully to ensure that period of time doesn’t accidentally begin to grow. Dependency across time in any form is far more costly and complicated than code that is time invariant. Internally, Google production services make relatively few promises of that form.<sup><a data-type="noteref" id="ch01fn162-marker" href="#ch01fn162">14</a></sup> We also benefit greatly from a cap on potential version skew imposed by our “build horizon”: every job in production needs to be rebuilt and redeployed every six months, maximum. (Usually it is far more frequent than that.)</p>

<p>We’re sure there are other situations that might necessitate long-lived dev branches. Just make sure to keep them rare. If you adopt other tools and practices discussed in this book, many will tend to exert pressure against long-lived dev branches. Automation and tooling that works great at trunk and fails (or takes more effort) for a dev branch can help encourage developers to stay current.</p>
</section>

<section data-type="sect2" id="what_about_release_branchesquestion_mar">
<h2>What About Release Branches?</h2>

<p>Many Google<a contenteditable="false" data-primary="version control" data-secondary="at Google" data-tertiary="release branches" data-type="indexterm" id="id-nMUMCnsvt7fo">&nbsp;</a> teams use release branches, with limited cherry picks. <a contenteditable="false" data-primary="release branches" data-secondary="Google and" data-type="indexterm" id="id-41U7sRsltefe">&nbsp;</a>If you’re going to put out a monthly release and continue working toward the next release, it’s perfectly reasonable to make a release branch. Similarly, if you’re going to ship devices to customers, it’s valuable to know exactly what version is out “in the field.” Use caution and reason, keep cherry picks to a minimum, and don’t plan to remerge with trunk. Our various teams have all sorts of policies about release branches given that relatively few teams have arrived at the sort of rapid release cadence promised by CD (see <a data-type="xref" href="ch24.html#continuous_delivery-id00035">Continuous Delivery</a>) that obviates the need or desire for a release branch. Generally speaking, release branches don’t cause any widespread cost in our experience. Or, at least, no noticeable cost above and beyond the additional inherent cost to the VCS.<a contenteditable="false" data-primary="version control" data-secondary="at Google" data-startref="ix_VCGoo" data-type="indexterm" id="id-NRUmhEs9tVf2">&nbsp;</a></p>
</section>
</section>

<section data-type="sect1" id="monorepos">
<h1>Monorepos</h1>

<p>In 2016, we published a (highly cited, much discussed) paper<a contenteditable="false" data-primary="version control" data-secondary="monorepos" data-type="indexterm" id="id-dBUBC3syt1">&nbsp;</a> on <a contenteditable="false" data-primary="monorepos" data-type="indexterm" id="id-5RUBsWsetb">&nbsp;</a>Google’s monorepo approach.<sup><a data-type="noteref" id="id-9MGtLHzsOte-marker" href="#id-9MGtLHzsOte">15</a></sup> The monorepo approach has some inherent benefits, and chief among them is<a contenteditable="false" data-primary="One-Version Rule" data-secondary="monorepos and" data-type="indexterm" id="id-g8UEhesxt1">&nbsp;</a> that adhering to One Version is trivial: it’s usually more difficult to violate One Version than it would be to do the right thing. There’s no process of deciding which versions of anything are official, or discovering which repositories are important. Building tools to understand the state of the build (see <a data-type="xref" href="ch23.html#continuous_integration">Continuous Integration</a>) doesn’t also require discovering where important repositories exist. Consistency helps scale up the impact of introducing new tools and optimizations. By and large, engineers can see what everyone else is doing and use that to inform their own choices in code and system design. These are all very good things.</p>

<p>Given all of that and our belief in the merits of the One-Version Rule, it is reasonable to ask whether a monorepo is the One True Way. By comparison, the open source community seems to work just fine with a “manyrepo” approach built on a seemingly infinite number of noncoordinating and nonsynchronized project repositories.</p>

<p>In short: no, we don’t think the monorepo approach as we’ve described it is the perfect answer for everyone. Continuing the parallel between filesystem format and VCS, it’s easy to imagine deciding between using 10 drives to provide one very large logical filesystem or 10 smaller filesystems accessed separately. In a filesystem world, there are pros and cons to both. Technical issues when evaluating filesystem choice would range from outage resilience, size constraints, performance characteristics, and so on. Usability issues would likely focus more on the ability to reference files across filesystem boundaries, add symlinks, and synchronize files.</p>

<p>A very similar set of issues governs whether to prefer a monorepo or a collection of finer-grained repositories.<a contenteditable="false" data-primary="repositories" data-secondary="finer-grained vs. monorepos" data-type="indexterm" id="id-g8UVCLIxt1">&nbsp;</a> The specific decisions of how to store your source code (or store your files, for that matter) are easily debatable, and in some cases, the particulars of your organization and your workflow are going to matter more than others. These are decisions you’ll need to make yourself.</p>

<p>What is important is not whether we focus on monorepo; it’s to adhere to the One-Version principle to the greatest extent possible: developers must not have a <em>choice</em> when adding a dependency onto some library that is already in use in the organization. Choice violations of the One-Version Rule lead to merge strategy discussions, diamond dependencies, lost work, and wasted effort.</p>

<p>Software engineering tools including both VCS and build systems are increasingly providing mechanisms <a contenteditable="false" data-primary="VCSs (version control systems)" data-secondary="blending between fine-grained repositories and monorepos" data-type="indexterm" id="id-2mU9C8Tdt9">&nbsp;</a>to smartly blend between fine-grained repositories and monorepos to provide an experience akin to the monorepo—an agreed-upon ordering of commits and understanding of the dependency graph.<a contenteditable="false" data-primary="Git" data-secondary="synthesizing monorepo behavior" data-type="indexterm" id="id-BRUesaT1tA">&nbsp;</a> Git submodules, Bazel with external dependencies, and CMake subprojects all allow modern developers to synthesize something weakly approximating monorepo behavior without the costs and downsides of a monorepo.<sup><a data-type="noteref" id="ch01fn163-marker" href="#ch01fn163">16</a></sup> For instance, fine-grained repositories are easier to deal with in terms of scale (Git often has performance issues after a few million commits and tends to be slow to clone when repositories include large binary artifacts) and storage (VCS metadata can add up, especially if you have binary artifacts in your version control system). Fine-grained repositories in a federated/virtual-monorepo (VMR)–style repository can make it easier to isolate experimental or top-secret projects while still holding to One Version and allowing access to common utilities.<a contenteditable="false" data-primary="virtual monorepos (VMRs)" data-type="indexterm" id="id-41UDhETltD">&nbsp;</a><a contenteditable="false" data-primary="federated/virtual-monorepo (VMR)–style repository" data-type="indexterm" id="id-8RU0IxT5tk">&nbsp;</a></p>

<p>To put it another way: if every project in your organization has the same secrecy, legal, privacy, and security requirements,<sup><a data-type="noteref" id="ch01fn164-marker" href="#ch01fn164">17</a></sup> a true monorepo is a fine way to go. Otherwise, <em>aim</em> for the functionality of a monorepo, but allow yourself the flexibility of implementing that experience in a different fashion. If you can manage with disjoint repositories and adhere to One Version or your workload is all disconnected enough to allow truly separate repositories, great. Otherwise, synthesizing something like a VMR in some fashion may represent the best of both worlds.</p>

<p>After all, your choice of filesystem format really doesn’t matter as much as what you write to it.</p>
</section>

<section data-type="sect1" id="future_of_version_control">
<h1>Future of Version Control</h1>

<p>Google isn’t the only organization to publicly discuss the benefits of a monorepo approach.<a contenteditable="false" data-primary="version control" data-secondary="future of" data-type="indexterm" id="id-5RU3CWskSb">&nbsp;</a> Microsoft, Facebook, Netflix, and Uber have also publicly mentioned their reliance on the approach.<a contenteditable="false" data-primary="monorepos" data-secondary="organizations citing benefits of" data-type="indexterm" id="id-enU9sOsqSK">&nbsp;</a> DORA has published about it extensively. It’s vaguely possible that all of these successful, long-lived companies are misguided, or at least that their situations are sufficiently different as to be inapplicable to the average smaller organization. Although it’s possible, we think it is unlikely.</p>

<p>Most arguments against monorepos focus on the <a contenteditable="false" data-primary="monorepos" data-secondary="arguments against" data-type="indexterm" id="id-enUACBHqSK">&nbsp;</a>technical limitations of having a single large repository. If cloning a repository from upstream is quick and cheap, developers are more likely to keep changes small and isolated (and to avoid making mistakes with committing to the wrong work-in-progress branch). If cloning a repository (or doing some other common VCS operation) takes hours of wasted developer time, you can easily see why an organization would shy away from reliance on such a large repository/operation. We luckily avoided this pitfall by focusing on providing a VCS that scales massively.</p>

<p>Looking at the past <a contenteditable="false" data-primary="Git" data-secondary="improvements to" data-type="indexterm" id="id-g8UVC5hLS1">&nbsp;</a>few years of major improvements to Git, there’s clearly a lot of work being done to support larger repositories: shallow clones, sparse branches, better optimization, and more. We expect this to continue and the importance of “but we need to keep the repository small” to diminish.</p>

<p>The other major argument against monorepos is that it doesn’t match how development happens in the Open Source Software (OSS) world.<a contenteditable="false" data-primary="Open Source Software (OSS)" data-secondary="monorepos and" data-type="indexterm" id="id-LRUjCgI0SN">&nbsp;</a> Although true, many of the practices in the OSS world come (rightly) from prioritizing freedom, lack of coordination, and lack of computing resources. Separate projects in the OSS world are effectively separate organizations that happen to be able to see one another’s code. Within the boundaries of an organization, we can make more assumptions: we can assume the availability of compute resources, we can assume coordination, and we can assume that there is some amount of centralized authority.</p>

<p>A less common but perhaps more legitimate concern with the monorepo approach is that as your organization scales up, it is less and less likely that every piece of code is subject to exactly the same legal, compliance, regulatory, secrecy, and privacy requirements. One native advantage of a manyrepo approach is that separate repositories are obviously capable of having different sets of authorized developers, visibility, permissions, and so on. Stitching that feature into a monorepo can be done but implies some ongoing carrying costs in terms of customization and maintenance.</p>

<p>At the same time, the industry seems to be inventing lightweight interrepository linkage over and over again. Sometimes, this is in the VCS (Git submodules) or the build system. So long as a collection of repositories have a consistent understanding of “what is trunk,” “which change happened first,” and mechanisms to describe dependencies, we can easily imagine stitching together a disparate collection of physical repositories into one larger VMR. <a contenteditable="false" data-primary="virtual monorepos (VMRs)" data-type="indexterm" id="id-BRUGCaTvSA">&nbsp;</a>Even though Piper has done very well for us, investing in a highly scaling VMR and tools to manage it and relying on off-the-shelf customization for per-repository policy requirements could have been a better <span class="keep-together">investment.</span></p>

<p>As soon as someone builds a sufficiently large nugget of compatible and interdependent projects in the OSS community and publishes a VMR view of those packages, we suspect that OSS developer practices will begin to change. We see glimpses of this in the tools that <em>could</em> synthesize a virtual monorepo as well as in the work done by (for instance) large Linux distributions discovering and publishing mutually compatible revisions of thousands of packages. With unit tests, CI, and automatic version bumping for new submissions to one of those revisions, enabling a package owner to update trunk for their package (in nonbreaking fashion, of course), we think that model will catch on in the open source world. It is just a matter of efficiency, after all: a (virtual) monorepo approach with a One-Version Rule cuts down the complexity of software development by a whole (difficult) dimension: time.</p>

<p>We expect<a contenteditable="false" data-primary="centralized version control systems (VCSs)" data-secondary="future of" data-type="indexterm" id="id-41UECwtjSD">&nbsp;</a> version control and dependency management to evolve in this direction in the next 10 to 20 years: VCSs will focus on <em>allowing</em> larger repositories with better performance scaling, but also removing the need for larger repositories by providing better mechanisms to stitch them together across project and organizational boundaries. Someone, perhaps the existing package management groups or Linux distributors, will catalyze a de facto standard virtual monorepo. Depending on the utilities in that monorepo will provide easy access to a compatible set of dependencies as one unit. We’ll more generally recognize that version numbers are timestamps, and that allowing version skew adds a dimensionality complexity (time) that costs a lot—and that we can learn to avoid. It starts with something logically like a monorepo.</p>
</section>

<section data-type="sect1" id="conclusion-id00020">
<h1>Conclusion</h1>

<p>Version control systems are a natural extension of the collaboration challenges and opportunities provided by technology, especially shared compute resources and computer networks. They have historically evolved in lockstep with the norms of software engineering as we understand them at the time.</p>

<p>Early systems provided simplistic file-granularity locking. As typical software engineering projects and teams grew larger, the scaling problems with that approach became apparent, and our understanding of version control changed to match those challenges. Then, as development increasingly moved toward an OSS model with distributed contributors, VCSs became more decentralized. We expect a shift in VCS technology that assumes constant network availability, focusing more on storage and build in the cloud to avoid transmitting unnecessary files and artifacts. This is increasingly critical for large, long-lived software engineering projects, even if it means a change in approach compared to simple single-dev/single-machine programming projects. This shift to cloud will make concrete what has emerged with DVCS approaches: even if we allow distributed development, something must still be centrally recognized as the Source of Truth.</p>

<p>The current DVCS decentralization is a sensible reaction of the technology to the needs of the industry (especially the open source community). However, DVCS configuration needs to be tightly controlled and coupled with branch management policies that make sense for your organization. It also can often introduce unexpected scaling problems: perfect fidelity offline operation requires a lot more local data. Failure to rein in the potential complexity of a branching free-for-all can lead to a potentially unbounded amount of overhead between developers and deployment of that code. However, complex technology doesn’t need to be used in a complex fashion: as we see in monorepo and trunk-based development models, keeping branch policies simple generally leads to better engineering outcomes.</p>

<p>Choice leads to costs here. We highly endorse the One-Version Rule presented here: developers within an organization must not have a choice where to commit, or which version of an existing component to depend upon. There are few policies we’re aware of that can have such an impact on the organization: although it might be annoying for individual developers, in the aggregate, the end result is far better.</p>
</section>

<section data-type="sect1" id="tlsemicolondrs-id00122">
<h1>TL;DRs</h1>

<ul>
	<li>
	<p>Use version control for any software development project larger than "toy project with only one developer that will never be updated."</p>
	</li>
	<li>
	<p>There’s an inherent scaling problem when there are choices in “which version of this should I depend upon?”</p>
	</li>
	<li>
	<p>One-Version Rules are surprisingly important for organizational efficiency. Removing choices in where to commit or what to depend upon can result in significant simplification.</p>
	</li>
	<li>
	<p>In some languages, you might be able to spend some effort to dodge this with technical approaches like shading, separate compilation, linker hiding, and so on. The work to get those approaches working is entirely lost labor—your software engineers aren’t producing anything, they’re just working around technical debts.</p>
	</li>
	<li>
	<p>Previous research (DORA/State of DevOps/Accelerate) has shown that trunk-based development is a predictive factor in high-performing development organizations. Long-lived dev branches are not a good default plan.</p>
	</li>
	<li>
	<p>Use whatever version control system makes sense for you. If your organization wants to prioritize separate repositories for separate projects, it’s still probably wise for interrepository dependencies to be unpinned/“at head”/“trunk based.” There are an increasing number of VCS and build system facilities that allow you to have both small, fine-grained repositories as well as a consistent “virtual” head/trunk notion for the whole organization.</p>
	</li>
</ul>
</section>
<div data-type="footnotes"><p data-type="footnote" id="ch01fn148"><sup><a href="#ch01fn148-marker">1</a></sup>The DevOps Research Association, which was acquired by Google between the first draft of this chapter and publication, has published extensively on this in the annual “State of DevOps Report” and the book <em>Accelerate</em>. As near as we can tell, it popularized the terminology <em>trunk-based development</em>.</p><p data-type="footnote" id="ch01fn150"><sup><a href="#ch01fn150-marker">2</a></sup>Although the formal idea of what is and is not a repository changes a bit depending on your choice of VCS, and the terminology will vary.</p><p data-type="footnote" id="ch01fn151"><sup><a href="#ch01fn151-marker">3</a></sup>Indeed, I’ve given several public talks that use “adoption of version control” as the canonical example of how the norms of software engineering can <em>and do</em> evolve over time. In my experience, in the 1990s, version control was pretty well understood as a best practice but not universally followed. In the early 2000s, it was still common to encounter professional groups that didn’t use it. Today, the use of tools like Git seems ubiquitous even among college students working on personal projects. Some of this rise in adoption is likely due to better user experience in the tools (nobody wants to go back to RCS), but the role of experience and changing norms is significant.</p><p data-type="footnote" id="ch01fn152"><sup><a href="#ch01fn152-marker">4</a></sup>Anecdote: To illustrate this, I looked for information on what pending/unsubmitted edits Googlers had outstanding for a semipopular file in my most recent project. At the time of this writing, 27 changes are pending, 12 from people on my team, 5 from people on related teams, and 10 from engineers I’ve never met. This is basically working as expected. Technical systems or policies that require out-of-band coordination certainly don’t scale to 24/7 software engineering in distributed locations.</p><p data-type="footnote" id="ch01fn153"><sup><a href="#ch01fn153-marker">5</a></sup>Stack Overflow <a href="https://oreil.ly/D173D">Developer Survey Results</a>, 2018.</p><p data-type="footnote" id="ch01fn154"><sup><a href="#ch01fn154-marker">6</a></sup>Monotonically increasing version numbers, rather than commit hashes, are particularly troublesome. Many systems and scripts have grown up in the Google developer ecosystem that assume that the numeric ordering of commits is the same as the temporal order—undoing those hidden dependencies is difficult.</p><p data-type="footnote" id="ch01fn155"><sup><a href="#ch01fn155-marker">7</a></sup>For that matter, as of the publication of the Monorepo paper, the repository itself had something like 86 TB of data and metadata, ignoring release branches. Fitting that onto a developer workstation directly would be…challenging.</p><p data-type="footnote" id="ch01fn156"><sup><a href="#ch01fn156-marker">8</a></sup>Recent informal Twitter polling suggests about 25% of software engineers have been subjected to “regularly scheduled” merge strategy meetings.</p><p data-type="footnote" id="ch01fn157"><sup><a href="#ch01fn157-marker">9</a></sup>For example, during an upgrade operation, there might be two versions checked in, but if a developer is adding a new dependency on an existing package, there should be no <em>choice</em> in which version to depend upon.</p><p data-type="footnote" id="ch01fn158"><sup><a href="#ch01fn158-marker">10</a></sup>That said, we fail at this in many cases because external packages sometimes have pinned copies of their own dependencies bundled in their source release. You can read more on how all of this goes wrong in <a data-type="xref" href="ch21.html#dependency_management">Dependency Management</a>.</p><p data-type="footnote" id="ch01fn159"><sup><a href="#ch01fn159-marker">11</a></sup>For instance, if there are external/third-party libraries that are periodically updated, it might be infeasible to update that library and update all use of it in a single atomic change. As such, it is often necessary to add a new version of that library, prevent new users from adding dependencies on the old one, and incrementally switch usage from old to new.</p><p data-type="footnote" id="ch01fn160"><sup><a href="#ch01fn160-marker">12</a></sup>Kevin Behr, Gene Kim, and George Spafford, <a href="https://oreil.ly/LhAOC"><em>The Phoenix Project</em></a> (Portland: IT Revolution Press, 2018).</p><p data-type="footnote" id="ch01fn161"><sup><a href="#ch01fn161-marker">13</a></sup>It’s difficult to get a precise count, but the number of such teams is almost certainly fewer than 10.</p><p data-type="footnote" id="ch01fn162"><sup><a href="#ch01fn162-marker">14</a></sup>Cloud interfaces are a different story.</p><p data-type="footnote" id="id-9MGtLHzsOte"><sup><a href="#id-9MGtLHzsOte-marker">15</a></sup>Rachel Potvin and Josh Levenberg, "Why Google stores billions of lines of code in a single repository," <em>Communications of the ACM</em>, 59 No. 7 (2016): 78-87.</p><p data-type="footnote" id="ch01fn163"><sup><a href="#ch01fn163-marker">16</a></sup>We don’t think we’ve seen anything do this particularly smoothly, but the interrepository dependencies/virtual monorepo idea is clearly in the air.</p><p data-type="footnote" id="ch01fn164"><sup><a href="#ch01fn164-marker">17</a></sup>Or you have the willingness and capability to customize your VCS—and maintain that customization for the lifetime of your codebase/organization. Then again, maybe don’t plan on that as an option; that is a lot of overhead.</p></div></section>

  </body>
</html>
